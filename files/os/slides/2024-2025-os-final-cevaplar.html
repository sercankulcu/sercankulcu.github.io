<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>İşletim Sistemleri 2024-2025 Final Soru ve Cevapları</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f4f4f4;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .question {
            margin: 20px 0;
            border-left: 4px solid #007BFF;
            padding-left: 15px;
        }
        .question h2 {
            color: #007BFF;
            margin-bottom: 10px;
        }
        .answer {
            margin-bottom: 20px;
			display: none;
        }
        .answer h3 {
            color: #444;
            margin-top: 15px;
        }
        .answer p, .answer ul, .answer ol {
            margin: 10px 0;
            color: #333;
        }
        .answer ul, .answer ol {
            padding-left: 20px;
        }
        .answer ul li, .answer ol li {
            margin-bottom: 8px;
        }
        .example {
            background: #e9ecef;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        .toggle-btn {
            background: #007BFF;
            color: #fff;
            border: none;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            margin-bottom: 10px;
            display: inline-block;
        }
        .toggle-btn:hover {
            background: #0056b3;
        }
        .answer.hidden {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>İşletim Sistemleri Soru ve Cevapları</h1>
        <p style="text-align: center; color: #555;">2023-2024 Final Sınavı</p>

        <!-- Soru 1 -->
        <div class="question">
            <h2>Soru 1: Bilgisayarda birçok süreç (process) aynı anda çalışıyor sanırız. Fiziksel olarak sadece 1 adet işlemci bulunmasına rağmen birden fazla sürecin aynı anda çalışıyor görünmesi nasıl sağlanır?</h2>
            <button class="toggle-btn" onclick="toggleAnswer('answer1')">Cevabı Göster/Gizle</button>
            <div class="answer" id="answer1">
                <h3>Cevap:</h3>
                <p>Tek işlemcili bir sistemde birden fazla sürecin aynı anda çalışıyor gibi görünmesi, işletim sisteminin <strong>çoklu görev (multitasking)</strong> ve <strong>bağlam anahtarlama (context switching)</strong> mekanizmaları sayesinde sağlanır. Bu süreç, CPU'nun süreçler arasında hızlı geçiş yapmasıyla mümkün olur ve kullanıcıya süreçlerin paralel çalıştığı izlenimi verir. Aşağıda bu mekanizma detaylı bir şekilde açıklanmıştır:</p>
                
                <h3>1. Çoklu Görev (Multitasking)</h3>
                <p>Çoklu görev, işletim sisteminin birden fazla süreci aynı anda yönetmesini sağlar. Tek işlemcili sistemlerde, CPU aynı anda yalnızca bir süreci çalıştırabilir. Ancak işletim sistemi, süreçlere kısa süreli CPU zaman dilimleri (time slices veya quantum) atayarak, hepsinin çalıştığı illüzyonunu yaratır. Bu, genellikle <strong>önleyici çoklu görev (preemptive multitasking)</strong> ile gerçekleştirilir:</p>
                <ul>
                    <li><strong>Önleyici Çoklu Görev:</strong> İşletim sistemi, bir sürecin CPU'yu ne kadar süre kullanacağını belirler. Süreç, zaman dilimi dolduğunda veya daha yüksek öncelikli bir süreç hazır olduğunda kesilir.</li>
                    <li><strong>Zaman Paylaşımı:</strong> CPU zamanı, süreçler arasında adil bir şekilde paylaştırılır (örneğin, Round Robin algoritması).</li>
                </ul>

                <h3>2. Bağlam Anahtarlama (Context Switching)</h3>
                <p>Bağlam anahtarlama, CPU'nun bir süreçten diğerine geçiş yapması için gereken işlemdir. İşletim sistemi, mevcut sürecin durumunu kaydeder ve yeni bir sürecin durumunu yükler:</p>
                <ul>
                    <li><strong>Durum Kaydetme:</strong> Çalışan sürecin program sayacı (program counter), yazmaçlar (registers) ve yığın işaretçisi gibi bilgileri, <strong>Süreç Denetim Bloğu (PCB)</strong>'na kaydedilir.</li>
                    <li><strong>Yeni Durum Yükleme:</strong> Bir sonraki sürecin PCB'sinden bilgiler alınır ve CPU yazmaçlarına yüklenir.</li>
                    <li><strong>CPU Kontrolü:</strong> CPU, yeni sürecin kodunu yürütmeye başlar.</li>
                </ul>
                <p>Bağlam anahtarlama, mikro veya nanosaniye mertebesinde gerçekleşir, bu nedenle kullanıcı geçişlerin farkına varmaz.</p>

                <h3>3. Çizelgeleme (Scheduling)</h3>
                <p>İşletim sistemi, hangi sürecin ne zaman çalışacağını belirlemek için çizelgeleme algoritmaları kullanır:</p>
                <ul>
                    <li><strong>Round Robin:</strong> Süreçlere eşit zaman dilimleri atanır.</li>
                    <li><strong>Öncelik Tabanlı:</strong> Yüksek öncelikli süreçler önce çalışır.</li>
                    <li><strong>En Kısa İş Önce:</strong> Hızlı tamamlanacak süreçler önceliklendirilir.</li>
                </ul>

                <h3>4. Kesmeler (Interrupts)</h3>
                <p>Kesmeler, bağlam anahtarlamasını tetikler. Örneğin, bir zamanlayıcı kesmesi (timer interrupt), bir sürecin zaman diliminin dolduğunu bildirir ve başka bir sürece geçiş yapılır.</p>

                <h3>Örnek:</h3>
                <div class="example">
                    <p>Bir sistemde üç süreç çalışıyor: metin editörü (P1), web tarayıcı (P2), müzik çalar (P3). İşletim sistemi:</p>
                    <ol>
                        <li>P1'e 10 ms verir, P1 bir belgeyi düzenler.</li>
                        <li>Zamanlayıcı kesmesiyle P1 durdurulur, durumu kaydedilir.</li>
                        <li>P2 çalıştırılır, bir web sayfası yükler (10 ms).</li>
                        <li>P3 çalıştırılır, müzik çalar (10 ms).</li>
                    </ol>
                    <p>Kullanıcı, tüm süreçlerin aynı anda çalıştığını düşünür, ancak CPU her seferinde bir süreci çalıştırır.</p>
                </div>

                <h3>Analitik Perspektif:</h3>
                <p>Bağlam anahtarlamasının hızı ve çizelgelemenin etkinliği, çoklu görev illüzyonunu sağlar. Ancak, sık bağlam anahtarlamaları ek yük (overhead) yaratabilir. Performans, CPU zamanının süreçler arasında adil ve verimli paylaşılmasına bağlıdır.</p>
            </div>
        </div>

        <!-- Soru 2 -->
        <div class="question">
            <h2>Soru 2: Bilgisayarda çalışan süreçlere ihtiyaç duymaları halinde, gerçekte var olan fiziksel bellek miktarından daha fazla bellek alanı nasıl tahsis edilir?</h2>
            <button class="toggle-btn" onclick="toggleAnswer('answer2')">Cevabı Göster/Gizle</button>
            <div class="answer" id="answer2">
                <h3>Cevap:</h3>
                <p>Fiziksel bellek (RAM) miktarından daha fazla bellek tahsisi, <strong>sanal bellek (virtual memory)</strong> mekanizmasıyla sağlanır. Sanal bellek, süreçlere fiziksel bellekten bağımsız, geniş bir adres alanı sunar ve sabit diskteki <strong>takas alanı (swap space)</strong> ile desteklenir. Aşağıda bu süreç detaylı bir şekilde açıklanmıştır:</p>

                <h3>1. Sanal Bellek Kavramı</h3>
                <p>Sanal bellek, her sürece kendi <strong>sanal adres alanını</strong> tahsis eder. Bu adres alanı, fiziksel belleğin boyutundan bağımsızdır ve süreçlerin büyük bellek taleplerini karşılar:</p>
                <ul>
                    <li><strong>Süreç İzolasyonu:</strong> Her süreç, diğer süreçlerin bellek alanına erişemez.</li>
                    <li><strong>Esneklik:</strong> Süreçler, fiziksel bellekten daha fazla bellek talep edebilir.</li>
                </ul>

                <h3>2. Sayfalama (Paging)</h3>
                <p>Sanal bellek, genellikle <strong>sayfalama</strong> ile uygulanır:</p>
                <ul>
                    <li>Bellek, sabit boyutlu sayfalara (örneğin, 4 KB) bölünür.</li>
                    <li><strong>Sayfa Tablosu:</strong> Sanal sayfa numaralarını fiziksel çerçeve numaralarına eşler.</li>
                    <li><strong>Adres Çevirisi:</strong> Bellek Yönetim Birimi (MMU), sanal adresleri fiziksel adreslere çevirir.</li>
                </ul>

                <h3>3. Talebe Bağlı Sayfalama (Demand Paging)</h3>
                <p>Fiziksel bellek yetersizse, yalnızca o an ihtiyaç duyulan sayfalar belleğe yüklenir:</p>
                <ul>
                    <li>Eğer bir sayfa fiziksel bellekte yoksa, bir <strong>sayfa hatası</strong> oluşur.</li>
                    <li>İşletim sistemi, sayfayı takas alanından veya dosya sisteminden yükler.</li>
                    <li>Fiziksel bellek doluysa, bir sayfa (örneğin, LRU algoritmasıyla) takas alanına yazılır.</li>
                </ul>

                <h3>4. Takas Alanı (Swap Space)</h3>
                <p>Takas alanı, sabit diskte ayrılmış bir bölümdür ve fiziksel belleğin uzantısı gibi çalışır. Kullanılmayan sayfalar buraya taşınır, böylece fiziksel bellekten daha fazla bellek sağlanır.</p>

                <h3>5. Bellek Aşırı Taahhüdü (Overcommitment)</h3>
                <p>İşletim sistemi, süreçlere ihtiyaç duydukları anda fiziksel bellek tahsis eder. Örneğin, bir süreç 1 GB talep etse bile, sadece bir kısmını kullanıyorsa, kalan alan fiziksel bellekte tutulmaz.</p>

                <h3>Örnek:</h3>
                <div class="example">
                    <p>4 GB RAM ve 8 GB takas alanı olan bir sistemde:</p>
                    <ul>
                        <li>P1: 3 GB, P2: 2 GB, P3: 4 GB talep ediyor (toplam 9 GB).</li>
                        <li>İşletim sistemi, her sürece sanal adres alanı tahsis eder.</li>
                        <li>Aktif sayfalar RAM’de (örneğin, 2 GB), geri kalan takas alanında tutulur.</li>
                        <li>Sayfa hatalarıyla gerekli sayfalar yüklenir.</li>
                    </ul>
                </div>

                <h3>Analitik Perspektif:</h3>
                <p>Sanal bellek, fiziksel bellek sınırlarını aşar, ancak sayfa hataları performansı etkileyebilir (disk erişimi yavaş). TLB ve etkili sayfa değiştirme algoritmaları, performansı optimize eder. Yoğun takas alanı kullanımı (thrashing), sistem yavaşlamasına neden olabilir.</p>
            </div>
        </div>

        <!-- Soru 3 -->
        <div class="question">
            <h2>Soru 3: Kilitlenme (deadlock) nedir? Bir sistemde kilitlenmenin oluşması için gerekli dört koşul nelerdir? Her koşulu, gerçek dünyadan bir örnekle (örneğin, bir trafik senaryosu) açıklayınız.</h2>
            <button class="toggle-btn" onclick="toggleAnswer('answer3')">Cevabı Göster/Gizle</button>
            <div class="answer" id="answer3">
                <h3>Cevap:</h3>
                <p><strong>Kilitlenme (deadlock)</strong>, birden fazla sürecin, birbirlerinin serbest bırakmasını beklediği kaynaklar nedeniyle süresiz olarak bekleme durumunda kalmasıdır. Hiçbir süreç ilerleyemez ve sistem tıkanır. Kilitlenme, paylaşılan kaynakların (örneğin, bellek, kilitler) kullanıldığı sistemlerde yaygındır.</p>

                <h3>Kilitlenmenin Dört Koşulu (Coffman Koşulları):</h3>
                <p>Kilitlenme, aşağıdaki dört koşulun aynı anda sağlanmasıyla oluşur:</p>
                <ol>
                    <li><strong>Karşılıklı Dışlama (Mutual Exclusion):</strong> En az bir kaynak, aynı anda yalnızca bir süreç tarafından kullanılabilir.</li>
                    <li><strong>Tut ve Bekle (Hold and Wait):</strong> Bir süreç, bir kaynağı tutarken başka bir kaynağı bekler.</li>
                    <li><strong>Önleme Yok (No Preemption):</strong> Kaynaklar, süreç gönüllü olarak bırakmadıkça zorla alınamaz.</li>
                    <li><strong>Dairesel Bekleme (Circular Wait):</strong> Süreçler, bir döngü oluşturacak şekilde birbirlerinin kaynaklarını bekler.</li>
                </ol>

                <h3>1. Karşılıklı Dışlama</h3>
                <p><strong>Tanım:</strong> Kaynak, yalnızca bir süreç tarafından kullanılabilir; diğer süreçler bekler.</p>
                <p><strong>Trafik Örneği:</strong> Bir dar köprü, aynı anda yalnızca bir yönden araç geçişine izin verir. Bir kamyon köprüyü kullanıyorsa, karşı yönden gelen araçlar bekler.</p>
                <p><strong>Açıklama:</strong> Köprü (kaynak), karşılıklı dışlama özelliğine sahiptir. Eğer kaynak paylaşılamazsa, kilitlenme riski artar, çünkü süreçler kaynak için sırayla bekler.</p>

                <h3>2. Tut ve Bekle</h3>
                <p><strong>Tanım:</strong> Bir süreç, bir kaynağı tutarken başka bir kaynağı talep eder.</p>
                <p><strong>Trafik Örneği:</strong> Bir kavşakta, araç A doğu-batı şeridini tutuyor ve kuzey-güney şeridini bekliyor. Araç B, kuzey-güney şeridini tutuyor ve doğu-batı şeridini bekliyor.</p>
                <p><strong>Açıklama:</strong> Her araç, bir şeridi tutarak diğerini beklerse, ilerleyemezler, bu da kilitlenmeye yol açar.</p>

                <h3>3. Önleme Yok</h3>
                <p><strong>Tanım:</strong> Kaynaklar, süreç tarafından gönüllü olarak bırakılmadıkça alınamaz.</p>
                <p><strong>Trafik Örneği:</strong> Bir kavşakta, bir otobüs dar bir yolu kapatarak ilerliyor ve taksinin geçmesini engelliyor. Trafik polisi, otobüsü zorla geri çekemez.</p>
                <p><strong>Açıklama:</strong> Otobüs yolu bırakmazsa, taksi bekler ve kilitlenme oluşabilir.</p>

                <h3>4. Dairesel Bekleme</h3>
                <p><strong>Tanım:</strong> Süreçler, dairesel bir zincir oluşturacak şekilde birbirlerinin kaynaklarını bekler.</p>
                <p><strong>Trafik Örneği:</strong> Dört yönlü bir kavşakta:</p>
                <ul>
                    <li>Araç A, batı şeridini tutuyor, kuzey-güney şeridini bekliyor.</li>
                    <li>Araç B, güney şeridini tutuyor, batı-doğu şeridini bekliyor.</li>
                    <li>Araç C, doğu şeridini tutuyor, güney-kuzey şeridini bekliyor.</li>
                    <li>Araç D, kuzey şeridini tutuyor, doğu-batı şeridini bekliyor.</li>
                </ul>
                <p><strong>Açıklama:</strong> Her araç, bir sonraki aracın şeridini bekler, bu da dairesel beklemeye ve kilitlenmeye neden olur.</p>

                <h3>Analitik Perspektif:</h3>
                <p>Dört koşulun tamamı sağlanmadıkça kilitlenme oluşmaz. İşletim sistemleri, bir koşulu ortadan kaldırarak kilitlenmeyi önler. Örneğin, dairesel beklemeyi önlemek için kaynak sıralaması kullanılabilir. Ancak, her strateji performans ve esneklik açısından trade-off’lar içerir.</p>
            </div>
        </div>

        <!-- Soru 4 -->
        <div class="question">
            <h2>Soru 4: Kilitlenme koşullarından her birini önlemek için uygulanabilecek bir strateji öneriniz.</h2>
            <button class="toggle-btn" onclick="toggleAnswer('answer4')">Cevabı Göster/Gizle</button>
            <div class="answer" id="answer4">
                <h3>Cevap:</h3>
                <p>Kilitlenmeyi önlemek için, dört koşuldan (karşılıklı dışlama, tut ve bekle, önleme yok, dairesel bekleme) herhangi birini ortadan kaldıran bir strateji uygulanabilir. Aşağıda her koşulu önlemek için bir strateji önerilmiştir:</p>

                <h3>1. Karşılıklı Dışlamayı Önleme: Kaynakları Paylaşımlı Yapma</h3>
                <p><strong>Strateji:</strong> Kaynakların eşzamanlı erişime izin verecek şekilde tasarlanması.</p>
                <p><strong>Açıklama:</strong> Kaynaklar, birden fazla sürecin aynı anda kullanabileceği şekilde yapılandırılır. Örneğin, bir yazıcı için bir spooler sistemi, yazdırma işlerini sıraya koyar ve doğrudan erişimi engeller.</p>
                <p><strong>Avantajlar:</strong> Bekleme süresi azalır, kilitlenme riski sıfıra iner.</p>
                <p><strong>Dezavantajlar:</strong> Tüm kaynaklar paylaşılamaz (örneğin, veritabanı yazma işlemleri). Veri tutarlılığı için senkronizasyon gerekir.</p>

                <h3>2. Tut ve Beklemeyi Önleme: Tüm Kaynakları Baştan Tahsis Etme</h3>
                <p><strong>Strateji:</strong> Süreçlerin tüm kaynakları yürütme öncesi alması zorunlu kılınır.</p>
                <p><strong>Açıklama:</strong> Bir süreç, ihtiyaç duyacağı tüm kaynakları baştan talep eder. Eğer kaynaklar mevcut değilse, süreç hiç başlatılmaz.</p>
                <p><strong>Avantajlar:</strong> Tut ve bekle durumu ortadan kalkar.</p>
                <p><strong>Dezavantajlar:</strong> Kaynak israfı, süreçlerin kaynak ihtiyaçlarını önceden bilme zorunluluğu, uzun bekleme süreleri.</p>

                <h3>3. Önleme Yok Koşulunu Önleme: Kaynakları Zorla Geri Alma</h3>
                <p><strong>Strateji:</strong> Kaynakların işletim sistemi tarafından zorla alınması (preemption).</p>
                <p><strong>Açıklama:</strong> Bir süreç, ihtiyaç duyduğu kaynağı alamıyorsa, tuttuğu kaynaklar geri alınır ve başka süreçlere tahsis edilir.</p>
                <p><strong>Avantajlar:</strong> Süreçlerin kaynakları süresiz tutması engellenir.</p>
                <p><strong>Dezavantajlar:</strong> Süreç durumu bozulabilir, fiziksel cihazlar için zor uygulanır, ek hesaplama yükü.</p>

                <h3>4. Dairesel Beklemeyi Önleme: Sıralı Kaynak Erişimi</h3>
                <p><strong>Strateji:</strong> Kaynaklara bir sıralama atanır ve süreçler kaynakları bu sırayla talep eder.</p>
                <p><strong>Açıklama:</strong> Örneğin, yazıcı (R1), disk (R2), tarayıcı (R3) sıralanır. Süreçler, yalnızca bu sırayla talep edebilir.</p>
                <p><strong>Avantajlar:</strong> Dairesel bekleme imkansız hale gelir, uygulama basit.</p>
                <p><strong>Dezavantajlar:</strong> Süreçlerin doğal akışını kısıtlar, ek bekleme süreleri yaratabilir.</p>

                <h3>Analitik Perspektif:</h3>
                <p>Dairesel beklemeyi önleme, en yaygın ve pratik stratejidir. Karşılıklı dışlama, kaynak doğası gereği genellikle kaldırılamaz. Tut ve bekle, kaynak israfına yol açar; önleme, fiziksel cihazlar için zordur. Sistem tasarımında, performans ve esneklik arasındaki denge dikkate alınmalıdır.</p>
            </div>
        </div>

        <!-- Soru 5 -->
        <div class="question">
            <h2>Soru 5: İşletim sisteminde bellek yönetimi (memory management) bileşenine neden ihtiyaç duyulur?</h2>
            <button class="toggle-btn" onclick="toggleAnswer('answer5')">Cevabı Göster/Gizle</button>
            <div class="answer" id="answer5">
                <h3>Cevap:</h3>
                <p>Bellek yönetimi, işletim sisteminin fiziksel ve sanal belleği süreçler arasında verimli, güvenli ve etkili bir şekilde tahsis eden bileşenidir. Çoklu süreç sistemlerinde, sınırlı bellek kaynaklarının paylaşılması gerektiğinden, bellek yönetimi vazgeçilmezdir. Aşağıda ihtiyaç nedenleri detaylı bir şekilde açıklanmıştır:</p>

                <h3>1. Bellek Tahsisini Yönetme</h3>
                <p>Süreçler, kod, veri ve yığın için bellek gerektirir. Bellek yönetimi, fiziksel belleği süreçlere adil bir şekilde tahsis eder.</p>
                <p><strong>Örnek:</strong> 8 GB RAM’de üç süreç (tarayıcı, editör, oyun) 10 GB talep ederse, bellek yönetimi sanal bellekle bu talebi karşılar.</p>

                <h3>2. Süreç İzolasyonu ve Güvenlik</h3>
                <p>Her süreç, kendi bellek alanında çalışmalı ve diğer süreçlerin verilerine erişmemelidir. Bellek yönetimi, sanal adres alanları ve sayfa tablolarıyla izolasyon sağlar.</p>
                <p><strong>Örnek:</strong> Bir tarayıcı, bankacılık uygulamasının verilerine erişemez.</p>

                <h3>3. Bellek Parçalanmasını Azaltma</h3>
                <p>Dahili (tahsis edilen bloğun kullanılmayan kısmı) ve harici (dağınık boş alanlar) parçalanma, belleğin verimsiz kullanılmasına yol açar. Bellek yönetimi, sayfalama veya birleştirme ile bu sorunları azaltır.</p>

                <h3>4. Sanal Bellek Desteği</h3>
                <p>Fiziksel bellek yetersizse, sanal bellek, takas alanıyla süreçlere daha büyük adres alanları sunar.</p>
                <p><strong>Örnek:</strong> 4 GB RAM’de 8 GB talep eden bir süreç, takas alanıyla çalışabilir.</p>

                <h3>5. Bellek Paylaşımı ve Verimlilik</h3>
                <p>Süreçler, ortak verilere (örneğin, kütüphaneler) erişebilir. Bellek yönetimi, kopya üzerine yazma (copy-on-write) ile paylaşımı optimize eder.</p>

                <h3>6. Performans Optimizasyonu</h3>
                <p>TLB, önbellekleme ve etkili tahsis algoritmaları (örneğin, best-fit), bellek erişimini hızlandırır.</p>

                <h3>7. Hata Yönetimi</h3>
                <p>Geçersiz bellek erişimleri (örneğin, segmentasyon hatası), bellek yönetimi tarafından tespit edilir ve sistem çökmesi önlenir.</p>

                <h3>Analitik Perspektif:</h3>
                <p>Bellek yönetimi, performans, güvenlik ve kaynak verimliliği arasında denge kurar. Sayfalama ve sanal bellek, modern sistemlerde temel araçlardır. Yetersiz bellek yönetimi, sistem kaosuna, güvenlik açıklarına ve düşük performansa yol açar.</p>
            </div>
        </div>

        <!-- Soru 6 -->
        <div class="question">
            <h2>Soru 6: Bellek yönetiminde mantıksal adres ve fiziksel adres kavramlarını açıklayınız.</h2>
            <button class="toggle-btn" onclick="toggleAnswer('answer6')">Cevabı Göster/Gizle</button>
            <div class="answer" id="answer6">
                <h3>Cevap:</h3>
                <p>Bellek yönetiminde <strong>mantıksal adres (logical address)</strong> ve <strong>fiziksel adres (physical address)</strong>, sanal bellek sisteminin temel kavramlarıdır. Süreçlerin bellekle etkileşimini sağlarlar.</p>

                <h3>1. Mantıksal Adres</h3>
                <p><strong>Tanım:</strong> Sürecin kendi sanal adres alanında kullandığı adrestir. Süreç, fiziksel belleğin detaylarını bilmez; yalnızca mantıksal adreslerle çalışır.</p>
                <ul>
                    <li><strong>Özellikler:</strong>
                        <ul>
                            <li>Sürece özgüdür; her süreç kendi bağımsız adres alanına sahiptir.</li>
                            <li>Sanal bellekle ilişkilidir, fiziksel bellek boyutundan bağımsızdır.</li>
                            <li>Örneğin, 0x1000 adresi, farklı süreçlerde farklı fiziksel konumlara işaret edebilir.</li>
                        </ul>
                    </li>
                    <li><strong>Örnek:</strong> Bir C programında `&variable`, mantıksal bir adrestir.</li>
                </ul>

                <h3>2. Fiziksel Adres</h3>
                <p><strong>Tanım:</strong> Belleğin (RAM) gerçek, donanımsal konumunu temsil eden adrestir.</p>
                <ul>
                    <li><strong>Özellikler:</strong>
                        <ul>
                            <li>Sistem genelinde benzersizdir; doğrudan RAM’e işaret eder.</li>
                            <li>Fiziksel bellek boyutuyla sınırlıdır (örneğin, 8 GB RAM).</li>
                            <li>CPU ve MMU tarafından kullanılır.</li>
                        </ul>
                    </li>
                    <li><strong>Örnek:</strong> Fiziksel adres 0xA000, RAM’deki bir bayta işaret eder.</li>
                </ul>

                <h3>Adres Çevirisi:</h3>
                <p>İşletim sistemi, mantıksal adresleri fiziksel adreslere çevirir:</p>
                <ul>
                    <li><strong>Sayfalama:</strong> Mantıksal adres, sayfa numarası ve ofset olarak bölünür. Sayfa tablosu, sayfa numarasını fiziksel çerçeveye eşler.</li>
                    <li><strong>MMU:</strong> Çeviriyi gerçekleştirir, TLB ile hızlandırılır.</li>
                    <li><strong>Sayfa Hatası:</strong> Eğer sayfa fiziksel bellekte yoksa, takas alanından yüklenir.</li>
                </ul>

                <h3>Örnek:</h3>
                <div class="example">
                    <p>İki süreç (P1, P2) ve 8 GB RAM:</p>
                    <ul>
                        <li>P1, mantıksal adres 0x1000’e erişir → Fiziksel adres 0xA000.</li>
                        <li>P2, mantıksal adres 0x1000’e erişir → Fiziksel adres 0xB000.</li>
                    </ul>
                    <p>Sayfa tablosu, her sürecin adresini farklı fiziksel konumlara eşler.</p>
                </div>

                <h3>Analitik Perspektif:</h3>
                <p>Mantıksal adresler, süreç izolasyonu ve esneklik sağlar. Fiziksel adresler, donanımla doğrudan iletişim kurar. Adres çevirisi, sayfa hataları ve TLB isabet oranı, sistem performansını etkiler.</p>
            </div>
        </div>

        <!-- Soru 7 -->
        <div class="question">
            <h2>Soru 7: Bellekte boş alanlar hangi veri yapıları ile tutulabilir? Açıklayınız.</h2>
            <button class="toggle-btn" onclick="toggleAnswer('answer7')">Cevabı Göster/Gizle</button>
            <div class="answer" id="answer7">
                <h3>Cevap:</h3>
                <p>Bellekte boş alanların izlenmesi için kullanılan veri yapıları, belleğin verimli tahsisini sağlar. Başlıca veri yapıları şunlardır:</p>

                <h3>1. Bağlı Liste (Linked List)</h3>
                <p><strong>Açıklama:</strong> Boş bellek blokları, bağlı listede düğümler olarak tutulur. Her düğüm, başlangıç adresini, boyutunu ve bir sonraki bloğa işaretçiyi içerir.</p>
                <ul>
                    <li><strong>Nasıl Çalışır:</strong> Liste taranır, uygun blok tahsis edilir, blok bölünebilir veya birleştirilir.</li>
                    <li><strong>Örnek:</strong> Boş bloklar: [0x1000, 200 KB], [0x3000, 100 KB]. 150 KB talep edilirse, 0x1000 bloğu bölünür (150 KB tahsis, 50 KB boş).</li>
                    <li><strong>Avantajlar:</strong> Basit, esnek, birleştirme kolay.</li>
                    <li><strong>Dezavantajlar:</strong> Yavaş tarama (O(n)), harici parçalanma, ek bellek ihtiyacı.</li>
                    <li><strong>Kullanım:</strong> Heap yönetimi (malloc).</li>
                </ul>

                <h3>2. Bit Haritası (Bitmap)</h3>
                <p><strong>Açıklama:</strong> Bellek, sabit boyutlu birimlere bölünür; her birim bir bit ile temsil edilir (`0`: boş, `1`: tahsisli).</p>
                <ul>
                    <li><strong>Nasıl Çalışır:</strong> Ardışık boş bitler aranır, tahsis edilir, bitler güncellenir.</li>
                    <li><strong>Örnek:</strong> 8 birim, bit haritası `00110100`. 2 birim talep edilirse, `11110100` olur.</li>
                    <li><strong>Avantajlar:</strong> Kompakt, hızlı bit işlemleri, harici parçalanma tespiti kolay.</li>
                    <li><strong>Dezavantajlar:</strong> Ardışık blok bulma zor, sabit boyutlu birimlere uygun.</li>
                    <li><strong>Kullanım:</strong> Sayfalama, fiziksel sayfa yönetimi.</li>
                </ul>

                <h3>3. Ağaç Yapıları (Tree Structures)</h3>
                <p><strong>Açıklama:</strong> Boş bloklar, ikili ağaç veya kırmızı-siyah ağaç gibi hiyerarşik yapılarla tutulur.</p>
                <ul>
                    <li><strong>Nasıl Çalışır:</strong> Uygun blok aranır, tahsis edilir, ağaç güncellenir.</li>
                    <li><strong>Örnek:</strong> [0x1000, 200 KB] bloğu, 150 KB tahsis için bölünür, kalan 50 KB ağaca eklenir.</li>
                    <li><strong>Avantajlar:</strong> Hızlı arama (O(log n)), esnek.</li>
                    <li><strong>Dezavantajlar:</strong> Karmaşık yönetim, ek bellek ihtiyacı.</li>
                    <li><strong>Kullanım:</strong> Sanal bellek yönetimi (Linux VMA).</li>
                </ul>

                <h3>4. Kumpas Sistemi (Buddy System)</h3>
                <p><strong>Açıklama:</strong> Bellek, ikinin katları boyutunda bloklara bölünür; her boyut için bir liste tutulur.</p>
                <ul>
                    <li><strong>Nasıl Çalışır:</strong> Uygun blok tahsis edilir, yoksa büyük blok bölünür. Serbest bırakıldığında kumpasla birleştirilir.</li>
                    <li><strong>Örnek:</strong> 100 KB talep için 128 KB tahsis edilir, 256 KB blok bölünür.</li>
                    <li><strong>Avantajlar:</strong> Hızlı birleştirme, düzenli bloklar.</li>
                    <li><strong>Dezavantajlar:</strong> Dahili parçalanma, sınırlı esneklik.</li>
                    <li><strong>Kullanım:</strong> Linux fiziksel sayfa tahsisi.</li>
                </ul>

                <h3>Analitik Perspektif:</h3>
                <p>Bağlı liste esnek, ancak yavaştır. Bit haritası kompakt, ancak sabit boyutlara uygundur. Ağaçlar hızlı ve esnek, kumpas sistemi düzenli ancak dahili parçalanma yaratır. Modern sistemler, bu yapıların kombinasyonunu kullanır.</p>
            </div>
        </div>

        <!-- Soru 8 -->
        <div class="question">
            <h2>Soru 8: Bellek yönetiminde dahili ve harici parçalanma arasındaki farkı açıklayınız.</h2>
            <button class="toggle-btn" onclick="toggleAnswer('answer8')">Cevabı Göster/Gizle</button>
            <div class="answer" id="answer8">
                <h3>Cevap:</h3>
                <p><strong>Dahili parçalanma (internal fragmentation)</strong> ve <strong>harici parçalanma (external fragmentation)</strong>, bellek tahsisinde ortaya çıkan ve belleğin verimsiz kullanılmasına yol açan sorunlardır. Aşağıda farkları açıklanmıştır:</p>

                <h3>1. Dahili Parçalanma</h3>
                <p><strong>Tanım:</strong> Bir sürece tahsis edilen bellek bloğunun, ihtiyaç duyulandan büyük olması ve kullanılmayan kısmın boşa gitmesidir.</p>
                <ul>
                    <li><strong>Nasıl Oluşur:</strong> Sabit boyutlu tahsis (örneğin, sayfalama) sırasında, süreç bloğun tamamını kullanamaz.</li>
                    <li><strong>Örnek:</strong> 4 KB’lik bir sayfaya 3 KB’lik bir süreç tahsis edilirse, 1 KB boşa gider.</li>
                    <li><strong>Etkiler:</strong> Bellek israfı, kullanılabilir alanı azaltır.</li>
                    <li><strong>Çözüm:</strong> Küçük sayfa boyutları, dinamik tahsis.</li>
                    <li><strong>Görüldüğü Yer:</strong> Sayfalama, sabit bölmeli tahsis.</li>
                </ul>

                <h3>2. Harici Parçalanma</h3>
                <p><strong>Tanım:</strong> Toplamda yeterli boş bellek olmasına rağmen, bu alanların dağınık ve ardışık olmaması nedeniyle tahsis edilememesidir.</p>
                <ul>
                    <li><strong>Nasıl Oluşur:</strong> Değişken boyutlu tahsislerde, süreçlerin tahsis ve serbest bırakılması boş alanları parçalar.</li>
                    <li><strong>Örnek:</strong> 900 KB boş bellek (200 KB, 300 KB, 400 KB), ancak 600 KB’lik ardışık blok yok.</li>
                    <li><strong>Etkiler:</strong> Süreç tahsisini engeller, performansı düşürür.</li>
                    <li><strong>Çözüm:</strong> Birleştirme, sayfalama, kumpas sistemi.</li>
                    <li><strong>Görüldüğü Yer:</strong> Değişken bölmeli tahsis, heap yönetimi.</li>
                </ul>

                <h3>Farklar:</h3>
                <table style="width: 100%; border-collapse: collapse; margin: 10px 0;">
                    <tr style="background: #e9ecef;">
                        <th>Özellik</th>
                        <th>Dahili Parçalanma</th>
                        <th>Harici Parçalanma</th>
                    </tr>
                    <tr>
                        <td>Yer</td>
                        <td>Tahsis edilmiş blok içinde</td>
                        <td>Boş bloklar arasında</td>
                    </tr>
                    <tr>
                        <td>Etkiler</td>
                        <td>Bellek israfı</td>
                        <td>Tahsis engeli</td>
                    </tr>
                    <tr>
                        <td>Çözüm</td>
                        <td>Küçük sayfalar, dinamik tahsis</td>
                        <td>Birleştirme, sayfalama</td>
                    </tr>
                </table>

                <h3>Analitik Perspektif:</h3>
                <p>Sayfalama, harici parçalanmayı çözer, ancak dahili parçalanma yaratır. Değişken tahsis, dahili parçalanmayı önler, ancak harici parçalanmaya yol açar. Modern sistemler, sayfalama ve kumpas sistemiyle bu sorunları dengeler.</p>
            </div>
        </div>

        <!-- Soru 9 -->
        <div class="question">
            <h2>Soru 9: Fiziksel bellekte olmayan bir sayfaya erişilmeye çalışıldığında neler olur? Adım adım açıklayınız.</h2>
            <button class="toggle-btn" onclick="toggleAnswer('answer9')">Cevabı Göster/Gizle</button>
            <div class="answer" id="answer9">
                <h3>Cevap:</h3>
                <p>Fiziksel bellekte olmayan bir sayfaya erişildiğinde, bir <strong>sayfa hatası (page fault)</strong> oluşur ve işletim sistemi, <strong>talebe bağlı sayfalama</strong> ile sayfayı yükler. Süreç adım adım şöyledir:</p>

                <h3>1. Mantıksal Adrese Erişim</h3>
                <p>Süreç, bir mantıksal adrese (örneğin, 0x1234) erişmeye çalışır. Bu adres, sanal adres alanındaki bir sayfa numarası ve ofset içerir.</p>

                <h3>2. MMU Adres Çevirisi</h3>
                <p>Bellek Yönetim Birimi (MMU), sayfa tablosuna bakar. Eğer sayfanın varlık biti `0` ise, sayfa fiziksel bellekte değildir.</p>

                <h3>3. Sayfa Hatası Kesmesi</h3>
                <p>MMU, bir sayfa hatası kesmesi üretir. CPU, mevcut talimatı durdurur ve kontrol işletim sistemine geçer.</p>

                <h3>4. Hata İşleme</h3>
                <p>İşletim sistemi, hatanın türünü analiz eder:</p>
                <ul>
                    <li><strong>Geçerli Hata:</strong> Sayfa, takas alanında veya dosyada varsa yüklenir.</li>
                    <li><strong>Geçersiz Hata:</strong> Adres geçersizse (örneğin, null işaretçi), segmentasyon hatası üretilir.</li>
                </ul>

                <h3>5. Yer Açma</h3>
                <p>Fiziksel bellek doluysa, bir sayfa (örneğin, LRU ile) çıkarılır:</p>
                <ul>
                    <li>Değiştirilmişse, takas alanına yazılır.</li>
                    <li>Değiştirilmemişse, atılır.</li>
                </ul>

                <h3>6. Sayfanın Yüklenmesi</h3>
                <p>Sayfa, diskten (takas alanı veya dosya) fiziksel belleğe yüklenir. Sayfa tablosu güncellenir (varlık biti `1`).</p>

                <h3>7. Sürecin Yeniden Başlatılması</h3>
                <p>Süreç durumu geri yüklenir, talimat tekrar yürütülür ve erişim tamamlanır.</p>

                <h3>Örnek:</h3>
                <div class="example">
                    <p>Süreç, 0x1234’e (sayfa 1, ofset 0x234) erişir:</p>
                    <ol>
                        <li>Sayfa 1 fiziksel bellekte değil, sayfa hatası oluşur.</li>
                        <li>Sayfa, takas alanında bulunur.</li>
                        <li>LRU ile bir sayfa çıkarılır, çerçeve 5 boşalır.</li>
                        <li>Sayfa 1, çerçeve 5’e yüklenir, sayfa tablosu güncellenir.</li>
                        <li>Süreç devam eder, 0x1234 erişimi tamamlanır.</li>
                    </ol>
                </div>

                <h3>Analitik Perspektif:</h3>
                <p>Sayfa hataları, disk I/O nedeniyle yavaştır (ms vs. ns). Düşük sayfa hatası oranı, TLB ve etkili algoritmalar performans için kritik. Yoğun sayfa değiştirme (thrashing), sistemi yavaşlatır.</p>
            </div>
        </div>

        <!-- Soru 10 -->
        <div class="question">
            <h2>Soru 10: Sayfa yer değiştirme (page replacement) algoritmalarından 3 tanesini açıklayınız.</h2>
            <button class="toggle-btn" onclick="toggleAnswer('answer10')">Cevabı Göster/Gizle</button>
            <div class="answer" id="answer10">
                <h3>Cevap:</h3>
                <p>Sayfa yer değiştirme algoritmaları, fiziksel bellek dolu olduğunda hangi sayfanın çıkarılacağını belirler. Üç yaygın algoritma şunlardır:</p>

                <h3>1. İlk Giren İlk Çıkar (FIFO)</h3>
                <p><strong>Açıklama:</strong> En uzun süredir bellekte olan sayfa çıkarılır. Bellek, bir kuyruk gibi yönetilir.</p>
                <ul>
                    <li><strong>Nasıl Çalışır:</strong> Yeni sayfa kuyruğun sonuna eklenir, yer açmak için kuyruğun başındaki sayfa çıkarılır.</li>
                    <li><strong>Örnek:</strong> 3 çerçeve, referans dizisi `1, 2, 3, 4, 1, 2` → 6 sayfa hatası.</li>
                    <li><strong>Avantajlar:</strong> Basit, düşük maliyet (O(1)).</li>
                    <li><strong>Dezavantajlar:</strong> Düşük performans, Belady anormalliği.</li>
                    <li><strong>Kullanım:</strong> Basit sistemler.</li>
                </ul>

                <h3>2. En Az Kullanılan (LRU)</h3>
                <p><strong>Açıklama:</strong> En uzun süredir kullanılmayan sayfa çıkarılır. Lokalite ilkesine dayanır.</p>
                <ul>
                    <li><strong>Nasıl Çalışır:</strong> Sayfaların son kullanım zamanı takip edilir, en eski sayfa çıkarılır.</li>
                    <li><strong>Örnek:</strong> 3 çerçeve, referans dizisi `1, 2, 3, 4, 1, 2` → 5 sayfa hatası.</li>
                    <li><strong>Avantajlar:</strong> Yüksek performans, lokaliteye uygun.</li>
                    <li><strong>Dezavantajlar:</strong> Karmaşık, zaman damgası takibi gerekir.</li>
                    <li><strong>Kullanım:</strong> Modern sistemler, önbellek yönetimi.</li>
                </ul>

                <h3>3. Saat Algoritması (Clock Algorithm)</h3>
                <p><strong>Açıklama:</strong> LRU’nun basit bir yaklaşık versiyonudur. Sayfalar dairesel bir listede tutulur, referans biti kullanılır.</p>
                <ul>
                    <li><strong>Nasıl Çalışır:</strong> Referans biti `1` olan sayfalara ikinci şans verilir, `0` olanlar çıkarılır.</li>
                    <li><strong>Örnek:</strong> 3 çerçeve, referans dizisi `1, 2, 3, 4, 1, 2` → ~5 sayfa hatası.</li>
                    <li><strong>Avantajlar:</strong> Basit, LRU’ya yakın performans, donanım desteğiyle uygulanabilir.</li>
                    <li><strong>Dezavantajlar:</strong> LRU kadar hassas değil.</li>
                    <li><strong>Kullanım:</strong> Linux, Windows.</li>
                </ul>

                <h3>Analitik Perspektif:</h3>
                <p>LRU ve saat algoritması, lokaliteye uygunluklarıyla yüksek performans sunar. FIFO basit, ancak etkisizdir. Algoritma seçimi, sistem ihtiyaçlarına ve donanım desteğine bağlıdır. Sayfa hatası oranı, performansı belirler.</p>
            </div>
        </div>
    </div>

    <script>
        function toggleAnswer(answerId) {
            const answer = document.getElementById(answerId);
            answer.classList.toggle('hidden');
        }
    </script>
</body>
</html>