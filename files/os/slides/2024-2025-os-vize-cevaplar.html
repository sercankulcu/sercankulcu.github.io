<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>İşletim Sistemleri Soru ve Cevapları</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f4f4f4;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }

        h1 {
            text-align: center;
            color: #333;
        }

        .question {
            margin: 20px 0;
            border-left: 4px solid #007BFF;
            padding-left: 15px;
        }

        .question h2 {
            color: #007BFF;
            margin-bottom: 10px;
        }

        .answer {
            margin-bottom: 20px;
            display: none;
        }

        .answer h3 {
            color: #444;
            margin-top: 15px;
        }

        .answer p,
        .answer ul,
        .answer ol {
            margin: 10px 0;
            color: #333;
        }

        .answer ul,
        .answer ol {
            padding-left: 20px;
        }

        .answer ul li,
        .answer ol li {
            margin-bottom: 8px;
        }

        .example {
            background: #e9ecef;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }

        .toggle-btn {
            background: #007BFF;
            color: #fff;
            border: none;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            margin-bottom: 10px;
            display: inline-block;
        }

        .toggle-btn:hover {
            background: #0056b3;
        }

        .answer.hidden {
            display: block;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>İşletim Sistemleri Soru ve Cevapları</h1>
        <p style="text-align: center; color: #555;">2023-2024 Vize Sınavı</p>

        <div class="question">
            <h2>Soru 1: İşletim sisteminin temel fonksiyonlarını birer cümle ile listeleyiniz.</h2>
            <div class="toggle-btn" onclick="toggleAnswer('answer1')">Cevabı Göster/Gizle</div>
            <div id="answer1" class="answer">
                <p><strong>Cevap:</strong></p>
                <p>İşletim sisteminin temel fonksiyonları, sistem kaynaklarını yönetmek, kullanıcı ile donanım arasında arayüz sağlamak ve uygulama yazılımlarının çalışmasını desteklemektir. Aşağıda temel fonksiyonlar detaylı bir şekilde birer cümle ile listelenmiştir:</p>
                <ul>
                    <li><strong>Süreç Yönetimi:</strong> İşletim sistemi, süreçlerin oluşturulmasını, yürütülmesini, çizelgelenmesini ve sonlandırılmasını koordine ederek CPU’nun verimli kullanımını sağlar.</li>
                    <li><strong>Bellek Yönetimi:</strong> Fiziksel ve sanal belleği süreçler arasında güvenli, adil ve verimli bir şekilde tahsis ederek bellek kaynaklarının optimal kullanımını garantiler.</li>
                    <li><strong>Dosya Sistemi Yönetimi:</strong> Verilerin saklanması, düzenlenmesi ve erişimi için dosya sistemlerini organize eder, diskteki verilere kolay erişim sağlar.</li>
                    <li><strong>Giriş/Çıkış Yönetimi:</strong> Klavye, fare, disk gibi donanım cihazlarıyla iletişim kurarak giriş/çıkış işlemlerini koordine eder ve cihazlar arası veri akışını yönetir.</li>
                    <li><strong>Güvenlik ve Erişim Kontrolü:</strong> Sistem kaynaklarına yalnızca yetkili kullanıcıların ve süreçlerin erişmesini sağlayarak veri güvenliğini ve sistem bütünlüğünü korur.</li>
                    <li><strong>Kullanıcı Arayüzü:</strong> Komut satırı veya grafik arayüz aracılığıyla kullanıcıların sistemle kolayca etkileşim kurmasını sağlar, böylece donanım karmaşıklığını soyutlar.</li>
                </ul>
                <div class="example">
                    <p><strong>Örnek:</strong> Bir işletim sistemi, bir metin editörünün (süreç) çalışmasını başlatır, belleği tahsis eder, kullanıcının yazdığı verileri diske kaydeder ve yalnızca yetkili kullanıcıların bu dosyaya erişmesine izin verir.</p>
                </div>
                <p><strong>Analitik Perspektif:</strong> İşletim sistemi, donanım ve yazılım arasında bir köprü görevi görerek kaynak kullanımını optimize eder, sistem performansını artırır ve kullanıcı deneyimini basitleştirir; ancak her fonksiyonun etkinliği, sistem tasarımı ve donanım kapasitesine bağlıdır.</p>
            </div>
        </div>

        <div class="question">
            <h2>Soru 2: İşlemci ile ana bellek arasında veri erişimini hızlandırmak için neler yapılabilir?</h2>
            <div class="toggle-btn" onclick="toggleAnswer('answer2')">Cevabı Göster/Gizle</div>
            <div id="answer2" class="answer">
                <p><strong>Cevap:</strong></p>
                <p>İşlemci ile ana bellek arasındaki veri erişimini hızlandırmak için çeşitli teknikler kullanılır; bu teknikler, bellek erişim süresini azaltarak sistem performansını artırır ve CPU’nun verimli çalışmasını sağlar:</p>
                <ol>
                    <li><strong>Önbellek (Cache) Kullanımı:</strong>
                        <ul>
                            <li>Hızlı SRAM tabanlı önbellek, sık kullanılan verileri ve talimatları CPU’ya yakın bir yerde depolar, böylece ana belleğe (RAM) erişim ihtiyacını azaltır.</li>
                            <li>Önbellek hiyerarşisi (L1, L2, L3), erişim sürelerini 2-10 ns’ye düşürürken, RAM erişimi 50-100 ns sürebilir.</li>
                            <li><strong>Detay:</strong> Önbellek, temporal (aynı veriye tekrar erişim) ve spatial (yakın verilere erişim) lokalite ilkelerine dayanır.</li>
                            <li><strong>Örnek:</strong> Bir programın döngü değişkenleri L1 önbelleğinde saklanır, böylece CPU tekrar tekrar RAM’e erişmez.</li>
                        </ul>
                    </li>
                    <li><strong>Çeviri Önbelleği (TLB):</strong>
                        <ul>
                            <li>Translation Lookaside Buffer (TLB), sanal adresleri fiziksel adreslere çevirmek için sayfa tablosu girişlerini önbelleğe alır, böylece adres çevirisi süresini azaltır.</li>
                            <li>TLB isabeti, adres çevirisini nanosaniyeler içinde tamamlar; isabetsizlik durumunda sayfa tablosuna erişim gerekir.</li>
                            <li><strong>Örnek:</strong> Bir süreç, sanal adres 0x1000’e eriştiğinde, TLB bu adresi fiziksel adrese hızlıca çevirir.</li>
                        </ul>
                    </li>
                    <li><strong>Bellek Hiyerarşisi:</strong>
                        <ul>
                            <li>CPU yazmaçları (en hızlı, ~1 ns), önbellek, RAM ve disk arasında hiyerarşik bir yapı, veri erişim hızını optimize eder.</li>
                            <li>Hiyerarşi, sık kullanılan verilerin CPU’ya yakın tutulmasını sağlar.</li>
                            <li><strong>Örnek:</strong> Bir veritabanı sorgusu önce önbellekte aranır, bulunamazsa RAM’den, en kötü ihtimalle diskten alınır.</li>
                        </ul>
                    </li>
                    <li><strong>Önceden Getirme (Prefetching):</strong>
                        <ul>
                            <li>CPU’nun gelecekte ihtiyaç duyacağı veriler, tahmine dayalı olarak önbelleğe önceden yüklenir.</li>
                            <li>Modern CPU’lar, döngü veya veri erişim modellerini analiz ederek prefetching yapar.</li>
                            <li><strong>Örnek:</strong> Bir döngüde dizinin ardışık elemanları önbelleğe önceden getirilir, erişim süresi azalır.</li>
                        </ul>
                    </li>
                    <li><strong>Paralel Bellek Erişimi:</strong>
                        <ul>
                            <li>Çoklu bellek bankaları veya interleaved bellek, aynı anda birden fazla veri erişimine izin vererek bant genişliğini artırır.</li>
                            <li><strong>Örnek:</strong> Çift kanallı RAM, aynı anda iki veri bloğuna erişim sağlar, bant genişliğini iki katına çıkarır.</li>
                        </ul>
                    </li>
                </ol>
                <div class="example">
                    <p><strong>Örnek:</strong> Bir oyun, grafik verilerini L1 önbelleğinde tutar, TLB sanal adresleri çevirir ve önceden getirme, sonraki kareleri önbelleğe yükler, böylece oyun akıcı çalışır.</p>
                </div>
                <p><strong>Analitik Perspektif:</strong> Önbellek ve TLB, lokalite ilkelerine dayanarak erişim hızını artırır; ancak önbellek isabetsizliği, yanlış önceden getirme veya sınırlı bant genişliği performansı düşürebilir. Modern sistemler, bu teknikleri birleştirerek en iyi performansı hedefler.</p>
            </div>
        </div>

        <div class="question">
            <h2>Soru 3: Kabuğun (shell) temel işlevi nedir?</h2>
            <div class="toggle-btn" onclick="toggleAnswer('answer3')">Cevabı Göster/Gizle</div>
            <div id="answer3" class="answer">
                <p><strong>Cevap:</strong></p>
                <p>Kabuk (shell), kullanıcı ile işletim sistemi arasında bir arayüz sağlayarak komutların girilmesini, yorumlanmasını ve yürütülmesini sağlar, böylece kullanıcıların sistemle etkileşimini kolaylaştırır.</p>
                <ul>
                    <li><strong>Komut Yorumlama:</strong> Kullanıcının girdiği komutları (örneğin, <code>ls</code>, <code>cd</code>) algılar, işletim sistemine uygun sistem çağrılarına çevirir ve yürütür.</li>
                    <li><strong>Betik Desteği:</strong> Komut dosyaları (shell script) aracılığıyla tekrarlayan veya karmaşık görevleri otomatikleştirir, örneğin, dosya işleme veya sistem bakımı.</li>
                    <li><strong>Kullanıcı Arayüzü:</strong> Komut satırı (CLI) veya grafik arayüz (GUI) ile kullanıcıların sistem kaynaklarına erişmesini sağlar, donanım karmaşıklığını soyutlar.</li>
                    <li><strong>Özellikler:</strong>
                        <ul>
                            <li><strong>Boru (Pipe):</strong> Bir komutun çıktısını başka bir komuta giriş olarak yönlendirir (örneğin, <code>ls | grep txt</code>).</li>
                            <li><strong>Arka Plan Yürütme:</strong> Komutların arka planda çalışmasını sağlar (örneğin, <code>command &</code>).</li>
                            <li><strong>Ortam Değişkenleri:</strong> Sistem ayarlarını yönetir (örneğin, <code>PATH</code>).</li>
                        </ul>
                    </li>
                    <li><strong>Örnek:</strong> Linux’ta <code>bash</code> kabuğu, <code>grep "error" log.txt</code> komutuyla log dosyalarında hata arar veya bir betikle sistem güncellemelerini otomatikleştirir.</li>
                </ul>
                <div class="example">
                    <p><strong>Örnek:</strong> Kullanıcı, <code>bash</code> kabuğunda <code>find / -name "*.txt" | xargs rm</code> komutunu çalıştırarak tüm metin dosyalarını siler; kabuk, komutları sırayla işler ve yönlendirme yapar.</p>
                </div>
                <p><strong>Analitik Perspektif:</strong> Kabuk, kullanıcı dostu bir arayüz sunarak sistemin karmaşıklığını soyutlar ve otomasyonu kolaylaştırır; ancak yanlış veya kötü niyetli komutlar sistem hatalarına veya güvenlik açıklarına yol açabilir.</p>
            </div>
        </div>

        <div class="question">
            <h2>Soru 4: Sistem çağrısının (system call) temel amacı nedir?</h2>
            <div class="toggle-btn" onclick="toggleAnswer('answer4')">Cevabı Göster/Gizle</div>
            <div id="answer4" class="answer">
                <p><strong>Cevap:</strong></p>
                <p>Sistem çağrısı, kullanıcı seviyesindeki bir programın işletim sisteminden donanım veya sistem kaynaklarına erişim gibi hizmetler talep etmesini sağlayan bir mekanizmadır.</p>
                <ul>
                    <li><strong>Amaç:</strong> Kullanıcı süreçlerinin, dosya okuma/yazma, bellek tahsisi, süreç oluşturma gibi işlemleri güvenli ve kontrollü bir şekilde gerçekleştirmesini sağlamak.</li>
                    <li><strong>Nasıl Çalışır:</strong>
                        <ul>
                            <li>Kullanıcı programı, bir sistem çağrısı (örneğin, <code>open()</code>, <code>fork()</code>) yapar.</li>
                            <li>CPU, kullanıcı modundan çekirdek moduna geçer, bu geçiş bir kesme (interrupt) ile tetiklenir.</li>
                            <li>İşletim sistemi, isteği işler ve sonucu kullanıcı programına döndürür.</li>
                        </ul>
                    </li>
                    <li><strong>Örnekler:</strong>
                        <ul>
                            <li><code>write()</code>: Bir dosyaya veri yazmak.</li>
                            <li><code>fork()</code>: Yeni bir süreç oluşturmak.</li>
                            <li><code>getpid()</code>: Süreç kimliğini almak.</li>
                        </ul>
                    </li>
                    <li><strong>Güvenlik:</strong> Sistem çağrıları, donanıma doğrudan erişimi engelleyerek yalnızca işletim sisteminin yetkilendirdiği işlemlere izin verir.</li>
                    <li><strong>Örnek:</strong> Bir metin editörü, <code>write()</code> sistem çağrısıyla kullanıcının yazdığı verileri diske kaydeder.</li>
                </ul>
                <div class="example">
                    <p><strong>Örnek:</strong> Bir C programı, <code>open("file.txt", O_RDONLY)</code> çağrısı yaparak bir dosyayı okumak için işletim sisteminden izin alır; işletim sistemi, dosya erişim yetkilerini kontrol eder ve dosyayı açar.</p>
                </div>
                <p><strong>Analitik Perspektif:</strong> Sistem çağrıları, güvenlik ve soyutlama sağlar, ancak sık çağrılar bağlam değiştirme maliyeti nedeniyle performansı etkileyebilir; bu nedenle, modern sistemler sistem çağrılarını optimize etmeye çalışır.</p>
            </div>
        </div>

        <div class="question">
            <h2>Soru 5: İşletim sistemleri bağlamında soyutlama nedir?</h2>
            <div class="toggle-btn" onclick="toggleAnswer('answer5')">Cevabı Göster/Gizle</div>
            <div id="answer5" class="answer">
                <p><strong>Cevap:</strong></p>
                <p>İşletim sistemlerinde soyutlama, karmaşık donanım ve sistem kaynaklarını kullanıcılar ve uygulamalar için daha basit, anlaşılır ve yönetilebilir bir arayüz olarak sunma işlemidir, böylece düşük seviyeli detaylar gizlenir.</p>
                <ul>
                    <li><strong>Amaç:</strong> Kullanıcıların ve programların, donanımın karmaşıklığını bilmeden sistemle etkileşim kurmasını sağlamak, kullanım kolaylığı ve taşınabilirlik sunmak.</li>
                    <li><strong>Örnekler:</strong>
                        <ul>
                            <li><strong>Sanal Bellek:</strong> Süreçlere fiziksel belleğin fiziksel konumlarını ve sınırlamalarını gizleyerek bağımsız, geniş bir adres alanı sunar.</li>
                            <li><strong>Dosya Sistemi:</strong> Diskteki fiziksel sektörleri ve veri bloklarını, dosya ve dizin gibi soyut kavramlarla temsil eder, kullanıcıya basit bir erişim sağlar.</li>
                            <li><strong>Süreç Soyutlaması:</strong> CPU, bellek ve diğer kaynaklar, her süreç için bağımsız bir yürütme ortamı gibi görünür, süreçler arası çakışmalar önlenir.</li>
                            <li><strong>Aygıt Sürücüleri:</strong> Karmaşık donanım cihazlarını (örneğin, yazıcılar) standart arayüzlerle soyutlar.</li>
                        </ul>
                    </li>
                    <li><strong>Örnek:</strong> Bir program, <code>fopen()</code> ile bir dosyayı açar; işletim sistemi, diskin fiziksel sektörlerini yönetir ve program bu detayları bilmez.</li>
                </ul>
                <div class="example">
                    <p><strong>Örnek:</strong> Bir kullanıcı, bir USB sürücüsüne dosya kaydeder; işletim sistemi, dosya sistemini ve USB protokolünü soyutlayarak kullanıcıya yalnızca bir “kaydet” arayüzü sunar.</p>
                </div>
                <p><strong>Analitik Perspektif:</strong> Soyutlama, kullanım kolaylığı, taşınabilirlik ve güvenlik sağlar, ancak ek soyutlama katmanları performans ek yükü getirebilir; bu nedenle, soyutlama seviyesi sistem tasarımıyla dengelenmelidir.</p>
            </div>
        </div>

        <div class="question">
            <h2>Soru 6: Eşzamanlılık nedir?</h2>
            <div class="toggle-btn" onclick="toggleAnswer('answer6')">Cevabı Göster/Gizle</div>
            <div id="answer6" class="answer">
                <p><strong>Cevap:</strong></p>
                <p>Eşzamanlılık (concurrency), birden fazla sürecin veya iş parçacığının aynı anda yürütülüyormuş gibi görünmesini sağlayan işletim sistemi özelliğidir, böylece sistem kaynaklarının verimli kullanımı sağlanır.</p>
                <ul>
                    <li><strong>Açıklama:</strong>
                        <ul>
                            <li>Tek işlemcili sistemlerde, eşzamanlılık bağlam anahtarlama ile sağlanır; CPU, süreçler arasında hızlı geçiş yaparak paralel çalışma illüzyonu yaratır.</li>
                            <li>Çok işlemcili sistemlerde, gerçek paralel yürütme mümkündür; her çekirdek farklı bir süreci veya iş parçacığını çalıştırabilir.</li>
                        </ul>
                    </li>
                    <li><strong>Mekanizmalar:</strong>
                        <ul>
                            <li><strong>Çizelgeleme (Scheduling):</strong> CPU zamanını süreçler arasında adil bir şekilde paylaştırır (örneğin, Round Robin).</li>
                            <li><strong>Bağlam Anahtarlama (Context Switching):</strong> Süreçlerin durumlarını kaydedip yükleyerek CPU’yu paylaşır.</li>
                            <li><strong>Senkronizasyon Araçları:</strong> Semaforlar, kilitler veya monitörler, süreçler arası veri tutarlılığını sağlar.</li>
                        </ul>
                    </li>
                    <li><strong>Örnek:</strong> Bir sistemde metin editörü, web tarayıcı ve müzik çalar aynı anda çalışıyormuş gibi görünür; CPU, her birine kısa zaman dilimleri atar.</li>
                    <li><strong>Zorluklar:</strong> Yarış koşulları (race conditions) ve kilitlenmeler, yanlış senkronizasyon nedeniyle ortaya çıkabilir.</li>
                </ul>
                <div class="example">
                    <p><strong>Örnek:</strong> Bir kullanıcı, bir metin editöründe yazı yazarken aynı anda bir tarayıcıda video izler; işletim sistemi, CPU’yu süreçler arasında paylaştırır ve senkronizasyonla çakışmaları önler.</p>
                </div>
                <p><strong>Analitik Perspektif:</strong> Eşzamanlılık, sistem kaynaklarının verimli kullanımını sağlar ve kullanıcı deneyimini iyileştirir; ancak yanlış senkronizasyon kilitlenme veya yarış koşullarına yol açabilir, bu nedenle dikkatli tasarım gereklidir.</p>
            </div>
        </div>

        <div class="question">
            <h2>Soru 7: Linux'ta proc dizininin amacı nedir? Dizin içerisinde hangi bilgiler bulunur?</h2>
            <div class="toggle-btn" onclick="toggleAnswer('answer7')">Cevabı Göster/Gizle</div>
            <div id="answer7" class="answer">
                <p><strong>Cevap:</strong></p>
                <p>Linux’ta <code>/proc</code> dizini, çalışan sistemin ve süreçlerin dinamik durum bilgilerini sağlayan sanal bir dosya sistemidir, sistem izleme ve hata ayıklamayı kolaylaştırır.</p>
                <ul>
                    <li><strong>Amaç:</strong>
                        <ul>
                            <li>Sistemin ve süreçlerin gerçek zamanlı bilgilerini kullanıcıya ve uygulamalara sunarak şeffaflık sağlar.</li>
                            <li>Sistem performansını izlemek, hata ayıklamak ve kaynak kullanımını analiz etmek için kullanılır.</li>
                            <li>Sanal bir dosya sistemi olarak, diskte fiziksel alan kaplamaz; bilgiler çekirdek tarafından dinamik olarak oluşturulur.</li>
                        </ul>
                    </li>
                    <li><strong>İçerik:</strong>
                        <ul>
                            <li><strong>Süreç Bilgileri:</strong> Her süreç için bir alt dizin (örneğin, <code>/proc/[pid]</code>) bulunur ve şunları içerir:
                                <ul>
                                    <li><code>stat</code>: Süreç durumu, CPU kullanımı, öncelik.</li>
                                    <li><code>cmdline</code>: Sürecin komut satırı argümanları.</li>
                                    <li><code>mem</code>: Bellek kullanımı ve adres alanı bilgileri.</li>
                                    <li><code>fd</code>: Açık dosya tanımlayıcıları.</li>
                                </ul>
                            </li>
                            <li><strong>Sistem Bilgileri:</strong>
                                <ul>
                                    <li><code>/proc/cpuinfo</code>: İşlemci modeli, hızı, çekirdek sayısı.</li>
                                    <li><code>/proc/meminfo</code>: Toplam ve kullanılan bellek, takas alanı.</li>
                                    <li><code>/proc/uptime</code>: Sistem çalışma süresi ve boşta kalma süresi.</li>
                                </ul>
                            </li>
                            <li><strong>Donanım Bilgileri:</strong>
                                <ul>
                                    <li><code>/proc/devices</code>: Kullanılan aygıt sürücüleri.</li>
                                    <li><code>/proc/interrupts</code>: Kesme (interrupt) istatistikleri.</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li><strong>Örnek:</strong> <code>cat /proc/cpuinfo</code> komutu, CPU modelini, hızını ve çekirdek sayısını gösterir; <code>cat /proc/[pid]/status</code>, bir sürecin bellek ve CPU kullanımını listeler.</li>
                </ul>
                <div class="example">
                    <p><strong>Örnek:</strong> Bir sistem yöneticisi, <code>top</code> komutunun <code>/proc/meminfo</code> ve <code>/proc/stat</code> dosyalarını okuyarak sistemin bellek ve CPU kullanımını izler.</p>
                </div>
                <p><strong>Analitik Perspektif:</strong> <code>/proc</code>, sistem şeffaflığı ve hata ayıklama için güçlü bir araçtır, ancak yanlış okuma/yazma işlemleri sistem kararsızlığına neden olabilir; bu nedenle dikkatli kullanım gereklidir.</p>
            </div>
        </div>

        <div class="question">
            <h2>Soru 8: Von Neumann mimarisinin en önemli özelliği nedir?</h2>
            <div class="toggle-btn" onclick="toggleAnswer('answer8')">Cevabı Göster/Gizle</div>
            <div id="answer8" class="answer">
                <p><strong>Cevap:</strong></p>
                <p>Von Neumann mimarisinin en önemli özelliği, program talimatlarının ve verilerin aynı bellek alanında saklanmasıdır (stored-program concept), bu da bilgisayarların esnek ve yeniden programlanabilir olmasını sağlar.</p>
                <ul>
                    <li><strong>Açıklama:</strong>
                        <ul>
                            <li>CPU, talimatları (kod) ve verileri aynı bellekten (örneğin, RAM) alır, böylece programlar bellekte saklanabilir ve değiştirilebilir.</li>
                            <li>Bu, sabit kablolu sistemlere kıyasla programlamayı kolaylaştırır ve genel amaçlı bilgisayarların temelini oluşturur.</li>
                        </ul>
                    </li>
                    <li><strong>Avantajlar:</strong>
                        <ul>
                            <li>Programların kolayca değiştirilmesi ve güncellenmesi.</li>
                            <li>Bellek alanının dinamik olarak kod ve veri arasında paylaşılması.</li>
                        </ul>
                    </li>
                    <li><strong>Dezavantajlar:</strong>
                        <ul>
                            <li>Veri ve talimatların aynı veri yolunu paylaşması (Von Neumann bottleneck), performans sınırlamalarına yol açar.</li>
                            <li>Önbellek ve boru hattı (pipeline) gibi modern teknikler bu sorunu hafifletir.</li>
                        </ul>
                    </li>
                    <li><strong>Örnek:</strong> Bir C programının kodu ve değişkenleri RAM’de saklanır; CPU, program sayacını kullanarak talimatları sırayla okur ve yürütür.</li>
                </ul>
                <div class="example">
                    <p><strong>Örnek:</strong> Bir hesap makinesi programı, toplama talimatlarını ve sayısal verileri RAM’de saklar; CPU, bu talimatları okuyarak toplama işlemini gerçekleştirir.</p>
                </div>
                <p><strong>Analitik Perspektif:</strong> Von Neumann mimarisi, modern bilgisayarların temelini oluşturur ve esneklik sağlar; ancak performans sınırlamaları nedeniyle Harvard mimarisi (ayrık kod ve veri belleği) gibi alternatifler, özellikle gömülü sistemlerde tercih edilir.</p>
            </div>
        </div>

        <div class="question">
            <h2>Soru 9: Mikro çekirdek ve monolitik mimariyi karşılaştırınız.</h2>
            <div class="toggle-btn" onclick="toggleAnswer('answer9')">Cevabı Göster/Gizle</div>
            <div id="answer9" class="answer">
                <p><strong>Cevap:</strong></p>
                <p>Mikro çekirdek ve monolitik mimari, işletim sistemi tasarımında iki farklı yaklaşımdır; her biri farklı avantajlar ve dezavantajlar sunar. Aşağıda detaylı bir karşılaştırma yapılmıştır:</p>
                <table border="1">
                    <tr>
                        <th>Özellik</th>
                        <th>Mikro Çekirdek</th>
                        <th>Monolitik Mimari</th>
                    </tr>
                    <tr>
                        <td><strong>Tanım</strong></td>
                        <td>Çekirdek, yalnızca temel işlevleri (süreç yönetimi, iş parçacığı yönetimi, süreçler arası iletişim) içerir; dosya sistemi, sürücüler ve ağ gibi hizmetler kullanıcı modunda ayrı süreçler olarak çalışır.</td>
                        <td>Çekirdek, tüm işletim sistemi hizmetlerini (süreç yönetimi, bellek yönetimi, dosya sistemi, sürücüler, ağ) tek bir büyük modülde içerir ve çekirdek modunda çalışır.</td>
                    </tr>
                    <tr>
                        <td><strong>Örnek</strong></td>
                        <td>Minix, QNX, Mach (macOS’un bazı bileşenleri).</td>
                        <td>Linux, Windows (eski sürümler), Unix.</td>
                    </tr>
                    <tr>
                        <td><strong>Avantajlar</strong></td>
                        <td>
                            <ul>
                                <li><strong>Modülerlik:</strong> Hizmetler ayrı süreçler olarak çalıştığından bakım ve güncelleme kolaydır.</li>
                                <li><strong>Güvenilirlik:</strong> Bir hizmetin çökmesi, çekirdeği etkilemez; hatalar izole edilir.</li>
                                <li><strong>Taşınabilirlik:</strong> Minimal çekirdek, farklı donanımlara kolayca uyarlanabilir.</li>
                                <li><strong>Güvenlik:</strong> Çekirdek dışı hizmetler, daha az yetkiyle çalışır.</li>
                            </ul>
                        </td>
                        <td>
                            <ul>
                                <li><strong>Yüksek Performans:</strong> Tüm hizmetler çekirdek modunda çalıştığından sistem çağrıları hızlıdır.</li>
                                <li><strong>Basitlik:</strong> Tek modül, tasarım ve geliştirmeyi kolaylaştırır.</li>
                                <li><strong>Etkili İletişim:</strong> Modüller arası iletişim hızlıdır, çünkü hepsi aynı adres alanında çalışır.</li>
                            </ul>
                        </td>
                    </tr>
                    <tr>
                        <td><strong>Dezavantajlar</strong></td>
                        <td>
                            <ul>
                                <li><strong>Performans:</strong> Kullanıcı ve çekirdek modları arasında sık geçiş, sistem çağrılarını yavaşlatır.</li>
                                <li><strong>Karmaşıklık:</strong> Süreçler arası iletişim (IPC) mekanizmaları karmaşıktır ve ek yük getirir.</li>
                                <li><strong>Geliştirme Zorluğu:</strong> Modüler tasarım, daha fazla kodlama ve test gerektirir.</li>
                            </ul>
                        </td>
                        <td>
                            <ul>
                                <li><strong>Güvenilirlik:</strong> Bir modülün çökmesi, tüm çekirdeği ve sistemi etkileyebilir.</li>
                                <li><strong>Bakım:</strong> Büyük ve karmaşık çekirdek, güncelleme ve hata ayıklamayı zorlaştırır.</li>
                                <li><strong>Taşınabilirlik:</strong> Donanıma özgü kodlar, taşınabilirliği sınırlar.</li>
                            </ul>
                        </td>
                    </tr>
                    <tr>
                        <td><strong>Kullanım</strong></td>
                        <td>Gömülü sistemler, gerçek zamanlı sistemler ve yüksek güvenilirlik gereken ortamlar (örneğin, otomotiv, havacılık).</td>
                        <td>Genel amaçlı sistemler, masaüstü ve sunucu ortamları, yüksek performans gereken yerler.</td>
                    </tr>
                </table>
                <div class="example">
                    <p><strong>Örnek:</strong> QNX (mikro çekirdek), bir arabanın kontrol sisteminde modülerlik ve güvenilirlik için kullanılırken; Linux (monolitik), bir web sunucusunda yüksek performans için tercih edilir.</p>
                </div>
                <p><strong>Analitik Perspektif:</strong> Mikro çekirdek, modülerlik ve güvenilirlik için uygundur, ancak performans maliyeti yüksektir; monolitik mimari, yüksek performans sunar, ancak bakım ve güvenilirlik açısından zorluklar yaratabilir. Seçim, sistem ihtiyaçlarına ve uygulama alanına bağlıdır.</p>
            </div>
        </div>

        <div class="question">
            <h2>Soru 10: Kesme tabanlı (preemptive) ile kesme tabanlı olmayan (non-preemptive) çizelgeleme algoritmaları arasındaki fark nedir?</h2>
            <div class="toggle-btn" onclick="toggleAnswer('answer10')">Cevabı Göster/Gizle</div>
            <div id="answer10" class="answer">
                <p><strong>Cevap:</strong></p>
                <p>Kesme tabanlı (preemptive) ve kesme tabanlı olmayan (non-preemptive) çizelgeleme algoritmaları, süreçlerin CPU’ya erişimini düzenleme yöntemlerinde farklılık gösterir; bu farklar, sistem performansı ve yanıt sürelerini etkiler:</p>
                <table border="1">
                    <tr>
                        <th>Özellik</th>
                        <th>Kesme Tabanlı (Preemptive)</th>
                        <th>Kesme Tabanlı Olmayan (Non-Preemptive)</th>
                    </tr>
                    <tr>
                        <td><strong>Tanım</strong></td>
                        <td>İşletim sistemi, çalışan süreci zaman dilimi dolduğunda veya daha yüksek öncelikli bir süreç hazır olduğunda keser ve CPU’yu başka bir sürece atar.</td>
                        <td>Süreç, CPU’yu gönüllü olarak bırakana (örneğin, I/O isteği veya tamamlanma) veya tamamlanana kadar çalışır; işletim sistemi zorla kesmez.</td>
                    </tr>
                    <tr>
                        <td><strong>Örnek Algoritmalar</strong></td>
                        <td>Round Robin, Öncelik Tabanlı Çizelgeleme, Çok Seviyeli Kuyruk.</td>
                        <td>İlk Gelen İlk Hizmet (FCFS), En Kısa İş Önce (SJF), En Kısa Kalan Süre Önce (SRTF).</td>
                    </tr>
                    <tr>
                        <td><strong>Avantajlar</strong></td>
                        <td>
                            <ul>
                                <li><strong>Hızlı Yanıt:</strong> Yüksek öncelikli süreçlere hızlı erişim sağlar, gerçek zamanlı sistemler için uygundur.</li>
                                <li><strong>Adalet:</strong> Zaman paylaşımı ile tüm süreçlere CPU zamanı verir, uzun süreçlerin sistemi kilitlemesini önler.</li>
                                <li><strong>Esneklik:</strong> Dinamik öncelik değişikliklerine uyum sağlar.</li>
                            </ul>
                        </td>
                        <td>
                            <ul>
                                <li><strong>Basitlik:</strong> Bağlam değiştirme az olduğundan yönetim basittir ve ek yük düşüktür.</li>
                                <li><strong>Verimlilik:</strong> Uzun süren süreçler için uygundur, çünkü kesintiye uğramaz.</li>
                                <li><strong>Düşük Maliyet:</strong> Bağlam değiştirme nadirdir, bu da CPU kaynaklarını korur.</li>
                            </ul>
                        </td>
                    </tr>
                    <tr>
                        <td><strong>Dezavantajlar</strong></td>
                        <td>
                            <ul>
                                <li><strong>Ek Yük:</strong> Sık bağlam değiştirme, CPU zamanını boşa harcar (mikro/nanosaniye mertebesinde).</li>
                                <li><strong>Karmaşıklık:</strong> Çizelgeleme algoritmaları daha karmaşıktır, öncelik yönetimi gerekir.</li>
                            </ul>
                        </td>
                        <td>
                            <ul>
                                <li><strong>Gecikme:</strong> Uzun süreçler, kısa veya yüksek öncelikli süreçleri geciktirebilir (konvoy etkisi).</li>
                                <li><strong>Adaletsizlik:</strong> Kısa süreçler, uzun süreçlerin tamamlanmasını bekler.</li>
                            </ul>
                        </td>
                    </tr>
                    <tr>
                        <td><strong>Örnek</strong></td>
                        <td>Round Robin’de bir süreç 10 ms çalışır, zamanlayıcı kesmesiyle durdurulur ve başka bir süreç çalışır.</td>
                        <td>FCFS’de bir süreç, tamamlanana veya I/O isteği yapana kadar CPU’yu tutar.</td>
                    </tr>
                </table>
                <div class="example">
                    <p><strong>Örnek:</strong> Bir sistemde Round Robin (preemptive) ile bir metin editörü 10 ms çalışır, ardından tarayıcıya geçilir; FCFS (non-preemptive) ile tarayıcı tamamlanana kadar editör bekler.</p>
                </div>
                <p><strong>Analitik Perspektif:</strong> Kesme tabanlı algoritmalar, dinamik ve adaletli sistemler için uygundur, özellikle kullanıcı etkileşimli veya gerçek zamanlı sistemlerde; kesme tabanlı olmayanlar ise basitlik ve düşük ek yük gerektiren toplu iş sistemlerinde tercih edilir. Seçim, sistem ihtiyaçlarına ve süreç özelliklerine bağlıdır.</p>
            </div>
        </div>

        <div class="question">
            <h2>Soru 11: "Round Robin" zamanlama algoritmasında, zaman dilimi (time quantum) çok küçük seçilirse ne olur?</h2>
            <div class="toggle-btn" onclick="toggleAnswer('answer11')">Cevabı Göster/Gizle</div>
            <div id="answer11" class="answer">
                <p><strong>Cevap:</strong></p>
                <p><strong>Doğru cevap: b) Bağlam değiştirme (context switch) masrafı artar ve sistem verimliliği azalır.</strong></p>
                <p><strong>Açıklama:</strong></p>
                <ul>
                    <li><strong>Round Robin Algoritması:</strong> Her süreç, sabit bir zaman dilimi (quantum) süresince CPU’yu kullanır; zaman dolduğunda veya süreç kesildiğinde, CPU başka bir sürece geçer.</li>
                    <li><strong>Zaman Dilimi Çok Küçükse:</strong>
                        <ul>
                            <li>Süreçler sık sık kesilir, bu da bağlam değiştirme (context switch) sayısını artırır.</li>
                            <li>Bağlam değiştirme, süreç durumlarının (program sayacı, yazmaçlar, yığın işaretçisi) kaydedilip yüklenmesini içerir ve bu işlem mikro veya nanosaniye mertebesinde zaman alır.</li>
                            <li>Bu ek yük, CPU’nun süreç yürütmek yerine bağlam değiştirmeye daha fazla zaman harcamasına neden olur, böylece sistem verimliliği azalır.</li>
                            <li><strong>Örnek:</strong> 1 ms quantum ile 10 süreç, saniyede 1000 bağlam değiştirmeye yol açar, bu da CPU’nun %10-20’sini tüketebilir.</li>
                        </ul>
                    </li>
                    <li><strong>Diğer Şıkların Değerlendirmesi:</strong>
                        <ul>
                            <li><strong>a) Sistem verimliliği artar ve süreçler daha hızlı tamamlanır:</strong> Yanlış, çünkü sık bağlam değiştirme performansı düşürür; süreçler daha az CPU zamanı alır.</li>
                            <li><strong>c) Süreçler arasında adalet sağlanamaz:</strong> Yanlış, küçük zaman dilimi adaleti artırır, çünkü her süreç sık sık CPU alır, ancak performans azalır.</li>
                            <li><strong>d) Kilitlenme olasılığı artar:</strong> Yanlış, zaman dilimi boyutu kilitlenmeyi doğrudan etkilemez; kilitlenme, kaynak yönetimiyle ilgilidir.</li>
                        </ul>
                    </li>
                </ul>
                <div class="example">
                    <p><strong>Örnek:</strong> Bir sistemde 5 süreç, 1 ms quantum ile çalışıyorsa, CPU her milisaniyede bağlam değiştirir; bu, bir sürecin 100 ms’lik işini tamamlaması için 500 ms’lik toplam sürede ek yük yaratır.</p>
                </div>
                <p><strong>Analitik Perspektif:</strong> Zaman dilimi seçimi, adalet ve performans arasında bir dengedir; çok küçük quantum, bağlam değiştirme ek yükünü artırır, çok büyük quantum ise kesme tabanlı olmayan çizelgelemeye yaklaşarak adaleti azaltır. Optimal quantum, sistem yüküne ve süreç sayısına bağlıdır.</p>
            </div>
        </div>

        <div class="question">
            <h2>Soru 12: Aşağıdaki senkronizasyon mekanizmalarından hangisi, meşgul bekleme (busy waiting) yöntemine dayanır?</h2>
            <div class="toggle-btn" onclick="toggleAnswer('answer12')">Cevabı Göster/Gizle</div>
            <div id="answer12" class="answer">
                <p><strong>Cevap:</strong></p>
                <p><strong>Doğru cevap: c) Döngüsel Kilit (Spinlock)</strong></p>
                <p><strong>Açıklama:</strong></p>
                <ul>
                    <li><strong>Meşgul Bekleme (Busy Waiting):</strong> Bir süreç veya iş parçacığı, bir kaynağın serbest olmasını beklerken CPU’yu sürekli kontrol ederek meşgul tutar, bu da CPU’nun boşa çalışmasına neden olur.</li>
                    <li><strong>Spinlock:</strong>
                        <ul>
                            <li>Süreç, kilidin serbest olmasını beklerken bir döngü içinde durumu kontrol eder (örneğin, <code>while(lock)</code>), bu da meşgul beklemeye örnektir.</li>
                            <li>Genellikle kısa süreli kilitler için kullanılır, özellikle çok çekirdekli sistemlerde, çünkü bağlam değiştirme maliyetinden kaçınılır.</li>
                            <li><strong>Örnek:</strong> Bir iş parçacığı, paylaşılan bir belleğe erişmek için spinlock kullanır; kilit serbest olana kadar döngüde bekler.</li>
                        </ul>
                    </li>
                    <li><strong>Diğer Şıkların Değerlendirmesi:</strong>
                        <ul>
                            <li><strong>a) Semafor:</strong> Süreçleri engelleyerek (blocked state) bekletir; CPU’yu serbest bırakır, bu nedenle meşgul bekleme değildir.</li>
                            <li><strong>b) Gözleyici (Monitor):</strong> İş parçacıklarını kuyruğa alarak bekletir ve CPU’yu serbest bırakır, meşgul bekleme kullanmaz.</li>
                            <li><strong>d) Koşul Değişkeni:</strong> Süreçleri askıya alarak (wait state) bekletir, CPU’yu meşgul etmez.</li>
                        </ul>
                    </li>
                </ul>
                <div class="example">
                    <p><strong>Örnek:</strong> Çok çekirdekli bir sistemde, bir iş parçacığı spinlock ile bir veritabanı kilidini kontrol eder; kilit serbest olana kadar döngüde bekler, bu da CPU’yu kısa süreli meşgul tutar.</p>
                </div>
                <p><strong>Analitik Perspektif:</strong> Spinlock, kısa süreli kilitler için uygundur ve bağlam değiştirme maliyetini azaltır; ancak uzun beklemelerde CPU israfına yol açar, bu nedenle semafor veya monitör gibi mekanizmalar uzun süreli senkronizasyon için daha verimlidir.</p>
            </div>
        </div>

        <div class="question">
            <h2>Soru 13: Bir işletim sisteminde, iki süreç arasında süreçler arası iletişim (inter-process communication) için paylaşılan bellek (shared memory) kullanıldığında, hangi durum senkronizasyon gerektirmez?</h2>
            <div class="toggle-btn" onclick="toggleAnswer('answer13')">Cevabı Göster/Gizle</div>
            <div id="answer13" class="answer">
                <p><strong>Cevap:</strong></p>
                <p><strong>Doğru cevap: c) Her iki süreç de okuma yapıyorsa</strong></p>
                <p><strong>Açıklama:</strong></p>
                <ul>
                    <li><strong>Paylaşılan Bellek:</strong> Süreçler arası iletişimde, iki süreç aynı bellek bölgesine erişir; veri tutarlılığını sağlamak için genellikle senkronizasyon (kilitler, semaforlar) gerekir.</li>
                    <li><strong>Her İki Süreç de Okuma Yapıyorsa:</strong>
                        <ul>
                            <li>Veri değiştirilmez, bu nedenle yarış koşulu (race condition) veya veri bozulması riski yoktur.</li>
                            <li>Senkronizasyon (örneğin, kilitler) gerekmez, çünkü okuma işlemleri birbirini etkilemez.</li>
                            <li><strong>Örnek:</strong> İki süreç, bir paylaşılan veri tabanındaki sabit bir tabloyu okur; veri değişmediği için kilit gerekmez.</li>
                        </ul>
                    </li>
                    <li><strong>Diğer Şıkların Değerlendirmesi:</strong>
                        <ul>
                            <li><strong>a) Bir süreç yazarken diğer süreç okuma yapıyorsa:</strong> Okuma işlemi, yazma sırasında eski veya tutarsız veri alabilir (örneğin, yarım yazılmış veri); senkronizasyon gerekir.</li>
                            <li><strong>b) Her iki süreç de aynı anda yazma yapıyorsa:</strong> Yarış koşulu oluşur, veri bozulabilir (örneğin, bir süreç diğerinin yazdığını ezer); kilit şarttır.</li>
                            <li><strong>d) Bir süreç belleği temizlerken diğer süreç erişmeye çalışıyorsa:</strong> Veri kaybı veya erişim hatası oluşabilir; senkronizasyon kritik öneme sahiptir.</li>
                        </ul>
                    </li>
                </ul>
                <div class="example">
                    <p><strong>Örnek:</strong> Bir veri analizi uygulaması, iki sürecin paylaşılan bir bellek bölgesindeki sabit bir veri setini okumasını sağlar; süreçler veri değiştirmediği için senkronizasyona gerek yoktur.</p>
                </div>
                <p><strong>Analitik Perspektif:</strong> Salt okuma senaryoları, senkronizasyon ek yükünü ortadan kaldırır ve performansı artırır; ancak yazma içeren durumlarda kilitler, semaforlar veya monitörler gibi senkronizasyon mekanizmaları veri tutarlılığı için zorunludur.</p>
            </div>
        </div>

        <div class="question">
            <h2>Soru 14: Öncelik tersine dönmesi (Priority Inversion) sorunu nedir ve hangi senaryoda ortaya çıkar?</h2>
            <div class="toggle-btn" onclick="toggleAnswer('answer14')">Cevabı Göster/Gizle</div>
            <div id="answer14" class="answer">
                <p><strong>Cevap:</strong></p>
                <p><strong>Doğru cevap: a) Düşük öncelikli bir iş parçacığının, yüksek öncelikli bir iş parçacığını engellemesi; paylaşılan bir kaynak kilitlendiğinde</strong></p>
                <p><strong>Açıklama:</strong></p>
                <ul>
                    <li><strong>Öncelik Tersine Dönmesi (Priority Inversion):</strong> Düşük öncelikli bir iş parçacığı, paylaşılan bir kaynağı kilitlediğinde, yüksek öncelikli bir iş parçacığını bekletir ve bu durum öncelik sıralamasını tersine çevirir, sistem performansını etkiler.</li>
                    <li><strong>Senaryo:</strong>
                        <ul>
                            <li>Düşük öncelikli iş parçacığı (T3) bir kaynağı (örneğin, bir kilit) tutar.</li>
                            <li>Yüksek öncelikli iş parçacığı (T1) bu kaynağı talep eder ve T3 serbest bırakana kadar bekler.</li>
                            <li>Orta öncelikli bir iş parçacığı (T2), T3’ü keserek CPU’yu alır, böylece T1’in beklemesi uzar, bu da öncelik tersine dönmesine neden olur.</li>
                        </ul>
                    </li>
                    <li><strong>Çözüm Yöntemleri:</strong>
                        <ul>
                            <li><strong>Öncelik Mirası (Priority Inheritance):</strong> T3, T1’in önceliğini geçici olarak devralır, böylece T2 tarafından kesilmez.</li>
                            <li><strong>Öncelik Tavanı (Priority Ceiling):</strong> Kaynağın önceliği, en yüksek öncelikli iş parçacığına ayarlanır.</li>
                        </ul>
                    </li>
                    <li><strong>Örnek:</strong> Gerçek zamanlı bir sistemde, düşük öncelikli bir görev bir veritabanı kilidini tutar; yüksek öncelikli bir görev bu kilidi beklerken, orta öncelikli bir görev CPU’yu alarak gecikmeye neden olur.</li>
                    <li><strong>Diğer Şıkların Değerlendirmesi:</strong>
                        <ul>
                            <li><strong>b) CPU ele geçirme:</strong> Bu, öncelik tersine dönmesi değil, kötü çizelgeleme veya tasarım hatasıdır.</li>
                            <li><strong>c) Sonsuz döngü:</strong> Bu, öncelik tersine dönmesiyle ilgili değildir; programlama hatasıdır.</li>
                            <li><strong>d) Dosya yazma çakışması:</strong> Bu, yarış koşuludur ve öncelik tersine dönmesiyle bağlantılı değildir.</li>
                        </ul>
                    </li>
                </ul>
                <div class="example">
                    <p><strong>Örnek:</strong> Bir otonom araçta, düşük öncelikli bir veri güncelleme görevi bir sensör kilidini tutar; yüksek öncelikli bir çarpışma önleme görevi bu kilidi beklerken, orta öncelikli bir navigasyon görevi CPU’yu alarak gecikmeye neden olur.</p>
                </div>
                <p><strong>Analitik Perspektif:</strong> Öncelik tersine dönmesi, özellikle gerçek zamanlı sistemlerde ciddi gecikmelere yol açar; öncelik mirası veya tavanı gibi protokoller bu sorunu azaltır, ancak ek karmaşıklık getirir.</p>
            </div>
        </div>

        <div class="question">
            <h2>Soru 15: Bir süreç diskten okuma yapmak istediğinde geçiş yapacağı durum hangisidir?</h2>
            <div class="toggle-btn" onclick="toggleAnswer('answer15')">Cevabı Göster/Gizle</div>
            <div id="answer15" class="answer">
                <p><strong>Cevap:</strong></p>
                <p><strong>Doğru cevap: b) Engellenmiş (blocked)</strong></p>
                <p><strong>Açıklama:</strong></p>
                <ul>
                    <li><strong>Durum Geçişi:</strong> Bir süreç, diskten okuma gibi giriş/çıkış (I/O) işlemi yapmak istediğinde, bu işlem tamamlanana kadar CPU’yu kullanamaz ve <strong>engellenmiş (blocked)</strong> duruma geçer.</li>
                    <li><strong>Süreç Durumları:</strong>
                        <ul>
                            <li><strong>Hazır (ready):</strong> CPU’yu almayı bekleyen süreçler; I/O beklemez.</li>
                            <li><strong>Çalışıyor (running):</strong> CPU’yu aktif olarak kullanan süreç.</li>
                            <li><strong>Engellenmiş (blocked):</strong> I/O işlemi veya başka bir olay (örneğin, kilit) bekleyen süreç; CPU’dan çıkarılır.</li>
                            <li><strong>Sonlandırıldı (terminated):</strong> Süreç tamamlanmış veya iptal edilmiştir.</li>
                        </ul>
                    </li>
                    <li><strong>Süreç:</strong>
                        <ul>
                            <li>Süreç, <code>read()</code> gibi bir sistem çağrısı yapar.</li>
                            <li>İşletim sistemi, I/O işlemini başlatır ve süreci engellenmiş duruma geçirir.</li>
                            <li>I/O tamamlandığında, süreç hazır duruma geri döner.</li>
                        </ul>
                    </li>
                    <li><strong>Örnek:</strong> Bir süreç, bir dosyadan veri okumak için <code>read()</code> sistem çağrısı yapar; disk işlemi bitene kadar engellenir, CPU başka bir sürece tahsis edilir.</li>
                    <li><strong>Diğer Şıkların Değerlendirmesi:</strong>
                        <ul>
                            <li><strong>a) Hazır:</strong> Süreç, CPU’yu bekler; disk I/O’su için uygun değildir.</li>
                            <li><strong>c) Çalışıyor:</strong> Süreç CPU’yu kullanıyordur; I/O beklemesi durumunda çalışamaz.</li>
                            <li><strong>d) Sonlandırıldı:</strong> Süreç bitmiştir ve I/O yapamaz.</li>
                        </ul>
                    </li>
                </ul>
                <div class="example">
                    <p><strong>Örnek:</strong> Bir veritabanı uygulaması, diskten büyük bir tabloyu okumak için <code>read()</code> çağrısı yapar; süreç engellenir, CPU ise bir web tarayıcı sürecine tahsis edilir.</p>
                </div>
                <p><strong>Analitik Perspektif:</strong> Engellenmiş durum, CPU’nun verimli kullanımını sağlar, çünkü I/O bekleyen süreçler CPU’yu serbest bırakır; bu, çoklu görev sistemlerinde kaynak paylaşımını optimize eder.</p>
            </div>
        </div>

        <div class="question">
            <h2>Soru 16: İşletim sistemlerinde süreç denetim bloğunun (PCB) temel amacı nedir?</h2>
            <div class="toggle-btn" onclick="toggleAnswer('answer16')">Cevabı Göster/Gizle</div>
            <div id="answer16" class="answer">
                <p><strong>Cevap:</strong></p>
                <p><strong>Doğru cevap: c) Bir sürecin durumu ve özellikleri hakkındaki bilgileri korumak</strong></p>
                <p><strong>Açıklama:</strong></p>
                <ul>
                    <li><strong>Süreç Denetim Bloğu (PCB):</strong> Her süreç için işletim sisteminin tuttuğu bir veri yapısıdır; sürecin durumunu, özelliklerini ve kaynaklarını saklar, böylece süreç yönetimi mümkün olur.</li>
                    <li><strong>İçerik:</strong>
                        <ul>
                            <li><strong>Süreç Kimliği (PID):</strong> Süreci benzersiz şekilde tanımlar.</li>
                            <li><strong>Durum:</strong> Çalışıyor, hazır, engellenmiş gibi süreç durumu.</li>
                            <li><strong>CPU Bilgileri:</strong> Program sayacı (PC), yazmaçlar, yığın işaretçisi.</li>
                            <li><strong>Bellek Bilgileri:</strong> Sayfa tabloları, bellek sınırları.</li>
                            <li><strong>Kaynaklar:</strong> Açık dosyalar, I/O cihazları, öncelik.</li>
                        </ul>
                    </li>
                    <li><strong>Amaç:</strong>
                        <ul>
                            <li>Bağlam anahtarlama sırasında sürecin durumunu kaydetmek ve geri yüklemek.</li>
                            <li>Süreçlerin çizelgelenmesini, yönetilmesini ve izlenmesini sağlamak.</li>
                            <li>İşletim sisteminin süreçler üzerinde kontrol sahibi olmasını mümkün kılmak.</li>
                        </ul>
                    </li>
                    <li><strong>Örnek:</strong> Bir süreç kesildiğinde, PCB’sine program sayacı ve yazmaçlar kaydedilir; başka bir süreç çalıştırıldıktan sonra PCB’den bilgiler geri yüklenir.</li>
                    <li><strong>Diğer Şıkların Değerlendirmesi:</strong>
                        <ul>
                            <li><strong>a) Yürütülebilir kodu saklamak:</strong> PCB, kodu değil, kodun bellekteki konumunu (örneğin, program sayacı) işaret eder.</li>
                            <li><strong>b) Kaynak tahsisini yönetmek:</strong> PCB, kaynak bilgilerini saklar, ancak tahsisi işletim sistemi yapar.</li>
                            <li><strong>d) Süreç dışı iletişim:</strong> PCB, iletişim için değil, süreç yönetimi için kullanılır; iletişim için borular veya mesaj kuyrukları kullanılır.</li>
                        </ul>
                    </li>
                </ul>
                <div class="example">
                    <p><strong>Örnek:</strong> Bir metin editörü süreci kesildiğinde, PCB’sine mevcut belge konumu ve yazmaçlar kaydedilir; CPU, bir tarayıcı sürecine geçer ve editörün durumu PCB’den geri yüklenir.</p>
                </div>
                <p><strong>Analitik Perspektif:</strong> PCB, süreç yönetiminin temel taşıdır; eksik veya hatalı PCB, bağlam anahtarlamasını bozar ve sistem kararlılığını tehdit eder; bu nedenle PCB’nin doğru ve hızlı yönetimi kritik öneme sahiptir.</p>
            </div>
        </div>
    </div>

    <script>
        function toggleAnswer(answerId) {
            const answer = document.getElementById(answerId);
            answer.classList.toggle('hidden');
        }
    </script>

</body>

</html>