</script>
<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>İşletim Sistemleri Vize Soru ve Cevapları</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f4f4f4;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }

        h1 {
            text-align: center;
            color: #333;
        }

        .question {
            margin: 20px 0;
            border-left: 4px solid #007BFF;
            padding-left: 15px;
        }

        .question h2 {
            color: #007BFF;
            margin-bottom: 10px;
        }

        .answer {
            margin-bottom: 20px;
            display: none;
        }

        .answer h3 {
            color: #444;
            margin-top: 15px;
        }

        .answer p,
        .answer ul,
        .answer ol {
            margin: 10px 0;
            color: #333;
        }

        .answer ul,
        .answer ol {
            padding-left: 20px;
        }

        .answer ul li,
        .answer ol li {
            margin-bottom: 8px;
        }

        .example {
            background: #e9ecef;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }

        .toggle-btn {
            background: #007BFF;
            color: #fff;
            border: none;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            margin-bottom: 10px;
            display: inline-block;
        }

        .toggle-btn:hover {
            background: #0056b3;
        }

        .answer.hidden {
            display: block;
        }
    </style>
    <script>
        function toggleAnswer(id) {
            var answer = document.getElementById(id);
            answer.style.display = answer.style.display === "none" ? "block" : "none";
        }
    </script>
</head>

<body>
    <div class="container">
        <h1>İşletim Sistemleri Soru ve Cevapları</h1>
        <p style="text-align: center; color: #555;">2023-2024 Vize Sınavı</p>

        <div class="question">
            <h2>Soru 1: İşletim sisteminin temel fonksiyonlarını birer cümle ile listeleyiniz.</h2>
            <div class="toggle-btn" onclick="toggleAnswer('answer1')">Cevabı Göster/Gizle</div>
            <div id="answer1" class="answer">
                <p><strong>Cevap:</strong></p>
                <p>İşletim sisteminin temel fonksiyonları, sistem kaynaklarını yönetmek, kullanıcı ile donanım arasında
                    arayüz sağlamak ve uygulama yazılımlarının çalışmasını desteklemektir. Aşağıda temel fonksiyonlar
                    birer
                    cümle ile listelenmiştir:</p>
                <ul>
                    <li><strong>Süreç Yönetimi:</strong> İşletim sistemi, süreçlerin oluşturulmasını, yürütülmesini,
                        çizelgelenmesini ve sonlandırılmasını yönetir.</li>
                    <li><strong>Bellek Yönetimi:</strong> Fiziksel ve sanal belleğin süreçler arasında güvenli ve
                        verimli
                        tahsisini sağlar.</li>
                    <li><strong>Dosya Sistemi Yönetimi:</strong> Verilerin saklanması, düzenlenmesi ve erişimi için
                        dosya
                        sistemlerini organize eder.</li>
                    <li><strong>Giriş/Çıkış Yönetimi:</strong> Donanım cihazlarıyla iletişim kurar ve giriş/çıkış
                        işlemlerini koordine eder.</li>
                    <li><strong>Güvenlik ve Erişim Kontrolü:</strong> Sistem kaynaklarına yalnızca yetkili
                        kullanıcıların ve
                        süreçlerin erişmesini sağlar.</li>
                    <li><strong>Kullanıcı Arayüzü:</strong> Kullanıcıların sistemle etkileşim kurmasını sağlayan komut
                        satırı veya grafik arayüz sunar.</li>
                </ul>
                <p><strong>Analitik Perspektif:</strong> İşletim sistemi, donanım ve yazılım arasında bir köprü görevi
                    görerek kaynak kullanımını optimize eder ve sistem performansını artırır.</p>
            </div>
        </div>

        <div class="question">
            <h2>Soru 2: İşlemci ile ana bellek arasında veri erişimini hızlandırmak için neler yapılabilir?</h2>
            <div class="toggle-btn" onclick="toggleAnswer('answer2')">Cevabı Göster/Gizle</div>
            <div id="answer2" class="answer">
                <p><strong>Cevap:</strong></p>
                <p>İşlemci ile ana bellek arasındaki veri erişimini hızlandırmak için çeşitli teknikler kullanılır. Bu
                    teknikler, bellek erişim süresini azaltarak sistem performansını artırır:</p>
                <ol>
                    <li><strong>Önbellek (Cache) Kullanımı:</strong>
                        <ul>
                            <li>Hızlı SRAM tabanlı önbellek, sık kullanılan verileri depolar ve CPU’nun ana belleğe
                                erişim
                                ihtiyacını azaltır.</li>
                            <li>Örnek: L1, L2, L3 önbellekleri, 2-10 ns erişim süresiyle RAM’e (50-100 ns) göre çok daha
                                hızlıdır.</li>
                        </ul>
                    </li>
                    <li><strong>Çeviri Önbelleği (TLB):</strong>
                        <ul>
                            <li>Translation Lookaside Buffer, sanal adresleri fiziksel adreslere çevirmek için sayfa
                                tablosu
                                girişlerini önbelleğe alır.</li>
                            <li>Örnek: TLB isabeti, adres çevirisini nanosaniyeler içinde tamamlar.</li>
                        </ul>
                    </li>
                    <li><strong>Bellek Hiyerarşisi:</strong>
                        <ul>
                            <li>CPU yazmaçları, önbellek, RAM ve disk arasında hiyerarşik bir yapı, erişim hızını
                                optimize
                                eder.</li>
                        </ul>
                    </li>
                    <li><strong>Önceden Getirme (Prefetching):</strong>
                        <ul>
                            <li>CPU’nun gelecekte ihtiyaç duyacağı veriler, önbelleğe önceden yüklenir.</li>
                            <li>Örnek: Döngüde kullanılan diziler için veri önceden getirilir.</li>
                        </ul>
                    </li>
                    <li><strong>Paralel Bellek Erişimi:</strong>
                        <ul>
                            <li>Çoklu bellek bankaları veya interleaved bellek, aynı anda birden fazla veri erişimine
                                izin
                                verir.</li>
                        </ul>
                    </li>
                </ol>
                <p><strong>Analitik Perspektif:</strong> Önbellek ve TLB, lokalite ilkesine (temporal ve spatial)
                    dayanır;
                    ancak önbellek isabetsizliği veya yanlış önceden getirme performansı düşürebilir.</p>
            </div>
        </div>

        <div class="question">
            <h2>Soru 3: Kabuğun (shell) temel işlevi nedir?</h2>
            <div class="toggle-btn" onclick="toggleAnswer('answer3')">Cevabı Göster/Gizle</div>
            <div id="answer3" class="answer">
                <p><strong>Cevap:</strong></p>
                <p>Kabuk (shell), kullanıcı ile işletim sistemi arasında bir arayüz sağlayarak komutların girilmesini,
                    yorumlanmasını ve yürütülmesini sağlar.</p>
                <ul>
                    <li><strong>Komut Yorumlama:</strong> Kullanıcının girdiği komutları (örneğin, <code>ls</code>,
                        <code>cd</code>) algılar ve işletim sistemine iletir.
                    </li>
                    <li><strong>Betik Desteği:</strong> Komut dosyalarını (shell script) çalıştırarak otomatik görevler
                        gerçekleştirir.</li>
                    <li><strong>Kullanıcı Arayüzü:</strong> Komut satırı (CLI) veya grafik arayüz (GUI) ile kullanıcı
                        etkileşimini sağlar.</li>
                    <li><strong>Örnek:</strong> Linux’ta <code>bash</code> kabuğu, <code>grep</code> komutunu
                        çalıştırarak
                        dosyalarda arama yapar.</li>
                </ul>
                <p><strong>Analitik Perspektif:</strong> Kabuk, kullanıcı dostu bir arayüz sunarak sistemin
                    karmaşıklığını
                    soyutlar; ancak yanlış komutlar sistem hatalarına yol açabilir.</p>
            </div>
        </div>

        <div class="question">
            <h2>Soru 4: Sistem çağrısının (system call) temel amacı nedir?</h2>
            <div class="toggle-btn" onclick="toggleAnswer('answer4')">Cevabı Göster/Gizle</div>
            <div id="answer4" class="answer">
                <p><strong>Cevap:</strong></p>
                <p>Sistem çağrısı, kullanıcı seviyesindeki bir programın işletim sisteminden hizmet talep etmesini
                    sağlayan
                    bir mekanizmadır.</p>
                <ul>
                    <li><strong>Amaç:</strong> Kullanıcı süreçlerinin, donanım kaynaklarına (örneğin, dosya okuma/yazma,
                        bellek tahsisi) güvenli ve kontrollü bir şekilde erişmesini sağlar.</li>
                    <li><strong>Nasıl Çalışır:</strong> Kullanıcı programı, bir sistem çağrısı (örneğin,
                        <code>open()</code>, <code>fork()</code>) yapar; CPU, kullanıcı modundan çekirdek moduna geçer
                        ve
                        isteği yerine getirir.
                    </li>
                    <li><strong>Örnek:</strong> <code>write()</code> sistem çağrısı, bir dosyaya veri yazmak için
                        kullanılır.</li>
                </ul>
                <p><strong>Analitik Perspektif:</strong> Sistem çağrıları, güvenlik ve soyutlama sağlar, ancak sık
                    çağrılar
                    bağlam değiştirme maliyeti nedeniyle performansı etkileyebilir.</p>
            </div>
        </div>

        <div class="question">
            <h2>Soru 5: İşletim sistemleri bağlamında soyutlama nedir?</h2>
            <div class="toggle-btn" onclick="toggleAnswer('answer5')">Cevabı Göster/Gizle</div>
            <div id="answer5" class="answer">
                <p><strong>Cevap:</strong></p>
                <p>İşletim sistemlerinde soyutlama, karmaşık donanım ve sistem kaynaklarını kullanıcılar ve uygulamalar
                    için
                    daha basit, anlaşılır ve yönetilebilir bir arayüz olarak sunma işlemidir.</p>
                <ul>
                    <li><strong>Amaç:</strong> Kullanıcıların ve programların, donanımın düşük seviyeli detaylarını
                        bilmeden
                        sistemle etkileşim kurmasını sağlamak.</li>
                    <li><strong>Örnekler:</strong>
                        <ul>
                            <li><strong>Sanal Bellek:</strong> Süreçlere fiziksel belleğin detaylarını gizleyerek
                                bağımsız
                                adres alanları sunar.</li>
                            <li><strong>Dosya Sistemi:</strong> Diskteki fiziksel sektörleri, dosya ve dizin gibi soyut
                                kavramlarla temsil eder.</li>
                            <li><strong>Süreç Soyutlaması:</strong> CPU ve kaynakları, süreçler için bağımsız bir
                                yürütme
                                ortamı gibi görünür.</li>
                        </ul>
                    </li>
                </ul>
                <p><strong>Analitik Perspektif:</strong> Soyutlama, kullanım kolaylığı ve taşınabilirlik sağlar, ancak
                    ek
                    soyutlama katmanları performans ek yükü getirebilir.</p>
            </div>
        </div>

        <div class="question">
            <h2>Soru 6: Eşzamanlılık nedir?</h2>
            <div class="toggle-btn" onclick="toggleAnswer('answer6')">Cevabı Göster/Gizle</div>
            <div id="answer6" class="answer">
                <p><strong>Cevap:</strong></p>
                <p>Eşzamanlılık (concurrency), birden fazla sürecin veya iş parçacığının aynı anda yürütülüyormuş gibi
                    görünmesini sağlayan işletim sistemi özelliğidir.</p>
                <ul>
                    <li><strong>Açıklama:</strong> Tek işlemcili sistemlerde, eşzamanlılık bağlam anahtarlama ile
                        sağlanır;
                        çok işlemcili sistemlerde ise gerçek paralel yürütme mümkündür.</li>
                    <li><strong>Örnek:</strong> Bir sistemde metin editörü ve web tarayıcı aynı anda çalışıyormuş gibi
                        görünür, ancak CPU zaman dilimleri arasında geçiş yapar.</li>
                    <li><strong>Mekanizmalar:</strong> Çizelgeleme (scheduling), bağlam anahtarlama (context switching),
                        senkronizasyon araçları (örneğin, semaforlar).</li>
                </ul>
                <p><strong>Analitik Perspektif:</strong> Eşzamanlılık, sistem kaynaklarının verimli kullanımını sağlar,
                    ancak yanlış senkronizasyon kilitlenme veya yarış koşullarına yol açabilir.</p>
            </div>
        </div>

        <div class="question">
            <h2>Soru 7: Linux'ta proc dizininin amacı nedir? Dizin içerisinde hangi bilgiler bulunur?</h2>
            <div class="toggle-btn" onclick="toggleAnswer('answer7')">Cevabı Göster/Gizle</div>
            <div id="answer7" class="answer">
                <p><strong>Cevap:</strong></p>
                <p>Linux’ta <code>/proc</code> dizini, çalışan sistemin ve süreçlerin durum bilgilerini sağlayan sanal
                    bir
                    dosya sistemidir.</p>
                <ul>
                    <li><strong>Amaç:</strong> İşletim sisteminin ve süreçlerin dinamik bilgilerini kullanıcıya ve
                        uygulamalara sunarak sistem izleme ve hata ayıklamayı kolaylaştırmak.</li>
                    <li><strong>İçerik:</strong>
                        <ul>
                            <li><strong>Süreç Bilgileri:</strong> Her süreç için bir alt dizin (örneğin,
                                <code>/proc/[pid]</code>) bulunur ve içerir: <code>stat</code> (süreç durumu),
                                <code>cmdline</code> (komut satırı argümanları), <code>mem</code> (bellek kullanımı).
                            </li>
                            <li><strong>Sistem Bilgileri:</strong> <code>/proc/cpuinfo</code> (işlemci detayları),
                                <code>/proc/meminfo</code> (bellek kullanımı), <code>/proc/uptime</code> (sistem çalışma
                                süresi).
                            </li>
                            <li><strong>Donanım Bilgileri:</strong> <code>/proc/devices</code>,
                                <code>/proc/interrupts</code>.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Örnek:</strong> <code>cat /proc/cpuinfo</code> komutu, CPU modelini ve hızını gösterir.
                    </li>
                </ul>
                <p><strong>Analitik Perspektif:</strong> <code>/proc</code>, sistem şeffaflığı sağlar, ancak yanlış
                    kullanım
                    (örneğin, hatalı okuma/yazma) sistem kararsızlığına neden olabilir.</p>
            </div>
        </div>

        <div class="question">
            <h2>Soru 8: Von Neumann mimarisinin en önemli özelliği nedir?</h2>
            <div class="toggle-btn" onclick="toggleAnswer('answer8')">Cevabı Göster/Gizle</div>
            <div id="answer8" class="answer">
                <p><strong>Cevap:</strong></p>
                <p>Von Neumann mimarisinin en önemli özelliği, program talimatlarının ve verilerin aynı bellek alanında
                    saklanmasıdır (stored-program concept).</p>
                <ul>
                    <li><strong>Açıklama:</strong> CPU, talimatları ve verileri aynı bellekten alır, bu da programların
                        esnek bir şekilde çalıştırılmasını sağlar.</li>
                    <li><strong>Örnek:</strong> Bir programın kodu ve kullandığı veriler RAM’de saklanır ve CPU
                        tarafından
                        sırayla işlenir.</li>
                    <li><strong>Avantajlar:</strong> Programların kolayca değiştirilmesi ve yeniden programlanabilirlik.
                    </li>
                    <li><strong>Dezavantajlar:</strong> Veri ve talimatların aynı veri yolunu paylaşması (Von Neumann
                        bottleneck).</li>
                </ul>
                <p><strong>Analitik Perspektif:</strong> Von Neumann mimarisi, modern bilgisayarların temelini
                    oluşturur,
                    ancak performans sınırlamaları nedeniyle Harvard mimarisi gibi alternatifler geliştirilmiştir.</p>
            </div>
        </div>

        <div class="question">
            <h2>Soru 9: Mikro çekirdek ve monolitik mimariyi karşılaştırınız.</h2>
            <div class="toggle-btn" onclick="toggleAnswer('answer9')">Cevabı Göster/Gizle</div>
            <div id="answer9" class="answer">
                <p><strong>Cevap:</strong></p>
                <p>Mikro çekirdek ve monolitik mimari, işletim sistemi tasarımında iki farklı yaklaşımdır. Aşağıda
                    karşılaştırmaları yapılmıştır:</p>
                <table border="1">
                    <tr>
                        <th>Özellik</th>
                        <th>Mikro Çekirdek</th>
                        <th>Monolitik Mimari</th>
                    </tr>
                    <tr>
                        <td><strong>Tanım</strong></td>
                        <td>Çekirdek, yalnızca temel işlevleri (örneğin, süreç yönetimi, iletişim) içerir; diğer
                            hizmetler
                            kullanıcı modunda çalışır.</td>
                        <td>Çekirdek, tüm işletim sistemi hizmetlerini (dosya sistemi, sürücüler, ağ) tek bir modülde
                            içerir.</td>
                    </tr>
                    <tr>
                        <td><strong>Örnek</strong></td>
                        <td>Minix, QNX</td>
                        <td>Linux, Windows (eski sürümler)</td>
                    </tr>
                    <tr>
                        <td><strong>Avantajlar</strong></td>
                        <td>
                            <ul>
                                <li>Modüler, bakım kolay.</li>
                                <li>Hatalar izole edilir, sistem çökmesi azalır.</li>
                                <li>Taşınabilirlik yüksek.</li>
                            </ul>
                        </td>
                        <td>
                            <ul>
                                <li>Hızlı, düşük sistem çağrısı maliyeti.</li>
                                <li>Basit tasarım, yüksek performans.</li>
                            </ul>
                        </td>
                    </tr>
                    <tr>
                        <td><strong>Dezavantajlar</strong></td>
                        <td>
                            <ul>
                                <li>Sistem çağrıları yavaş (modlar arası geçiş).</li>
                                <li>Karmaşık iletişim mekanizmaları.</li>
                            </ul>
                        </td>
                        <td>
                            <ul>
                                <li>Hatalar tüm sistemi etkiler.</li>
                                <li>Bakım ve güncelleme zor.</li>
                            </ul>
                        </td>
                    </tr>
                    <tr>
                        <td><strong>Kullanım</strong></td>
                        <td>Gömülü sistemler, yüksek güvenilirlik gereken yerler.</td>
                        <td>Genel amaçlı sistemler, yüksek performans gereken yerler.</td>
                    </tr>
                </table>
                <p><strong>Analitik Perspektif:</strong> Mikro çekirdek, modülerlik ve güvenilirlik için uygundur;
                    monolitik
                    mimari ise performans odaklıdır. Seçim, sistem ihtiyaçlarına bağlıdır.</p>
            </div>
        </div>

        <div class="question">
            <h2>Soru 10: Kesme tabanlı (preemptive) ile kesme tabanlı olmayan (non-preemptive) çizelgeleme algoritmaları
                arasındaki fark nedir?</h2>
            <div class="toggle-btn" onclick="toggleAnswer('answer10')">Cevabı Göster/Gizle</div>
            <div id="answer10" class="answer">
                <p><strong>Cevap:</strong></p>
                <p>Kesme tabanlı (preemptive) ve kesme tabanlı olmayan (non-preemptive) çizelgeleme algoritmaları,
                    süreçlerin CPU’ya erişimini düzenleme yöntemlerinde farklılık gösterir:</p>
                <table border="1">
                    <tr>
                        <th>Özellik</th>
                        <th>Kesme Tabanlı (Preemptive)</th>
                        <th>Kesme Tabanlı Olmayan (Non-Preemptive)</th>
                    </tr>
                    <tr>
                        <td><strong>Tanım</strong></td>
                        <td>İşletim sistemi, çalışan süreci zaman dilimi dolduğunda veya daha yüksek öncelikli bir süreç
                            hazır olduğunda keser.</td>
                        <td>Süreç, CPU’yu gönüllü olarak bırakana veya tamamlanana kadar çalışır.</td>
                    </tr>
                    <tr>
                        <td><strong>Örnek Algoritmalar</strong></td>
                        <td>Round Robin, Öncelik Tabanlı</td>
                        <td>İlk Gelen İlk Hizmet (FCFS), En Kısa İş Önce (SJF)</td>
                    </tr>
                    <tr>
                        <td><strong>Avantajlar</strong></td>
                        <td>
                            <ul>
                                <li>Yüksek öncelikli süreçlere hızlı yanıt.</li>
                                <li>Zaman paylaşımı sağlar, adaletli.</li>
                            </ul>
                        </td>
                        <td>
                            <ul>
                                <li>Basit, düşük bağlam değiştirme maliyeti.</li>
                                <li>Uzun süren süreçler için uygun.</li>
                            </ul>
                        </td>
                    </tr>
                    <tr>
                        <td><strong>Dezavantajlar</strong></td>
                        <td>
                            <ul>
                                <li>Yüksek bağlam değiştirme maliyeti.</li>
                                <li>Karmaşık yönetim.</li>
                            </ul>
                        </td>
                        <td>
                            <ul>
                                <li>Uzun süreçler diğerlerini geciktirir.</li>
                                <li>Düşük yanıt süresi.</li>
                            </ul>
                        </td>
                    </tr>
                    <tr>
                        <td><strong>Örnek</strong></td>
                        <td>Round Robin’de süreç 10 ms çalışır, kesilir.</td>
                        <td>FCFS’de süreç tamamlanana kadar çalışır.</td>
                    </tr>
                </table>
                <p><strong>Analitik Perspektif:</strong> Kesme tabanlı algoritmalar, dinamik ve adaletli sistemler için
                    uygundur; kesme tabanlı olmayanlar ise basitlik ve düşük ek yük gerektiren sistemlerde tercih
                    edilir.
                </p>
            </div>
        </div>

        <div class="question">
            <h2>Soru 11: "Round Robin" zamanlama algoritmasında, zaman dilimi (time quantum) çok küçük seçilirse ne
                olur?
            </h2>
            <div class="toggle-btn" onclick="toggleAnswer('answer11')">Cevabı Göster/Gizle</div>
            <div id="answer11" class="answer">
                <p><strong>Cevap:</strong></p>
                <p><strong>Doğru cevap: b) Bağlam değiştirme (context switch) masrafı artar ve sistem verimliliği
                        azalır.</strong></p>
                <p><strong>Açıklama:</strong></p>
                <ul>
                    <li>Round Robin algoritmasında, her süreç bir zaman dilimi (quantum) süresince çalışır ve ardından
                        CPU
                        başka bir sürece geçer.</li>
                    <li>Zaman dilimi çok küçük seçilirse:
                        <ul>
                            <li>Sık bağlam değiştirmeler (context switch) olur, bu da CPU zamanını boşa harcar.</li>
                            <li>Bağlam değiştirme, süreç durumlarının kaydedilip yüklenmesini içerir ve bu işlem zaman
                                alır
                                (örneğin, mikro/nanosaniye).</li>
                            <li>Sonuç olarak, sistem verimliliği azalır, çünkü CPU, süreç yürütmek yerine bağlam
                                değiştirmeye daha fazla zaman harcar.</li>
                        </ul>
                    </li>
                    <li><strong>Diğer Şıkların Değerlendirmesi:</strong>
                        <ul>
                            <li><strong>a) Sistem verimliliği artar ve süreçler daha hızlı tamamlanır:</strong> Yanlış,
                                çünkü sık bağlam değiştirme performansı düşürür.</li>
                            <li><strong>c) Süreçler arasında adalet sağlanamaz:</strong> Yanlış, küçük zaman dilimi
                                adaleti
                                artırır, ancak performansı düşürür.</li>
                            <li><strong>d) Kilitlenme olasılığı artar:</strong> Yanlış, zaman dilimi boyutu kilitlenmeyi
                                doğrudan etkilemez.</li>
                        </ul>
                    </li>
                </ul>
                <p><strong>Analitik Perspektif:</strong> Zaman dilimi seçimi, adalet ve performans arasında bir
                    dengedir;
                    çok küçük quantum, bağlam değiştirme ek yükünü artırırken, çok büyük quantum, kesme tabanlı olmayan
                    çizelgelemeye yaklaşır.</p>
            </div>
        </div>

        <div class="question">
            <h2>Soru 12: Aşağıdaki senkronizasyon mekanizmalarından hangisi, meşgul bekleme (busy waiting) yöntemine
                dayanır?</h2>
            <div class="toggle-btn" onclick="toggleAnswer('answer12')">Cevabı Göster/Gizle</div>
            <div id="answer12" class="answer">
                <p><strong>Cevap:</strong></p>
                <p><strong>Doğru cevap: c) Döngüsel Kilit (Spinlock)</strong></p>
                <p><strong>Açıklama:</strong></p>
                <ul>
                    <li><strong>Meşgul Bekleme (Busy Waiting):</strong> Bir süreç veya iş parçacığı, bir kaynağın
                        serbest
                        olmasını beklerken CPU’yu sürekli kontrol ederek meşgul tutar.</li>
                    <li><strong>Spinlock:</strong> Süreç, kilidin serbest olmasını beklerken döngü içinde kontrol yapar
                        (örneğin, <code>while(lock)</code>), bu da meşgul beklemeye örnektir.</li>
                    <li><strong>Diğer Şıkların Değerlendirmesi:</strong>
                        <ul>
                            <li><strong>a) Semafor:</strong> Meşgul bekleme yerine, süreçleri engelleyerek (blocked
                                state)
                                bekletir.</li>
                            <li><strong>b) Gözleyici (Monitor):</strong> İş parçacıklarını kuyruğa alarak bekletir,
                                meşgul
                                bekleme kullanmaz.</li>
                            <li><strong>d) Koşul Değişkeni:</strong> Süreçleri askıya alarak bekletir, CPU’yu meşgul
                                etmez.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Örnek:</strong> Çok çekirdekli bir sistemde, bir iş parçacığı spinlock ile kısa süreli
                        kilitler için bekler.</li>
                </ul>
                <p><strong>Analitik Perspektif:</strong> Spinlock, kısa süreli kilitler için uygundur, ancak uzun
                    beklemelerde CPU israfına yol açar; diğer mekanizmalar ise enerji verimliliği sağlar.</p>
            </div>
        </div>

        <div class="question">
            <h2>Soru 13: Bir işletim sisteminde, iki süreç arasında süreçler arası iletişim (inter-process
                communication)
                için paylaşılan bellek (shared memory) kullanıldığında, hangi durum senkronizasyon gerektirmez?</h2>
            <div class="toggle-btn" onclick="toggleAnswer('answer13')">Cevabı Göster/Gizle</div>
            <div id="answer13" class="answer">
                <p><strong>Cevap:</strong></p>
                <p><strong>Doğru cevap: c) Her iki süreç de okuma yapıyorsa</strong></p>
                <p><strong>Açıklama:</strong></p>
                <ul>
                    <li>Paylaşılan bellekte senkronizasyon, veri tutarlılığını sağlamak için gereklidir, özellikle yazma
                        işlemleri söz konusu olduğunda.</li>
                    <li><strong>Her iki süreç de okuma yapıyorsa:</strong>
                        <ul>
                            <li>Veri değişmez, bu nedenle yarış koşulu (race condition) veya veri bozulması olmaz.</li>
                            <li>Senkronizasyon (örneğin, kilitler) gerekmez.</li>
                        </ul>
                    </li>
                    <li><strong>Diğer Şıkların Değerlendirmesi:</strong>
                        <ul>
                            <li><strong>a) Bir süreç yazarken diğer süreç okuma yapıyorsa:</strong> Okuma, eski veya
                                hatalı
                                veri alabilir, senkronizasyon gerekir.</li>
                            <li><strong>b) Her iki süreç de aynı anda yazma yapıyorsa:</strong> Yarış koşulu oluşur,
                                veri
                                bozulur, senkronizasyon şarttır.</li>
                            <li><strong>d) Bir süreç belleği temizlerken diğer süreç erişmeye çalışıyorsa:</strong> Veri
                                kaybı veya hata oluşur, senkronizasyon gerekir.</li>
                        </ul>
                    </li>
                    <li><strong>Örnek:</strong> İki süreç, paylaşılan bir veri tabanını sadece okuyor; kilit
                        kullanılmaz.
                    </li>
                </ul>
                <p><strong>Analitik Perspektif:</strong> Salt okuma senaryoları, senkronizasyon ek yükünü ortadan
                    kaldırır,
                    ancak yazma içeren durumlarda kilitler veya semaforlar kritik öneme sahiptir.</p>
            </div>
        </div>

        <div class="question">
            <h2>Soru 14: Öncelik tersine dönmesi (Priority Inversion) sorunu nedir ve hangi senaryoda ortaya çıkar?</h2>
            <div class="toggle-btn" onclick="toggleAnswer('answer14')">Cevabı Göster/Gizle</div>
            <div id="answer14" class="answer">
                <p><strong>Cevap:</strong></p>
                <p><strong>Doğru cevap: a) Düşük öncelikli bir iş parçacığının, yüksek öncelikli bir iş parçacığını
                        engellemesi; paylaşılan bir kaynak kilitlendiğinde</strong></p>
                <p><strong>Açıklama:</strong></p>
                <ul>
                    <li><strong>Öncelik Tersine Dönmesi:</strong> Düşük öncelikli bir iş parçacığı, paylaşılan bir
                        kaynağı
                        kilitlediğinde, yüksek öncelikli bir iş parçacığını bekletir, bu da öncelik sıralamasını tersine
                        çevirir.</li>
                    <li><strong>Senaryo:</strong>
                        <ul>
                            <li>Düşük öncelikli iş parçacığı (T3) bir kaynağı kilitler.</li>
                            <li>Yüksek öncelikli iş parçacığı (T1) bu kaynağı talep eder ve bekler.</li>
                            <li>Orta öncelikli bir iş parçacığı (T2), T3’ü keser, böylece T1’in beklemesi uzar.</li>
                        </ul>
                    </li>
                    <li><strong>Örnek:</strong> Gerçek zamanlı bir sistemde, düşük öncelikli bir görev veritabanı
                        kilidini
                        tutar, yüksek öncelikli bir görev bekler.</li>
                    <li><strong>Çözüm:</strong> Öncelik mirası (priority inheritance) veya öncelik tavanı (priority
                        ceiling)
                        protokolleri kullanılır.</li>
                    <li><strong>Diğer Şıkların Değerlendirmesi:</strong>
                        <ul>
                            <li><strong>b)</strong> CPU ele geçirme, öncelik tersine dönmesi değil, kötü çizelgelemedir.
                            </li>
                            <li><strong>c)</strong> Sonsuz döngü, öncelik tersine dönmesiyle ilgili değildir.</li>
                            <li><strong>d)</strong> Dosya yazma çakışması, yarış koşuludur, öncelik tersine dönmesi
                                değildir.</li>
                        </ul>
                    </li>
                </ul>
                <p><strong>Analitik Perspektif:</strong> Öncelik tersine dönmesi, gerçek zamanlı sistemlerde ciddi
                    gecikmelere yol açar; uygun protokoller bu sorunu azaltır.</p>
            </div>
        </div>

        <div class="question">
            <h2>Soru 15: Bir süreç diskten okuma yapmak istediğinde geçiş yapacağı durum hangisidir?</h2>
            <div class="toggle-btn" onclick="toggleAnswer('answer15')">Cevabı Göster/Gizle</div>
            <div id="answer15" class="answer">
                <p><strong>Cevap:</strong></p>
                <p><strong>Doğru cevap: b) Engellenmiş (blocked)</strong></p>
                <p><strong>Açıklama:</strong></p>
                <ul>
                    <li>Bir süreç, diskten okuma gibi giriş/çıkış işlemi yapmak istediğinde, bu işlem tamamlanana kadar
                        CPU’yu kullanamaz ve <strong>engellenmiş</strong> duruma geçer.</li>
                    <li><strong>Süreç Durumları:</strong>
                        <ul>
                            <li><strong>Hazır (ready):</strong> CPU’yu bekleyen süreçler.</li>
                            <li><strong>Çalışıyor (running):</strong> CPU’yu kullanan süreç.</li>
                            <li><strong>Engellenmiş (blocked):</strong> G/Ç veya başka bir olay bekleyen süreç.</li>
                            <li><strong>Sonlandırıldı (terminated):</strong> Süreç tamamlanmış veya iptal edilmiştir.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Örnek:</strong> Bir süreç <code>read()</code> sistem çağrısı yapar, disk I/O’su bitene
                        kadar
                        engellenir.</li>
                    <li><strong>Diğer Şıkların Değerlendirmesi:</strong>
                        <ul>
                            <li><strong>a) Hazır:</strong> Süreç CPU’yu bekler, disk I/O’su için uygun değil.</li>
                            <li><strong>c) Çalışıyor:</strong> Süreç CPU’yu kullanıyor, I/O beklemez.</li>
                            <li><strong>d) Sonlandırıldı:</strong> Süreç bitmiş, I/O yapamaz.</li>
                        </ul>
                    </li>
                </ul>
                <p><strong>Analitik Perspektif:</strong> Engellenmiş durum, CPU’nun verimli kullanımını sağlar, çünkü
                    I/O
                    bekleyen süreçler CPU’yu serbest bırakır.</p>
            </div>
        </div>

        <div class="question">
            <h2>Soru 16: İşletim sistemlerinde süreç denetim bloğunun (PCB) temel amacı nedir?</h2>
            <div class="toggle-btn" onclick="toggleAnswer('answer16')">Cevabı Göster/Gizle</div>
            <div id="answer16" class="answer">
                <p><strong>Cevap:</strong></p>
                <p><strong>Doğru cevap: c) Bir sürecin durumu ve özellikleri hakkındaki bilgileri korumak</strong></p>
                <p><strong>Açıklama:</strong></p>
                <ul>
                    <li><strong>Süreç Denetim Bloğu (PCB):</strong> Her süreç için işletim sisteminin tuttuğu bir veri
                        yapısıdır ve sürecin durumunu, özelliklerini ve kaynaklarını içerir.</li>
                    <li><strong>İçerik:</strong>
                        <ul>
                            <li>Süreç kimliği (PID), durum (çalışıyor, hazır, engellenmiş).</li>
                            <li>Program sayacı (PC), yazmaçlar, yığın işaretçisi.</li>
                            <li>Bellek bilgileri, açık dosyalar, öncelik.</li>
                        </ul>
                    </li>
                    <li><strong>Amaç:</strong> Bağlam anahtarlama sırasında sürecin durumunu kaydetmek ve geri yüklemek,
                        böylece süreç yönetimini mümkün kılmak.</li>
                    <li><strong>Örnek:</strong> Bir süreç kesildiğinde, PCB’si güncellenir ve başka bir süreç
                        çalıştırılır.
                    </li>
                    <li><strong>Diğer Şıkların Değerlendirmesi:</strong>
                        <ul>
                            <li><strong>a) Yürütülebilir kodu saklamak:</strong> PCB, kodu değil, kodun konumunu işaret
                                eder.</li>
                            <li><strong>b) Kaynak tahsisini yönetmek:</strong> PCB bilgi saklar, yönetimi işletim
                                sistemi
                                yapar.</li>
                            <li><strong>d) Süreç dışı iletişim:</strong> PCB iletişim için değil, süreç bilgisi için
                                kullanılır.</li>
                        </ul>
                    </li>
                </ul>
                <p><strong>Analitik Perspektif:</strong> PCB, süreç yönetiminin temel taşıdır; eksik veya hatalı PCB,
                    bağlam
                    anahtarlamasını ve sistem kararlılığını bozar.</p>
            </div>
        </div>
    </div>

</body>

</html>