<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Testing & Debugging in OS</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      padding: 40px;
      max-width: 850px;
      margin: auto;
      background-color: #ffffff;
      color: #333;
    }

    h1,
    h2,
    h3 {
      color: #2c3e50;
    }

    h1 {
      border-bottom: 2px solid #2c3e50;
      padding-bottom: 10px;
    }

    code {
      background-color: #f4f4f4;
      padding: 2px 6px;
      border-radius: 4px;
      font-family: Consolas, monospace;
    }

    blockquote {
      background: #f9f9f9;
      border-left: 5px solid #ccc;
      padding: 12px 20px;
      margin: 20px 0;
      font-style: italic;
    }

    ul {
      margin-top: 10px;
    }
  </style>
</head>

<body>

  <h1>Testing & Debugging in Operating Systems</h1>

  <p>Testing makes sure the OS works as expected.</p>
  <p>Debugging helps us find and fix problems.</p>

  <h2>Why Is Testing Important?</h2>
  <p>Imagine building a car without testing it.</p>
  <p>Would you feel safe driving it? Probably not.</p>

  <p>It‚Äôs the same with an OS. It must be tested before people use it.</p>
  <p>Testing helps find errors early.</p>
  <p>This saves time and prevents system crashes.</p>

  <blockquote>
    üõ†Ô∏è <strong>Example:</strong> You write code for memory management. If there is a bug, the system might crash or
    leak memory. Testing can catch this before release.
  </blockquote>

  <h2>Types of Testing in OS</h2>

  <h3>1. Unit Testing</h3>
  <p>Test small parts of the OS code one by one.</p>
  <p>Example: Test just the file open function, not the whole file system.</p>

  <h3>2. Integration Testing</h3>
  <p>Test how different parts work together.</p>
  <p>Example: Check how the file system and memory manager interact.</p>

  <h3>3. System Testing</h3>
  <p>Test the full OS like a real user would.</p>
  <p>Check file reading, process creation, memory allocation, etc.</p>

  <h3>4. Regression Testing</h3>
  <p>Make sure that fixing one bug didn‚Äôt break something else.</p>
  <p>This is very useful when code changes often.</p>

  <h3>5. Stress Testing</h3>
  <p>Run the OS under heavy load.</p>
  <p>Example: Start many processes, open many files, and see if the OS can handle it.</p>

  <blockquote>
    üß™ <strong>Tip:</strong> Testing must cover both normal and strange situations.
  </blockquote>

  <h2>Debugging Basics</h2>
  <p>Debugging means finding and fixing errors (bugs).</p>
  <p>Bugs can be tricky. Some crash the system. Others just cause strange behavior.</p>

  <h3>Daily Life Example:</h3>
  <blockquote>
    üî¶ You turn on a lamp. Nothing happens. You check the bulb, the switch, and the plug. This is debugging!
  </blockquote>

  <h2>Debugging Tools</h2>

  <ul>
    <li><strong>printk:</strong> Like <code>printf</code> but for the kernel. Shows messages on screen or in logs.</li>
    <li><strong>gdb:</strong> The GNU Debugger. Helps find bugs in OS code.</li>
    <li><strong>QEMU/Bochs:</strong> Virtual machines used to test OS code safely.</li>
    <li><strong>Kernel logs:</strong> The OS writes logs during running. Check them to understand problems.</li>
  </ul>

  <blockquote>
    üß∞ <strong>Example:</strong> You write a new system call. It doesn‚Äôt work. Use <code>printk</code> to check if your
    code runs.
  </blockquote>

  <h2>Debugging Steps</h2>
  <ol>
    <li>Reproduce the bug (try to make the error happen again).</li>
    <li>Look at logs or outputs (what does the system say?).</li>
    <li>Use tools like gdb or printk to check where the problem is.</li>
    <li>Fix the code (once you find the bug).</li>
    <li>Test again (to make sure it works now).</li>
  </ol>

  <h2>Common Bugs in OS Development</h2>
  <ul>
    <li>Memory leaks ‚Äì you forget to free memory.</li>
    <li>Null pointer dereference ‚Äì trying to use empty memory.</li>
    <li>Race conditions ‚Äì two parts of code access shared data at the same time.</li>
    <li>Deadlocks ‚Äì two processes wait forever for each other.</li>
    <li>Off-by-one errors ‚Äì using loops or arrays incorrectly.</li>
  </ul>

  <h2>Best Practices</h2>
  <ul>
    <li>Test each part as you build it.</li>
    <li>Write clear and small functions.</li>
    <li>Use comments and logs.</li>
    <li>Keep backups of working versions.</li>
    <li>Review code with others (code review).</li>
  </ul>

  <h2>Summary</h2>
  <ul>
    <li>Testing makes sure your OS works correctly.</li>
    <li>Debugging helps fix problems in code.</li>
    <li>Use tools like <code>gdb</code> and <code>printk</code>.</li>
    <li>Always test after making changes.</li>
  </ul>

  <h2>üìö Key Terms</h2>
  <ul>
    <li><strong>Testing:</strong> Checking if software works as expected.</li>
    <li><strong>Debugging:</strong> Finding and fixing problems in code.</li>
    <li><strong>printk:</strong> Function to log messages in the Linux kernel.</li>
    <li><strong>gdb:</strong> A debugger for C programs.</li>
    <li><strong>Regression Testing:</strong> Testing to make sure new changes didn‚Äôt break old code.</li>
  </ul>

  <h2>üß† Practice Time!</h2>
  <p>Try writing a simple kernel module that logs "Hello, OS!" using <code>printk</code>.</p>
  <p>Use <code>dmesg</code> to read the log messages.</p>

  <p><strong>Great job! Now you know how to test and debug your OS projects. üß©</strong></p>

</body>

</html>