<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Learn and interact with a Binary Search Tree (BST) Simulator. Insert, search, delete, and visualize binary search tree operations in real-time. Perfect for computer science students and enthusiasts.">
  <meta name="keywords" content="Binary Search Tree, BST Simulator, Data Structures, Interactive Tree Visualization, Computer Science Learning Tool">
  <meta name="author" content="Your Name">
  <title>Interactive Binary Search Tree Simulator | Learn Data Structures</title>
  <style>
    /* Stil kodları aynen korunmuştur */
    body {
      font-family: Arial, sans-serif;
      background-color: #f0f0f0;
      color: #333;
      text-align: center;
      margin: 0 auto;
      padding: 2vw;
      max-width: 800px;
      box-sizing: border-box;
    }
    h1 {
      margin: 0;
      padding: 0 0 20px 0;
      text-align: center;
    }
    .controls {
      display: flex;
      flex-wrap: nowrap;
      justify-content: space-between;
      gap: 1vw;
      box-sizing: border-box;
      padding: 1vw;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    input, button {
      width: calc((100% - (5 * 1vw)) / 5);
      padding: 1vw;
      margin: 0;
      border: 2px solid #ccc;
      border-radius: 8px;
      font-size: 1rem;
      box-sizing: border-box;
    }
    button {
      background-color: #4CAF50;
      color: white;
      cursor: pointer;
      border: none;
    }
    button:hover {
      background: #45a049;
      transform: scale(1.05);
    }
    button:active {
      transform: scale(0.98);
    }
    #tree-container {
      width: 100%;
      height: 500px;
      background: white;
      border-radius: 8px;
      overflow: hidden;
      position: relative;
      margin-top: 20px;
    }

    .node {
  width: 40px;
  height: 40px;
  background: #ddd; /* Gray background for the node */
  border-radius: 50%;
  position: absolute;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;	
  color: #000; /* Black text color */
  transition: all 0.5s ease;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); /* Lighter shadow for better readability */
  border: 2px solid #fff; /* White border to separate node from the edges */
  z-index: 1;
}

.edge {
  position: absolute;
  background: #000;
  height: 2px;
  transform-origin: left center;
  z-index: 0;
}


    .node.highlight {
      background: #ff5722;
      transform: scale(1.2);
      box-shadow: 0 0 10px rgba(255, 87, 34, 0.6);
    }


    #message {
      margin-top: 20px;
      padding: 12px;
      border-radius: 5px;
      font-size: 1rem;
      text-align: center;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }

    @media (max-width: 768px) {
      input, button {
        font-size: 3vw;
        padding: 2vw;
        width: calc((100% - (5 * 2vw)) / 5);
      }
  </style>
</head>
<body>
  <header>
    <h1>Interactive Binary Search Tree Simulator</h1>
    <p>Explore binary search trees with this interactive simulator. Perfect for learning data structures.</p>
  </header>
  <main>
    <section class="container">
      <div class="controls">
        <input type="number" id="value-input" placeholder="Enter a number" aria-label="Value Input">
        <button onclick="insertValue()">Insert</button>
        <button onclick="searchValue()">Search</button>
        <button onclick="deleteValue()">Delete</button>
        <button onclick="resetTree()">Reset Tree</button>
      </div>
      <div id="tree-container" aria-label="Tree Visualization Area"></div>
      <div id="message" aria-live="polite"></div>
    </section>
  </main>
  <footer>
    <p>&copy; 2024 Your Name. All rights reserved.</p>
  </footer>
  <script>
    class Node {
      constructor(value) {
        this.value = value;
        this.left = null;
        this.right = null;
        this.x = 0;
        this.y = 0;
        this.level = 0;
      }
    }

    class BinarySearchTree {
      constructor() {
        this.root = null;
      }

      insert(value) {
        const newNode = new Node(value);
        
        if (!this.root) {
          this.root = newNode;
          return;
        }

        let current = this.root;
        while (true) {
          // If value already exists, do nothing
          if (value === current.value) {
            return;  // End function to avoid duplicate values
          }

          if (value < current.value) {
            if (!current.left) {
              current.left = newNode;
              break;
            }
            current = current.left;
          } else {
            if (!current.right) {
              current.right = newNode;
              break;
            }
            current = current.right;
          }
        }
      }

      search(value) {
        let current = this.root;
        const path = [];
        
        while (current) {
          path.push(current);
          if (value === current.value) {
            return path;
          }
          if (value < current.value) {
            current = current.left;
          } else {
            current = current.right;
          }
        }
        return null;
      }

      findMin(node) {
        let current = node;
        while (current.left) {
          current = current.left;
        }
        return current;
      }

      delete(value) {
        const deleteNode = (node, value) => {
          if (!node) return null;

          if (value < node.value) {
            node.left = deleteNode(node.left, value);
            return node;
          } else if (value > node.value) {
            node.right = deleteNode(node.right, value);
            return node;
          } else {
            // Case 1: No children
            if (!node.left && !node.right) {
              return null;
            }
            // Case 2: One child
            if (!node.left) return node.right;
            if (!node.right) return node.left;
            
            // Case 3: Two children
            const successor = this.findMin(node.right);
            node.value = successor.value;
            node.right = deleteNode(node.right, successor.value);
            return node;
          }
        };

        this.root = deleteNode(this.root, value);
      }

      calculatePositions() {
        const container = document.getElementById('tree-container');
        const width = container.offsetWidth;
        const height = container.offsetHeight;
        const levelHeight = 80;

        const assignPositions = (node, level, left, right) => {
          if (!node) return;
          
          node.level = level;
          node.x = (left + right) / 2;
          node.y = level * levelHeight + 40;

          const offset = (right - left) / 2;
          assignPositions(node.left, level + 1, left, node.x);
          assignPositions(node.right, level + 1, node.x, right);
        };

        assignPositions(this.root, 0, 0, width);
      }
    }

    let bst = new BinarySearchTree();

    // Insert 10 random elements at the beginning
    for (let i = 0; i < 10; i++) {
      const randomValue = Math.floor(Math.random() * 100);
      bst.insert(randomValue);
    }

    function createNodeElement(node) {
      const nodeEl = document.createElement('div');
      nodeEl.className = 'node';
      nodeEl.textContent = node.value;
      nodeEl.style.left = `${node.x - 20}px`;
      nodeEl.style.top = `${node.y - 20}px`;
      nodeEl.setAttribute('data-value', node.value); // Add data-value attribute for search
      return nodeEl;
    }

    function createEdge(fromNode, toNode) {
      const edge = document.createElement('div');
      edge.className = 'edge';
      
      const deltaX = toNode.x - fromNode.x;
      const deltaY = toNode.y - fromNode.y;
      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);  // Calculate distance
      const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;  // Calculate angle

      edge.style.width = `${distance}px`;  // Set edge width
      edge.style.left = `${fromNode.x}px`;  // Set start position
      edge.style.top = `${fromNode.y}px`;  // Set start position
      edge.style.transform = `rotate(${angle}deg)`;  // Rotate edge to correct angle
  
      return edge;
    }

    function renderTree() {
      const container = document.getElementById('tree-container');
      container.innerHTML = '';
      
      if (!bst.root) return;

      bst.calculatePositions();

      const nodes = [];
      const edges = [];

      const traverse = (node) => {
        if (!node) return;
        
        const nodeEl = createNodeElement(node);
        nodes.push(nodeEl);

        if (node.left) {
          const leftNodeEl = createNodeElement(node.left);
          const edge = createEdge(node, node.left);
          edges.push(edge);
        }
        if (node.right) {
          const rightNodeEl = createNodeElement(node.right);
          const edge = createEdge(node, node.right);
          edges.push(edge);
        }

        nodeEl.style.transition = 'transform 0.5s ease, background-color 0.5s ease'; // Add transition for animation
        container.appendChild(nodeEl);
        
        traverse(node.left);
        traverse(node.right);
      };

      traverse(bst.root);

      // Append edges
      edges.forEach(edge => container.appendChild(edge));
    }

    function insertValue() {
      const value = parseInt(document.getElementById('value-input').value);
      if (!isNaN(value)) {
        const existingPath = bst.search(value);
        if (existingPath) {
          showMessage(`Value ${value} already exists!`);
        } else {
          bst.insert(value);
          renderTree();
          showMessage(`Inserted ${value}`);
        }
      } else {
        showMessage('Please enter a valid number');
      }
    }

    function searchValue() {
      const value = parseInt(document.getElementById('value-input').value);
      if (!isNaN(value)) {
        const path = bst.search(value);
        renderTree();
        if (path) {
          showMessage(`Found ${value}`);
          path.forEach((node, index) => {
            setTimeout(() => {
              const nodeEl = document.querySelector(`[data-value="${node.value}"]`);  // Select node by data-value attribute
              nodeEl.classList.add('highlight');
            }, 500 * index);
          });
        } else {
          showMessage(`Value ${value} not found`);
        }
      } else {
        showMessage('Please enter a valid number');
      }
    }

    function deleteValue() {
  const value = parseInt(document.getElementById('value-input').value);
  if (!isNaN(value)) {
    // Check if the value exists in the tree before deleting
    const path = bst.search(value);
    if (path) {
      bst.delete(value);
      renderTree();
      showMessage(`Deleted ${value}`);
    } else {
      showMessage(`Value ${value} not found for deletion`);
    }
  } else {
    showMessage('Please enter a valid number');
  }
}

    function resetTree() {
      bst = new BinarySearchTree();
      renderTree();
      showMessage('Tree reset');
    }

    function showMessage(msg) {
      const messageEl = document.getElementById('message');
      messageEl.textContent = msg;
      setTimeout(() => messageEl.textContent = '', 2000);
    }

    renderTree();
  </script>
</body>
</html>
