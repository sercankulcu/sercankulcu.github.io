<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Othello</title>
<style>
  body {
    background-color: #1e1e1e;
    color: white;
    text-align: center;
    font-family: Arial, sans-serif;
  }
  h1 { margin-top: 20px; }
  #board {
    display: grid;
    grid-template-columns: repeat(8, 60px);
    grid-template-rows: repeat(8, 60px);
    margin: 20px auto;
    width: 480px;
    border: 4px solid #333;
  }
  .cell {
    width: 60px; height: 60px;
    background-color: green;
    border: 1px solid #003300;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    position: relative;
    font-weight: bold;
  }
  .black, .white {
    border-radius: 50%;
    width: 48px; height: 48px;
  }
  .black { background-color: black; }
  .white { background-color: white; }
  .highlight-move {
    border-radius: 50%;
    width: 48px; height: 48px;
    background: radial-gradient(circle, rgba(255,255,0,0.8) 0%, rgba(255,215,0,0.6) 70%, transparent 100%);
    border: 3px solid #FFD700;
    box-shadow: 0 0 10px rgba(255,215,0,0.8);
    z-index: 5;
  }
  .score {
    position: absolute;
    color: #FFD700;
    font-size: 16px !important;
    font-weight: bold;
    text-shadow: 1px 1px 2px black;
    z-index: 15;
    pointer-events: all;
    user-select: none;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.7);
    border-radius: 50%;
    width: 36px;
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .selected {
    background-color: rgba(255, 215, 0, 0.4) !important;
    border: 4px solid #FFD700 !important;
    box-shadow: 0 0 15px rgba(255,215,0,1) !important;
  }
  .selected .highlight-move {
    background: radial-gradient(circle, rgba(255,215,0,1) 0%, rgba(255,165,0,0.8) 70%, transparent 100%);
    border: 4px solid #FF8C00;
    box-shadow: 0 0 15px rgba(255,140,0,1);
  }
  #status {
    margin-top: 15px;
    font-size: 18px;
  }
  button, select {
    margin-top: 10px;
    padding: 8px 16px;
    border: none;
    background-color: #4caf50;
    color: white;
    border-radius: 6px;
    cursor: pointer;
  }
  button:hover, select:hover { background-color: #45a049; }
  select { margin-left: 10px; }
</style>
</head>
<body>
<h1>Othello</h1>
<div>
  <label for="aiMode">AI Mode:</label>
  <select id="aiMode">
    <option value="simple">ðŸ§© Simple (Heuristic)</option>
    <option value="smart">ðŸ§  Smart (Minimax + Alpha-Beta)</option>
  </select>
</div>
<div id="board"></div>
<div id="status"></div>
<button onclick="resetGame()">Restart Game</button>

<script>
const SIZE = 8;
let board = [];
let currentPlayer = 'black';
let aiMode = 'simple';
const directions = [
  [1,0],[-1,0],[0,1],[0,-1],
  [1,1],[1,-1],[-1,1],[-1,-1]
];
const DEPTH = 5;

function createBoard() {
  const boardDiv = document.getElementById("board");
  boardDiv.innerHTML = '';
  board = Array.from({ length: SIZE }, () => Array(SIZE).fill(null));

  board[3][3] = 'white';
  board[3][4] = 'black';
  board[4][3] = 'black';
  board[4][4] = 'white';

  for (let r = 0; r < SIZE; r++) {
    for (let c = 0; c < SIZE; c++) {
      const cell = document.createElement("div");
      cell.className = "cell";
      cell.dataset.row = r;
      cell.dataset.col = c;
      cell.addEventListener("click", handleMove);
      boardDiv.appendChild(cell);
    }
  }
  updateBoard();
  updateHighlights();
  updateStatus();
}

function updateBoard() {
  document.querySelectorAll(".cell").forEach(cell => {
    const r = cell.dataset.row;
    const c = cell.dataset.col;
    cell.innerHTML = '';
    cell.classList.remove("highlight", "selected");
    const existingScore = cell.querySelector('.score');
    const existingMove = cell.querySelector('.highlight-move');
    if (existingScore) existingScore.remove();
    if (existingMove) existingMove.remove();
    
    if (board[r][c]) {
      const piece = document.createElement("div");
      piece.className = board[r][c];
      cell.appendChild(piece);
    }
  });
}

function updateHighlights() {
  document.querySelectorAll(".cell").forEach(cell => {
    const r = parseInt(cell.dataset.row);
    const c = parseInt(cell.dataset.col);
    cell.classList.remove("selected");
    const existingScore = cell.querySelector('.score');
    const existingMove = cell.querySelector('.highlight-move');
    if (existingScore) existingScore.remove();
    if (existingMove) existingMove.remove();
    
    if (currentPlayer === 'black' && !board[r][c] && isValidMove(board, r, c, currentPlayer)) {
      const moveIndicator = document.createElement("div");
      moveIndicator.className = "highlight-move";
      cell.appendChild(moveIndicator);
      
      const score = calculateMoveScore(board, r, c, currentPlayer);
      const scoreDiv = document.createElement("div");
      scoreDiv.className = "score";
      scoreDiv.dataset.row = r;
      scoreDiv.dataset.col = c;
      scoreDiv.textContent = Math.max(0, score);
      scoreDiv.addEventListener("click", function(e) {
        e.stopPropagation();
        handleMove({ target: cell });
      });
      cell.appendChild(scoreDiv);
    }
  });
}

function isCornerNeighbor(r, c) {
  const corners = [[0,0],[0,7],[7,0],[7,7]];
  for (let [cr, cc] of corners) {
    if ((Math.abs(r - cr) <= 1 && Math.abs(c - cc) <= 1) && !(r === cr && c === cc)) {
      return true;
    }
  }
  return false;
}

function calculateMoveScore(b, r, c, player) {
  if (aiMode === 'simple') {
    const flips = countFlips(b, r, c, player);
    let bonus = 0;
    let penalty = 0;
    
    let score = flips;
    
    if (isCornerNeighbor(r, c)) {
      penalty -= 15; // GÃ¼Ã§lendirildi
    }
    else if ((r === 0 || r === 7) && (c === 0 || c === 7)) {
      bonus += 15; // ArtÄ±rÄ±ldÄ±
    }
    else if ((r === 0 || r === 7 || c === 0 || c === 7)) {
      bonus += 5;
    }
    
    return score + bonus + penalty;
  } else {
    const tempBoard = cloneBoard(b);
    makeMove(tempBoard, r, c, player);
    let rawScore = minimax(tempBoard, 2, false, -Infinity, Infinity, opposite(player));
    
    const allMoves = getValidMoves(b, player);
    let minScore = Infinity;
    for (let move of allMoves) {
      let tempB = cloneBoard(b);
      makeMove(tempB, move[0], move[1], player);
      let moveScore = minimax(tempB, 2, false, -Infinity, Infinity, opposite(player));
      if (moveScore < minScore) minScore = moveScore;
    }
    
    let normalized = rawScore - minScore;
    return Math.max(0, Math.round(normalized));
  }
}

function handleMove(e) {
  if (currentPlayer !== 'black') return;
  
  let targetCell;
  if (e.target.classList.contains('score')) {
    targetCell = e.target.parentElement;
  } else {
    targetCell = e.target;
  }
  
  const r = parseInt(targetCell.dataset.row);
  const c = parseInt(targetCell.dataset.col);
  
  if (!isValidMove(board, r, c, currentPlayer)) return;
  
  document.querySelectorAll('.cell').forEach(cell => {
    cell.classList.remove('selected');
  });
  targetCell.classList.add('selected');
  
  makeMove(board, r, c, currentPlayer);
  currentPlayer = 'white';
  updateBoard();
  updateStatus();
  setTimeout(aiMove, 400);
}

function aiMove() {
  if (!hasValidMove(board, 'white')) {
    currentPlayer = 'black';
    if (!hasValidMove(board, 'black')) return endGame();
    updateBoard();
    updateHighlights();
    updateStatus();
    return;
  }

  const mode = document.getElementById("aiMode").value;
  aiMode = mode;
  let move = mode === "simple"
    ? bestHeuristicMove(board, 'white')
    : bestMinimaxMove(board, DEPTH, 'white');

  if (move) makeMove(board, move[0], move[1], 'white');

  currentPlayer = 'black';
  if (!hasValidMove(board, 'black')) {
    currentPlayer = 'white';
    if (!hasValidMove(board, 'white')) return endGame();
  }

  updateBoard();
  updateHighlights();
  updateStatus();
}

function bestHeuristicMove(b, player) {
  let best = null, bestScore = -Infinity;
  for (let r = 0; r < SIZE; r++) {
    for (let c = 0; c < SIZE; c++) {
      if (isValidMove(b, r, c, player)) {
        const score = calculateMoveScore(b, r, c, player);
        if (score > bestScore) {
          bestScore = score;
          best = [r, c];
        }
      }
    }
  }
  return best;
}

function bestMinimaxMove(b, depth, player) {
  let bestVal = -Infinity;
  let bestMove = null;
  for (let move of getValidMoves(b, player)) {
    let newBoard = cloneBoard(b);
    makeMove(newBoard, move[0], move[1], player);
    let value = minimax(newBoard, depth - 1, false, -Infinity, Infinity, opposite(player));
    if (value > bestVal) {
      bestVal = value;
      bestMove = move;
    }
  }
  return bestMove;
}

function minimax(b, depth, maximizing, alpha, beta, player) {
  if (depth === 0 || isGameOver(b)) return evaluateBoard(b);
  const moves = getValidMoves(b, player);
  if (moves.length === 0) return evaluateBoard(b);

  if (maximizing) {
    let maxEval = -Infinity;
    for (let move of moves) {
      let newBoard = cloneBoard(b);
      makeMove(newBoard, move[0], move[1], player);
      let eval = minimax(newBoard, depth - 1, false, alpha, beta, opposite(player));
      maxEval = Math.max(maxEval, eval);
      alpha = Math.max(alpha, eval);
      if (beta <= alpha) break;
    }
    return maxEval;
  } else {
    let minEval = Infinity;
    for (let move of moves) {
      let newBoard = cloneBoard(b);
      makeMove(newBoard, move[0], move[1], player);
      let eval = minimax(newBoard, depth - 1, true, alpha, beta, opposite(player));
      minEval = Math.min(minEval, eval);
      beta = Math.min(beta, eval);
      if (beta <= alpha) break;
    }
    return minEval;
  }
}

function cloneBoard(b) {
  return b.map(row => [...row]);
}

function evaluateBoard(b) {
  const { black, white } = countPieces(b);
  let score = white - black;
  
  score += cornerBonus(b, 'white') - cornerBonus(b, 'black');
  score += edgeBonus(b, 'white') - edgeBonus(b, 'black');
  score += mobilityBonus(b, 'white') - mobilityBonus(b, 'black');
  score += cornerNeighborPenalty(b, 'white') - cornerNeighborPenalty(b, 'black');
  
  return score;
}

function cornerBonus(b, player) {
  const corners = [[0,0],[0,7],[7,0],[7,7]];
  return corners.reduce((sum, [r,c]) => sum + (b[r][c] === player ? 100 : 0), 0);
}

function edgeBonus(b, player) {
  let score = 0;
  for (let r = 0; r < SIZE; r++) {
    if (b[0][r] === player && ![0,7].includes(r)) score += 15; // ArtÄ±rÄ±ldÄ±
    if (b[7][r] === player && ![0,7].includes(r)) score += 15;
  }
  for (let c = 0; c < SIZE; c++) {
    if (b[c][0] === player && ![0,7].includes(c)) score += 15;
    if (b[c][7] === player && ![0,7].includes(c)) score += 15;
  }
  return score;
}

function mobilityBonus(b, player) {
  return getValidMoves(b, player).length * 8; // ArtÄ±rÄ±ldÄ±
}

function cornerNeighborPenalty(b, player) {
  let penalty = 0;
  const neighbors = [
    [0,1],[1,0],[1,1], [0,6],[1,7],[1,6],
    [7,1],[6,0],[6,1], [7,6],[6,7],[6,6]
  ];
  for (let [r,c] of neighbors) {
    if (b[r][c] === player) penalty += 50; // GÃœÃ‡LENDÄ°RÄ°LDÄ° (20 -> 50)
  }
  return -penalty;
}

function getValidMoves(b, player) {
  const moves = [];
  for (let r = 0; r < SIZE; r++)
    for (let c = 0; c < SIZE; c++)
      if (isValidMove(b, r, c, player)) moves.push([r, c]);
  return moves;
}

function isValidMove(b, r, c, player) {
  if (b[r][c]) return false;
  for (let [dr, dc] of directions) {
    let nr = r + dr, nc = c + dc, foundOpponent = false;
    while (inBounds(nr, nc) && b[nr][nc] === opposite(player)) {
      nr += dr; nc += dc; foundOpponent = true;
    }
    if (foundOpponent && inBounds(nr, nc) && b[nr][nc] === player)
      return true;
  }
  return false;
}

function makeMove(b, r, c, player) {
  b[r][c] = player;
  for (let [dr, dc] of directions) {
    let cellsToFlip = [];
    let nr = r + dr, nc = c + dc;
    while (inBounds(nr, nc) && b[nr][nc] === opposite(player)) {
      cellsToFlip.push([nr, nc]);
      nr += dr; nc += dc;
    }
    if (inBounds(nr, nc) && b[nr][nc] === player)
      for (let [fr, fc] of cellsToFlip) b[fr][fc] = player;
  }
}

function countFlips(b, r, c, player) {
  let total = 0;
  for (let [dr, dc] of directions) {
    let nr = r + dr, nc = c + dc, count = 0;
    while (inBounds(nr, nc) && b[nr][nc] === opposite(player)) {
      count++; nr += dr; nc += dc;
    }
    if (inBounds(nr, nc) && b[nr][nc] === player) total += count;
  }
  return total;
}

function opposite(p) { return p === 'black' ? 'white' : 'black'; }
function inBounds(r, c) { return r >= 0 && r < SIZE && c >= 0 && c < SIZE; }

function hasValidMove(b, player) {
  return getValidMoves(b, player).length > 0;
}

function countPieces(b) {
  let black = 0, white = 0;
  for (let r = 0; r < SIZE; r++)
    for (let c = 0; c < SIZE; c++)
      if (b[r][c] === 'black') black++;
      else if (b[r][c] === 'white') white++;
  return { black, white };
}

function isGameOver(b) {
  return !hasValidMove(b, 'black') && !hasValidMove(b, 'white');
}

function updateStatus() {
  const { black, white } = countPieces(board);
  document.getElementById("status").textContent =
    isGameOver(board)
      ? `Game Over! Black: ${black}  White: ${white}`
      : `Turn: ${currentPlayer === 'black' ? 'Black (You)' : 'White (Computer)'} | Black: ${black}  White: ${white}`;
}

function endGame() {
  const { black, white } = countPieces(board);
  let result = "It's a Tie!";
  if (black > white) result = "You Win! ðŸŽ‰";
  else if (white > black) result = "Computer Wins ðŸ¤–";
  document.getElementById("status").textContent = `Game Over! ${result}`;
}

function resetGame() {
  currentPlayer = 'black';
  aiMode = 'simple';
  createBoard();
}

document.getElementById("aiMode").addEventListener("change", function() {
  updateHighlights();
});

createBoard();
</script>
</body>
</html>