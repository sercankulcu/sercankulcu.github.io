<style>
  body { margin: 0; padding: 0; overflow: hidden; background-color: #663300; font-family: sans-serif; }
  #gameContainer { position: relative; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; }
  #startMenu {
    position: absolute;
    z-index: 10;
    background: rgba(0, 0, 0, 0.85);
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    color: white;
  }
  #startMenu h1 { font-size: 3rem; margin-bottom: 2rem; color: #FCBD00; text-shadow: 2px 2px #000; }
  .menu-btn {
    padding: 15px 30px;
    margin: 10px;
    font-size: 1.5rem;
    cursor: pointer;
    background-color: #FCBD00;
    border: 2px solid #333;
    border-radius: 8px;
    color: #333;
    font-weight: bold;
    transition: all 0.2s;
  }
  .menu-btn:hover { background-color: #fff; transform: scale(1.05); }
  #statusOverlay {
    position: absolute;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    color: rgba(255,255,255,0.7);
    font-size: 14px;
    pointer-events: none;
  }
</style>

<body onload="init();">
  <div id="gameContainer">
    <div id="startMenu">
      <h1>Tavla AI</h1>
      <button class="menu-btn" onclick="startGame('ai')">ðŸ¤– AI vs AI (Ä°zle)</button>
      <button class="menu-btn" onclick="startGame('human')">ðŸ‘¤ Ä°nsan vs AI (Oyna)</button>
    </div>
    
    <canvas id="myCanvas">
      Your browser does not support the canvas tag.
    </canvas>
    
    <div id="statusOverlay"></div>
  </div>
</body>

<script>
var canvas, ctx;
var mousePos;
// Oyun Modu DeÄŸiÅŸkenleri
var gameMode = null; // 'ai' veya 'human'
var humanColor = "white"; // Ä°nsan her zaman beyaz oynar
var aiColor = "black";

var ValidMoves = function(){
  this.numOfValidMoves = function(){
    var result = 0;
    for (var i in this) if (typeof this[i] === "object") result += this[i].length;
    return result;
  }
  setValidMoves(this);
  
  function setValidMoves(vm) {
    if (Board["bar"+Board.onMove.capitalizeFirstLetter()][0] > 0) {
      vm["bar"+Board.onMove.capitalizeFirstLetter()] = [];
      for (var i=0; i<Board.moves.length; i++) {
        if (isValid("bar" + Board.onMove.capitalizeFirstLetter(), Board.moves[i]) && vm["bar" + Board.onMove.capitalizeFirstLetter()].indexOf(Board.moves[i]) == -1) vm["bar" + Board.onMove.capitalizeFirstLetter()].push(Board.moves[i]);
      }
    }
    else { 
      for (var i=1; i<=24; i++) {
        if (Board["p"+i][1] != (Board.onMove == "black" ? 0 : 1)) continue;
        vm["p"+i] = [];
        for (var j=0; j<Board.moves.length; j++) {
          if (isValid("p"+i, Board.moves[j]) && vm["p"+i].indexOf(Board.moves[j]) == -1) vm["p"+i].push(Board.moves[j]);
        }
      }
    }
  }
  
  function isValid(start, number){
    var startPt, target;
    if (start.charAt(0) == "b") startPt = Board.onMove == "black" ? 25 : 0;
    else startPt = parseInt(start.substr(1));
    target = Board.onMove == "black" ? startPt-number : startPt+number;
    if (Board.onMove == "black" && target <= 0) target = "offBlack";
    else if (Board.onMove == "white" && target >= 25) target = "offWhite";
    else target = "p"+target;
    
    if (target.charAt(0) == "p") {
      if (Board[target][1] == -1) return true;
      if (Board[start][1] == Board[target][1]) return true;
      if (Board[target][0] > 1) return false;
      else return true;
    }
    else {   //bear off
      var playerCode = Board.onMove == "black" ? 0 : 1;
      var shift = Board.onMove == "black" ? 6 : 0;
      for (var i = 1+shift; i <= 18+shift; i++) {
        if (Board["p"+i][1] == playerCode) return false;
      }
      if (startPt == (Board.onMove == "black" ? number : 25-number)) return true;
      if (Board.onMove == "black") {
        for (var i = startPt+1; i <= 6; i++) {
          if (Board["p"+i][1] == playerCode) return false;
        }
      }
      if (Board.onMove == "white") {
        for (var i = startPt-1; i >= 19; i--) {
          if (Board["p"+i][1] == playerCode) return false;
        }
      }
      return true;
    }
  }
}

var Cube = { position: "center", value: 1, onScreen: false };
var Dices = { position: "", diceValueLeft: 5, diceValueRight: 5, onScreen: false };

var Board = {
  width: window.innerWidth*3/4 < window.innerHeight ? window.innerWidth - 20 : window.innerHeight*4/3*0.9,
  reset: function(){
    this.p24 = [2, 0]; this.p23 = [0, -1]; this.p22 = [0, -1]; this.p21 = [0, -1]; this.p20 = [0, -1];
    this.p19 = [5, 1]; this.p18 = [0, -1]; this.p17 = [3, 1]; this.p16 = [0, -1]; this.p15 = [0, -1];
    this.p14 = [0, -1]; this.p13 = [5, 0]; this.p12 = [5, 1]; this.p11 = [0, -1]; this.p10 = [0, -1];
    this.p9 = [0, -1]; this.p8 = [3, 0]; this.p7 = [0, -1]; this.p6 = [5, 0]; this.p5 = [0, -1];
    this.p4 = [0, -1]; this.p3 = [0, -1]; this.p2 = [0, -1]; this.p1 = [2, 1];
    this.offWhite = [0, 1]; this.offBlack = [0, 0];
    this.barWhite = [0, 1]; this.barBlack = [0, 0];
    this.status = "start";  
    this.onMove = "black";
    this.moves = [];
    this.playedMoves = [];
    Cube.position = "center";
    Cube.value = 1;
    Dices.onScreen = false;
  },
  save: function() {
    for (var i = 1; i <= 24; i++) this["b" + i] = this["p" + i].slice();
    this.bOffWhite = this.offWhite.slice();
    this.bOffBlack = this.offBlack.slice();
    this.bBarWhite = this.barWhite.slice();
    this.bBarBlack = this.barBlack.slice();
    this.bMoves = this.moves.slice();
  },
  undo: function() {
    for (var i = 1; i <= 24; i++) this["p" + i] = this["b" + i].slice();
    this.offWhite = this.bOffWhite.slice();
    this.offBlack = this.bOffBlack.slice();
    this.barWhite = this.bBarWhite.slice();
    this.barBlack = this.bBarBlack.slice();
    this.moves = this.bMoves.slice();
    this.playedMoves = [];    
  },
  mouseOverPoint: undefined
};

function init() {
  canvas = document.getElementById('myCanvas');
  ctx = canvas.getContext('2d');
  Board.reset();
  drawBoard(Board); 
  canvas.addEventListener("mousemove", handleMousemove);
  canvas.addEventListener("click", handleMouseclick);
}

// MenÃ¼den seÃ§im yapÄ±lÄ±nca Ã§aÄŸrÄ±lÄ±r
function startGame(mode) {
    gameMode = mode;
    document.getElementById('startMenu').style.display = 'none';
    
    // BaÅŸlangÄ±Ã§ ZarÄ±
    var r1 = 0, r2 = 0;
    while (r1 == r2) {
        r1 = Math.floor(Math.random()*6)+1;
        r2 = Math.floor(Math.random()*6)+1;
    }
    Board.onMove = r1 > r2 ? "black" : "white";
    Dices.diceValueLeft = Math.max(r1, r2);
    Dices.diceValueRight = Math.min(r1, r2);
    Board.moves = [r1, r2].sort((a,b)=>a-b);
    Board.status = "move";
    Dices.onScreen = true;
    
    drawBoard(Board);
    checkTurn(); // Ä°lk hamleyi kimin yapacaÄŸÄ±nÄ± kontrol et
}

function checkTurn() {
    // Oyun bitti mi?
    if (Board.offWhite[0] === 15 || Board.offBlack[0] === 15) return;

    if (gameMode === 'ai') {
        // AI vs AI modunda her zaman otomatik
        setTimeout(autoMove, 800);
    } else {
        // Human vs AI modu
        if (Board.onMove === humanColor) {
            // Ä°nsan sÄ±rasÄ±: Bekle (KullanÄ±cÄ± tÄ±klayacak)
            updateOverlay("SÄ±ra Sende (Beyaz). Hamle yap.");
        } else {
            // AI sÄ±rasÄ±: Otomatik oyna
            updateOverlay("Bilgisayar (Siyah) dÃ¼ÅŸÃ¼nÃ¼yor...");
            setTimeout(autoMove, 800);
        }
    }
}

function drawBoard(brd) {
  var w = brd.width;
  var h = w*3/4;
  var p = 0.02;
  canvas.width = w;
  canvas.height = h;
  
  // Renkler
  var boardBorderColor = "#663300";
  var boardInnerColor = "#B88A00";
  var triangleColor1 = "#ADAD85";
  var triangleColor2 = "#FF471A";
  var blackCheckerColor = "#333";
  var whiteCheckerColor = "#DDD";
  
  drawEmptyBoard();
  for (var i = 1; i <= 24; i++) drawPoint(i, brd["p" + i]);
  drawCheckersOnTheBar();
  drawCheckersBearedOff();
  drawRest();

  function drawEmptyBoard() {
    ctx.save();
    ctx.fillStyle = boardBorderColor;
    ctx.fillRect(0, 0, w, h);
    ctx.fillStyle = boardInnerColor;
    ctx.fillRect(w*p, h*p*2, w*p*3, h*p*20);
    ctx.fillRect(w*p, h*p*28, w*p*3, h*p*20);
    ctx.fillRect(w*p*46, h*p*2, w*p*3, h*p*20);
    ctx.fillRect(w*p*46, h*p*28, w*p*3, h*p*20);
    ctx.fillRect(w*p*5, h*p*2, w*p*18, h*p*46);
    ctx.fillRect(w*p*27, h*p*2, w*p*18, h*p*46);
    for (var i = 0; i <= 5; i++) {
      drawTriangle(5 + i*3, 2, 3, 20, i%2);
      drawTriangle(5 + i*3, 48, 3, 20, (i+1)%2);
      drawTriangle(27 + i*3, 2, 3, 20, i%2);
      drawTriangle(27 + i*3, 48, 3, 20, (i+1)%2);
    }
    ctx.restore();

    function drawTriangle(startx, starty, width, height, color) {
      var peak;
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(w * p * startx, h * p * starty);
      peak = starty < 25 ? starty + height : starty - height;
      ctx.lineTo(w * p * (startx + width / 2), h * p * peak);
      ctx.lineTo(w * p * (startx + width), h * p * starty);
      ctx.fillStyle = color == 0 ? triangleColor1 : triangleColor2;
      ctx.strokeStyle = "#444";
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawPoint(j, point) {
    if (point[1] == -1 || point[0] == 0) return;
    var color = point[1] == 0 ? blackCheckerColor : whiteCheckerColor;
    var centerx, centery;
    var numCheckers = Math.min(point[0], 5);
    for (var i = 0; i < numCheckers; i++) {
      if (j >= 19) { centerx = w*p * (28.5 + (j-19) * 3); centery = 2*h*p + 1.5*w*p + i*3*w*p; } 
      else if (j >= 13) { centerx = w*p * (6.5 + (j-13) * 3); centery = 2*h*p + 1.5*w*p + i*3*w*p; } 
      else if (j >= 7) { centerx = w*p * (6.5 + (12-j) * 3); centery = 48*h*p - 1.5*w*p - i*3*w*p; } 
      else { centerx = w*p * (28.5 + (6-j) * 3); centery = 48*h*p - 1.5*w*p - i*3*w*p; }
      drawChecker(centerx, centery, color, (j == brd.mouseOverPoint && i == numCheckers-1 && brd.status == "move" && point[1] == (brd.onMove == "black" ? 0 : 1)));
    }
    if (point[0] > 5) {
      ctx.save();
      ctx.fillStyle = color == blackCheckerColor ? whiteCheckerColor : blackCheckerColor;
      ctx.font = w*p*1.8 + "px Arial";
      ctx.textBaseline = "middle"; ctx.textAlign = "center";
      ctx.fillText(point[0].toString(), centerx, centery);
      ctx.restore();
    }
  }

  function drawChecker(x, y, col, hl) {
    var r = w*p*1.5;
    ctx.save();
    ctx.beginPath();
    if (hl) { r *= 1.05; ctx.shadowColor = "#444"; ctx.shadowBlur = 5; }
    ctx.arc(x, y, r*0.99, 0, 2 * Math.PI);
    ctx.fillStyle = col; ctx.fill(); ctx.restore(); ctx.stroke();
  }
  
  function drawCheckersOnTheBar(){
    var x = w*p*25;
    for (var i=0; i<brd.barBlack[0]; i++) drawChecker(x, h*p*18 - i*w*p*3, blackCheckerColor, (brd.mouseOver == "barBlack" && i == brd.barBlack[0]-1 && brd.status == "move" && brd.onMove == "black"));
    for (var i=0; i<brd.barWhite[0]; i++) drawChecker(x, h*p*32 + i*w*p*3, whiteCheckerColor, (brd.mouseOver == "barWhite" && i == brd.barWhite[0]-1 && brd.status == "move" && brd.onMove == "white"));
  }
  
  function drawCheckersBearedOff() {
    ctx.save();
    ctx.fillStyle = blackCheckerColor; ctx.lineWidth = 2;
    for (var i = 1; i <= brd.offBlack[0]; i++) { ctx.fillRect(w*p*46, h*p*(48 - i*4/3), w*p*3, h*p*4/3); ctx.strokeRect(w*p*46, h*p*(48 - i*4/3), w*p*3, h*p*4/3); }
    ctx.fillStyle = whiteCheckerColor;
    for (var i = 0; i < brd.offWhite[0]; i++) { ctx.fillRect(w*p*46, h*p*(2 + i*4/3), w*p*3, h*p*4/3); ctx.strokeRect(w*p*46, h*p*(2 + i*4/3), w*p*3, h*p*4/3); }
    ctx.restore();
  }

  function drawRest() {
    if (brd.status == "move" || brd.status == "roll") drawDices();

    function drawDices() {
      if(!Dices.onScreen) return;
      var x = brd.onMove == "black" ? w*p*35.5 - h*p*4 : w*p*14.5;
      var y = h*p*23;
      var diceColor = brd.onMove == "black" ? "#333" : "#DDD";
      var dotColor = brd.onMove == "black" ? "#DDD" : "#333";
      drawOneDice(x, y, h*p*4, Dices.diceValueLeft, diceColor, dotColor);
      x = brd.onMove == "black" ? x + h*p*4 + w*p : x - h*p*4 - w*p;
      drawOneDice(x, y, h*p*4, Dices.diceValueRight, diceColor, dotColor);
      
      function drawOneDice(x, y, size, value, dc, doc) {
        ctx.save();
        ctx.fillStyle = dc;
        ctx.translate(x, y);
        ctx.beginPath(); ctx.rect(0,0,size,size); ctx.fill(); ctx.stroke();
        
        ctx.fillStyle = doc;
        var pads = [[],[3],[0,6],[0,3,6],[0,2,4,6],[0,2,3,4,6],[0,1,2,4,5,6]];
        var pos = [{x:0.25,y:0.25},{x:0.25,y:0.5},{x:0.25,y:0.75},{x:0.5,y:0.5},{x:0.75,y:0.25},{x:0.75,y:0.5},{x:0.75,y:0.75}];
        for(var i=0; i<pads[value].length; i++){
           var p = pos[pads[value][i]];
           ctx.beginPath(); ctx.arc(p.x*size, p.y*size, size*0.07, 0, 2*Math.PI); ctx.fill();
        }
        ctx.restore();
      }
    }
  }
}

function handleMousemove(evt) {
  mousePos = getMousePos(canvas, evt);
  Board.mouseOverPoint = (mousePos.point != undefined && mousePos.point.charAt(0) == "p") ? parseInt(mousePos.point.substr(1)) : undefined;
  Board.mouseOver = mousePos.point; 
  drawBoard(Board);
}

function handleMouseclick(evt) {
  // EÄŸer menÃ¼ aÃ§Ä±ksa veya yapay zeka dÃ¼ÅŸÃ¼nÃ¼yorsa veya sÄ±ra rakipteyken (Human vs AI) tÄ±klama
  if (document.getElementById('startMenu').style.display !== 'none') return;
  if (isThinking) return;
  if (gameMode === 'human' && Board.onMove !== humanColor && Board.status === 'move') return;

  mousePos = getMousePos(canvas, evt);

  // --- Ä°NSAN Ä°Ã‡Ä°N ZAR ATMA ---
  // Buton olmadÄ±ÄŸÄ± iÃ§in, eÄŸer sÄ±ra insandaysa ve durum "roll" ise, ekrana herhangi bir tÄ±klama zar atar
  if (Board.status == "roll") {
      // Sadece insan modunda ve insan sÄ±rasÄ±ndaysa manuel zar atÄ±labilir
      // AI vs AI modunda buraya manuel giremez, autoRoll halleder
      if (gameMode === 'human' && Board.onMove === humanColor) {
          humanRoll();
      }
      return;
  }
  
  if (Board.status == "move") {
    var start, stpt, target, tgpt;
    var valids = new ValidMoves();

    // Zar deÄŸiÅŸtirmek iÃ§in zarlara tÄ±klama
    if (mousePos.point == "Dices" && valids.numOfValidMoves() > 0) {
        var temp = Dices.diceValueLeft;
        Dices.diceValueLeft = Dices.diceValueRight;
        Dices.diceValueRight = temp;
        drawBoard(Board);
        return;
    }

    // Hamle yapma mantÄ±ÄŸÄ± (Eski koddan, biraz sadeleÅŸtirildi)
    if (mousePos.point && (mousePos.point.charAt(0) == "p" || mousePos.point.charAt(0) == "b")) {
      if (Board[mousePos.point][1] != (Board.onMove == "black" ? 0 : 1)) return; // Kendi taÅŸÄ±n deÄŸil
      
      start = mousePos.point;
      if (!valids.hasOwnProperty(start) || valids[start].length == 0) return; // GeÃ§erli hamle yok

      stpt = start.charAt(0) == "p" ? Board.mouseOverPoint : (Board.onMove == "black" ? 25: 0);
      var currentMove = (valids[start].length > 1) ? Dices.diceValueLeft : valids[start][0];
      tgpt = Board.onMove == "black" ? stpt - currentMove : stpt + currentMove;
      
      if (Board.onMove == "black" && tgpt < 1) target = "offBlack";
      else if (Board.onMove == "white" && tgpt > 24) target = "offWhite";
      else target = "p" + tgpt;
      
      move(start, target);
      Board.moves.splice(Board.moves.indexOf(currentMove), 1);
      drawBoard(Board);
      
      // Hamleler bitti mi?
      var v2 = new ValidMoves();
      if (Board.moves.length == 0 || v2.numOfValidMoves() == 0) {
          if (Board["off"+Board.onMove.capitalizeFirstLetter()][0] == 15) {
             updateOverlay(Board.onMove.capitalizeFirstLetter() + " KAZANDI!");
             setTimeout(function(){ location.reload(); }, 3000);
             return;
          }
          endTurn();
      }
    }
  }
}

// Ä°nsan oyuncu zar atma fonksiyonu
function humanRoll() {
    var r1 = Math.floor(Math.random()*6)+1;
    var r2 = Math.floor(Math.random()*6)+1;
    Dices.diceValueLeft = Math.max(r1, r2);
    Dices.diceValueRight = Math.min(r1, r2);
    Board.moves = [r1, r2];
    if (r1 === r2) Board.moves.push(r1, r2);
    Board.moves.sort((a,b)=>a-b);
    Dices.onScreen = true;
    Board.status = "move";
    updateOverlay("Zar attÄ±n: " + r1 + "-" + r2);
    drawBoard(Board);
    
    var valids = new ValidMoves();
    if (valids.numOfValidMoves() === 0) {
        setTimeout(function(){ endTurn(); }, 1500);
        updateOverlay("YapÄ±lacak hamle yok.");
    }
}

function move(start, target) {
  if (target.charAt(0) == "o") Board["off" + Board.onMove.capitalizeFirstLetter()][0]++;
  else if (Board[target][0] == 0) { Board[target][0]++; Board[target][1] = Board[start][1]; }
  else if (Board[target][1] == Board[start][1]) Board[target][0]++;
  else {
    Board[target][1] = 1 - Board[target][1];
    if (Board.onMove == "black") Board.barWhite[0]++; else Board.barBlack[0]++;
  }
  if (--Board[start][0] == 0 && start.charAt(0) == "p") Board[start][1] = -1;
  Board.playedMoves.push(start+"/"+target);
}

function getMousePos(canvas, evt) {
  var rect = canvas.getBoundingClientRect();
  var w = canvas.width, h = canvas.height, p = 0.02;
  var result = { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
  result.xp = parseFloat(result.x / w * 50).toFixed(2);
  result.yp = parseFloat(result.y / h * 50).toFixed(2);
  var pt = 0;
  if (result.xp > 27 && result.xp < 45 && result.yp > 2 && result.yp < 22) pt = Math.floor((result.xp - 27) / 3) + 19;
  else if (result.xp > 5 && result.xp < 23 && result.yp > 2 && result.yp < 22) pt = Math.floor((result.xp - 5) / 3) + 13;
  else if (result.xp > 5 && result.xp < 23 && result.yp > 28 && result.yp < 48) pt = 12 - Math.floor((result.xp - 5) / 3);
  else if (result.xp > 27 && result.xp < 45 && result.yp > 28 && result.yp < 48) pt = 6 - Math.floor((result.xp - 27) / 3);

  if (pt != 0) result.point = "p" + pt;
  else if (Board.barBlack[0] > 0 && result.xp > 23.5 && result.xp < 26.5 && result.y < h*p*18 + w*p*1.5) result.point = "barBlack";
  else if (Board.barWhite[0] > 0 && result.xp > 23.5 && result.xp < 26.5 && result.y > h*p*32 - w*p*1.5) result.point = "barWhite";
  else if (Dices.onScreen && ((Dices.position=="right" && result.xp>32.5 && result.xp<39.5) || (Dices.position=="left" && result.xp>10.5 && result.xp<17.5)) && result.yp>23 && result.yp<27) result.point="Dices";
  else result.point = undefined;
  return result;
}

String.prototype.capitalizeFirstLetter = function() { return this.charAt(0).toUpperCase() + this.slice(1); }

// === AI MANTIKLARI (DeÄŸiÅŸtirilmeden korundu ve Human moduna uyarlandÄ±) ===
var isThinking = false;

// AI Puanlama
const AI_WEIGHTS = { BEAR_OFF: 2000, HIT_OPPONENT: 1200, MAKE_POINT: 400, COVER_BLOT: 300, LEAVE_BLOT: -400, HOME_BOARD: 60, STACKING_PENALTY: -40 };

function getSmartMove(validMovesObj) {
  var possibleStarts = Object.keys(validMovesObj).filter(k => validMovesObj[k].length > 0);
  if (possibleStarts.length === 0) return null;
  var bestMove = null, bestScore = -Infinity;
  possibleStarts.forEach(function(start) {
    validMovesObj[start].forEach(function(die) {
      var score = evaluateMoveQuality(start, die) + Math.random() * 10;
      if (score > bestScore) { bestScore = score; bestMove = { start: start, die: die }; }
    });
  });
  return bestMove;
}

function evaluateMoveQuality(start, die) {
  var score = 0;
  var me = Board.onMove == "black" ? 0 : 1; var opp = 1 - me;
  var startPt = start.startsWith("bar") ? (me == 0 ? 25 : 0) : parseInt(start.substr(1));
  var targetPt = (me == 0) ? startPt - die : startPt + die;
  var target, isBearOff = false;
  if (me == 0 && targetPt <= 0) { target = "offBlack"; isBearOff = true; }
  else if (me == 1 && targetPt >= 25) { target = "offWhite"; isBearOff = true; }
  else target = "p" + targetPt;

  if (isBearOff) return AI_WEIGHTS.BEAR_OFF;
  var destData = Board[target]; var srcData = Board[start];
  if (destData[1] == opp && destData[0] == 1) score += AI_WEIGHTS.HIT_OPPONENT;
  if (destData[1] == me && destData[0] == 1) score += AI_WEIGHTS.MAKE_POINT;
  if (srcData[0] == 2) score += AI_WEIGHTS.LEAVE_BLOT;
  if (destData[0] == 0) score += AI_WEIGHTS.LEAVE_BLOT / 1.5;
  if (destData[1] == me && destData[0] >= 3) score += AI_WEIGHTS.STACKING_PENALTY * (destData[0] - 2);
  if (srcData[0] == 1) score += AI_WEIGHTS.COVER_BLOT;
  return score;
}

function autoMove() {
  if (Board.status !== "move" || (gameMode === 'human' && Board.onMove === humanColor)) return;
  
  isThinking = true;
  var valids = new ValidMoves();
  if (valids.numOfValidMoves() === 0) { endTurn(); isThinking = false; return; }

  var moveChoice = getSmartMove(valids);
  if (!moveChoice) { // Fallback
    var startPoints = Object.keys(valids).filter(k => valids[k].length > 0);
    var rndStart = startPoints[Math.floor(Math.random() * startPoints.length)];
    var rndDie = valids[rndStart][0];
    moveChoice = { start: rndStart, die: rndDie };
  }

  var start = moveChoice.start; var die = moveChoice.die;
  var startPt = start.startsWith("bar") ? (Board.onMove === "black" ? 25 : 0) : parseInt(start.substr(1));
  var targetPt = Board.onMove === "black" ? startPt - die : startPt + die;
  var target = (Board.onMove === "black" && targetPt <= 0) ? "offBlack" : (Board.onMove === "white" && targetPt >= 25) ? "offWhite" : "p" + targetPt;

  move(start, target);
  var diceIndex = Board.moves.indexOf(die);
  if (diceIndex > -1) Board.moves.splice(diceIndex, 1);
  drawBoard(Board);

  if (Board["off" + Board.onMove.capitalizeFirstLetter()][0] === 15) {
     updateOverlay("YAPAY ZEKA KAZANDI!");
     setTimeout(function(){ location.reload(); }, 3000);
     return;
  }

  if (Board.moves.length === 0) setTimeout(endTurn, 800);
  else setTimeout(autoMove, 800);
}

function endTurn() {
  isThinking = false;
  Dices.onScreen = false;
  Board.onMove = Board.onMove === "black" ? "white" : "black";
  Board.status = "roll";
  Board.moves = [];
  drawBoard(Board);
  
  // SÄ±ra kimde kontrol et ve ona gÃ¶re aksiyon al
  if (gameMode === 'ai') {
      setTimeout(autoRoll, 800);
  } else {
      if (Board.onMove === humanColor) {
          updateOverlay("SÄ±ra Sende (Beyaz). Zar atmak iÃ§in ekrana tÄ±kla.");
      } else {
          updateOverlay("SÄ±ra Yapay Zekada (Siyah).");
          setTimeout(autoRoll, 800);
      }
  }
}

function autoRoll() {
  if (Board.status !== "roll") return;
  var r1 = Math.floor(Math.random()*6)+1;
  var r2 = Math.floor(Math.random()*6)+1;
  Dices.diceValueLeft = Math.max(r1, r2);
  Dices.diceValueRight = Math.min(r1, r2);
  Board.moves = [r1, r2];
  if (r1 === r2) Board.moves.push(r1, r2);
  Board.moves.sort((a,b)=>a-b);
  Dices.onScreen = true;
  Board.status = "move";
  drawBoard(Board);
  
  var valids = new ValidMoves();
  if (valids.numOfValidMoves() === 0) setTimeout(endTurn, 1000);
  else setTimeout(autoMove, 800);
}

function updateOverlay(msg) {
    document.getElementById("statusOverlay").innerText = msg;
}
</script>