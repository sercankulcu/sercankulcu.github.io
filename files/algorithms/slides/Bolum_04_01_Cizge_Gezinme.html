<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Graph Traversal Simulator: BFS and DFS Visualization</title>
  <meta name="description"
    content="Visualize Breadth-First Search (BFS) and Depth-First Search (DFS) graph traversal algorithms in a web-based simulator. Generate random graphs and observe the step-by-step animation.">
  <meta name="keywords"
    content="graph traversal, BFS, DFS, algorithm visualization, javascript, graph simulator, web development, data structures">

  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #f0f0f0;
      color: #333;
      text-align: center;
      margin: 0 auto;
      padding: 1vw;
      max-width: 800px;
      box-sizing: border-box;
    }

    .container {
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
    }

    .controls {
      display: flex;
      flex-wrap: nowrap;
      justify-content: space-between;
      gap: 1vw;
      width: 100%;
      box-sizing: border-box;
      padding: 1vw;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    input,
    button {
      width: calc((100% - (4 * 1vw)) / 4);
      padding: 1vw;
      margin: 0;
      border: 2px solid #ccc;
      border-radius: 8px;
      font-size: 1rem;
      box-sizing: border-box;
    }

    button {
      background-color: #4CAF50;
      color: white;
      cursor: pointer;
      border: none;
    }

    button:hover {
      background-color: #45a049;
    }


    #graphCanvas {
      margin: 10px;
    }

    .node {
      position: absolute;
      background-color: #eee;
      border: 1px solid #000;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .edge {
      position: absolute;
      background-color: #000;
    }

    #outputDiv {
      margin-top: 10px;
      width: 80%;
      max-height: 200px;
      max-width: 800px;
      overflow-y: auto;
      white-space: pre-wrap;
    }
  </style>
</head>

<body>
  <h1>Graph Traversal Simulator</h1>
  <div class="container">
    <div class="controls">
      <input type="number" id="nodeCount" value="10">
      <button id="generateButton">Generate Graph</button>
      <button id="bfsButton">BFS</button>
      <button id="dfsButton">DFS</button>
    </div>
  </div>

  <canvas id="graphCanvas" width="600" height="400"></canvas>

  <div id="outputDiv"></div>

  <script>
    const canvas = document.getElementById('graphCanvas');
    const ctx = canvas.getContext('2d');
    const nodeCountInput = document.getElementById('nodeCount');
    const generateButton = document.getElementById('generateButton');
    const bfsButton = document.getElementById('bfsButton');
    const dfsButton = document.getElementById('dfsButton');
    const outputDiv = document.getElementById('outputDiv');

    let nodes = [];
    let edges = [];
    let adjacencyList = {};

    function generateGraph() {
      const nodeCount = parseInt(nodeCountInput.value);
      const nodeVisualSize = 30;
      nodes = [];
      edges = [];
      adjacencyList = {};

      // Generate nodes
      for (let i = 0; i < nodeCount; i++) {
        const x = Math.random() * (canvas.width - nodeVisualSize);
        const y = Math.random() * (canvas.height - nodeVisualSize);
        nodes.push({ id: i, x, y, size: nodeVisualSize });
        adjacencyList[i] = [];
      }

      // Generate some random edges (adjust probability as needed)
      for (let i = 0; i < nodes.length; i++) {
        for (let j = i + 1; j < nodes.length; j++) {
          if (Math.random() < 0.3) { // 30% probability of an edge
            edges.push({ from: i, to: j });
            adjacencyList[i].push(j);
            adjacencyList[j].push(i); // Assuming undirected graph
          }
        }
      }
      clearOutput();
      logOutput("Graph generated with " + nodeCount + " nodes and " + edges.length + " edges.");
      drawGraph();
    }

    function drawGraph() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw edges
      edges.forEach(edge => {
        const fromNode = nodes[edge.from];
        const toNode = nodes[edge.to];

        ctx.beginPath();
        ctx.moveTo(fromNode.x + fromNode.size / 2, fromNode.y + fromNode.size / 2);
        ctx.lineTo(toNode.x + toNode.size / 2, toNode.y + toNode.size / 2);
        ctx.stroke();
      });

      // Draw nodes
      nodes.forEach(node => {
        ctx.beginPath();
        ctx.arc(node.x + node.size / 2, node.y + node.size / 2, node.size / 2, 0, 2 * Math.PI);
        ctx.fillStyle = '#eee';
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = '#000';
        ctx.fillText(node.id, node.x + node.size / 2 - 5, node.y + node.size / 2 + 5);
      });
    }

    async function bfs() {
      if (nodes.length === 0) return;
      clearOutput();
      logOutput("Starting BFS from node 0.");

      const startNodeId = 0; // Start BFS from the first node
      const queue = [startNodeId];
      const visited = new Set();
      visited.add(startNodeId);

      while (queue.length > 0) {
        const currentNodeId = queue.shift();
        logOutput("Visiting node: " + currentNodeId);
        await highlightNode(currentNodeId, 'green'); // Highlight current node

        for (const neighborId of adjacencyList[currentNodeId]) {
          if (!visited.has(neighborId)) {
            logOutput("Enqueuing neighbor: " + neighborId + " from " + currentNodeId);
            queue.push(neighborId);
            visited.add(neighborId);
            await highlightEdge(currentNodeId, neighborId, 'green'); //Highlight edge
          } else {
            logOutput("Neighbor " + neighborId + " of " + currentNodeId + " already visited.");
          }
        }
      }
      logOutput("BFS finished.");
      resetNodeColors();
      resetEdgeColors();
    }

    async function dfs() {
      if (nodes.length === 0) return;
      clearOutput();
      logOutput("Starting DFS from node 0.");

      const startNodeId = 0; // Start DFS from the first node
      const stack = [startNodeId];
      const visited = new Set();

      while (stack.length > 0) {
        const currentNodeId = stack.pop();

        if (!visited.has(currentNodeId)) {
          visited.add(currentNodeId);
          logOutput("Visiting node: " + currentNodeId);
          await highlightNode(currentNodeId, 'blue'); // Highlight current node

          for (const neighborId of adjacencyList[currentNodeId]) {
            if (!visited.has(neighborId)) {
              logOutput("Pushing neighbor: " + neighborId + " onto stack from " + currentNodeId);
              stack.push(neighborId);
              await highlightEdge(currentNodeId, neighborId, 'blue'); //Highlight edge
            } else {
              logOutput("Neighbor " + neighborId + " of " + currentNodeId + " already visited.");
            }
          }
        }
      }
      logOutput("DFS finished.");
      resetNodeColors();
      resetEdgeColors();
    }

    async function highlightNode(nodeId, color) {
      const node = nodes[nodeId];
      ctx.beginPath();
      ctx.arc(node.x + node.size / 2, node.y + node.size / 2, node.size / 2, 0, 2 * Math.PI);
      ctx.fillStyle = color;
      ctx.fill();
      ctx.stroke();
      await delay(500); // Animation delay
    }

    async function highlightEdge(fromNodeId, toNodeId, color) {
      const fromNode = nodes[fromNodeId];
      const toNode = nodes[toNodeId];

      ctx.beginPath();
      ctx.moveTo(fromNode.x + fromNode.size / 2, fromNode.y + fromNode.size / 2);
      ctx.lineTo(toNode.x + toNode.size / 2, toNode.y + toNode.size / 2);
      ctx.strokeStyle = color;
      ctx.stroke();
      ctx.strokeStyle = '#000'; // Reset stroke color
      await delay(500); // Animation delay
    }

    function resetNodeColors() {
      nodes.forEach(node => {
        ctx.beginPath();
        ctx.arc(node.x + node.size / 2, node.y + node.size / 2, node.size / 2, 0, 2 * Math.PI);
        ctx.fillStyle = '#eee';
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = '#000';
        ctx.fillText(node.id, node.x + node.size / 2 - 5, node.y + node.size / 2 + 5);
      });
    }

    function resetEdgeColors() {
      drawGraph(); // Redraws the graph, effectively resetting edge colors
    }

    function delay(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    function logOutput(message) {
      outputDiv.textContent += message + "\n";
      outputDiv.scrollTop = outputDiv.scrollHeight; // Auto scroll to bottom
    }

    function clearOutput() {
      outputDiv.textContent = "";
    }

    generateButton.addEventListener('click', generateGraph);
    bfsButton.addEventListener('click', bfs);
    dfsButton.addEventListener('click', dfs);

    // Initial graph generation
    generateGraph();
  </script>
</body>

</html>