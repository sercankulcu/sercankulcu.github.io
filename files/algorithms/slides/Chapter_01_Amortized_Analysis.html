<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Amortized Analysis</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      padding: 30px;
      max-width: 800px;
      margin: auto;
      background-color: #f9f9f9;
      color: #333;
    }
    h1, h2 {
      color: #005f73;
    }
    code {
      background-color: #eee;
      padding: 2px 4px;
      border-radius: 3px;
      font-family: Consolas, monospace;
    }
  </style>
</head>
<body>

  <h1>Amortized Analysis</h1>

  <h2>What is Amortized Analysis?</h2>
  <p>
    Sometimes, an operation looks expensive. But if we look at many operations together, the cost is not so bad. 
    That’s where amortized analysis helps.
  </p>
  <p>
    It tells us the average cost per operation, over a series of operations. It’s not the worst-case. It's not the best-case. 
    It’s the long-term average.
  </p>

  <h2>Why Use Amortized Analysis?</h2>
  <p>
    Let’s say you are buying bus tickets every day. One day, you buy a 30-day pass. It’s expensive that day, 
    but cheap in the long run. On average, your cost per ride is low.
  </p>
  <p>
    Computers work the same way. Some operations are costly, but not always. 
    If we average over time, things look better.
  </p>

  <h2>Real-Life Example: A Piggy Bank</h2>
  <p>
    Imagine you have a piggy bank. You drop coins every day. 
    Once it’s full, you break it and buy a new one. 
    Breaking the piggy bank is costly. But you don’t do it every day.
  </p>
  <p>
    Over many days, the average cost per day is small.
    This is like amortized analysis.
  </p>

  <h2>Computer Science Example: Dynamic Array</h2>
  <p>
    A dynamic array is like a resizable list. In Java or Python, it’s like <code>ArrayList</code> or <code>list</code>.
  </p>
  <p>
    When it gets full, it doubles its size. That doubling step is expensive.
  </p>
  <p>
    But most of the time, adding an item is quick. Only sometimes it’s slow.
  </p>
  <p>
    So, the average cost per add is low.
  </p>

  <h2>How It Works: Cost Over Time</h2>
  <p>
    Suppose adding to the array takes:
  </p>
  <ul>
    <li>1 unit of time if there’s space</li>
    <li>n units of time when resizing (because we copy n items)</li>
  </ul>
  <p>
    But resizing happens rarely. After copying n items, we get space for n more.
  </p>
  <p>
    So, if we do many adds, the average cost is about 2 units per add.
  </p>
  <p>
    That’s amortized analysis.
  </p>

  <h2>Three Methods of Amortized Analysis</h2>
  <ol>
    <li><strong>Aggregate Method:</strong> Total cost divided by total number of operations.</li>
    <li><strong>Accounting Method:</strong> Charge extra for cheap operations. Save the extra for later use.</li>
    <li><strong>Potential Method:</strong> Use a potential function to track "stored energy" or cost.</li>
  </ol>

  <h2>Example Using Aggregate Method</h2>
  <p>
    Suppose we perform 8 operations. Let’s say the total cost is 16.
  </p>
  <p>
    Then the amortized cost is 16 ÷ 8 = 2.
  </p>

  <h2>Example Using Accounting Method</h2>
  <p>
    We add items to a dynamic array. Normal add costs 1.
    But we charge 3 for every add.
  </p>
  <p>
    The extra 2 is saved for when resizing happens.
  </p>
  <p>
    When we double the array, we use the saved credits to pay for copying.
  </p>

  <h2>Example Using Potential Method</h2>
  <p>
    Think of a potential as stored cost. Like water in a tank.
  </p>
  <p>
    Some operations increase the potential. Some use it.
  </p>
  <p>
    We define a function that calculates the potential after each step.
  </p>
  <p>
    Amortized cost = actual cost + change in potential.
  </p>

  <h2>When to Use Amortized Analysis?</h2>
  <p>
    Use it when some operations are rare but expensive.
  </p>
  <p>
    Good examples are:
  </p>
  <ul>
    <li>Dynamic arrays</li>
    <li>Stack with multipop</li>
    <li>Union-Find data structure</li>
    <li>Splay Trees</li>
  </ul>

  <h2>Summary</h2>
  <ul>
    <li>Amortized analysis gives average cost per operation over time.</li>
    <li>It is useful when some operations are costly but rare.</li>
    <li>There are three main methods: aggregate, accounting, and potential.</li>
    <li>It helps us design efficient algorithms and data structures.</li>
  </ul>

  <h2>Fun Tip</h2>
  <p>
    Think of amortized cost like paying for a gym membership. 
    One-time payment, but you use it many times.
  </p>
  <p>
    The average cost per workout is low!
  </p>

</body>
</html>
