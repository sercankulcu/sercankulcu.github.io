<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sorting Algorithms</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      margin: 20px auto; /* Center the content horizontally */
      background-color: #f4f4f9;
	  max-width: 800px;
    }
    h1, h2 {
      text-align: center;
    }
    .content {
      display: none;
    }
    .content.active {
      display: block;
    }
    button {
      display: block;
      margin: 10px auto;
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
    }
    .section {
      margin-bottom: 20px;
    }
    .section h2 {
      margin-bottom: 10px;
    }
    ul {
      margin: 0;
      padding: 0 20px;
    }
    li {
      margin-bottom: 5px;
    }
  </style>
</head>
<body>
  <button id="toggleLang">Türkçe</button>

  <div id="englishContent" class="content active">
    <h1>Sorting Algorithms</h1>

    <div class="section">
      <h2>Bubble Sort</h2>
      <ul>
        <li>➀ Compare 2 consecutive elements. Swap if 1st one is larger than 2nd one.</li>
        <li>➁ At the end of each iteration, largest element in the list bubbles up to the top of the list.</li>
        <li>➂ The next iteration excludes the last element (i.e., largest element) in the list.</li>
      </ul>
    </div>
    <div class="section">
      <h2>Insertion Sort</h2>
      <ul>
        <li>➀ An element in the list is picked and compared with all other elements prior to it in reverse order.</li>
        <li>➁ If the element is smaller than the compared element, later is shifted to the right. Or else the element is inserted next to the compared element.</li>
      </ul>
    </div>
        <div class="section">
      <h2>Selection Sort</h2>
      <ul>
        <li>➀ The list is scanned for the smallest element.</li>
        <li>➁ At the end of each iteration, this smallest element is swapped with the first element in the list.</li>
        <li>➂ The next iteration excludes the first element (i.e., smallest element) in the list.</li>
      </ul>
    </div>
    <div class="section">
      <h2>Merge Sort</h2>
      <ul>
        <li>➀ A list is divided into 2 equal halves. Each half goes for a recursion (calling same function).</li>
        <li>➁ It is expected to have 2 sorted sublists at the end of recursion.</li>
        <li>➂ Merge 2 sorted sublists to form a full sorted list.</li>
      </ul>
    </div>
    <div class="section">
      <h2>Quick Sort</h2>
      <ul>
        <li>➀ A pivot element is chosen and checked for an appropriate position in the list such that smaller elements are left to it and larger elements are right to it.</li>
        <li>➁ The left and right sublists do the same through recursion.</li>
      </ul>
    </div>
    <div class="section">
      <h2>Counting Sort</h2>
      <ul>
        <li>➀ The list is scanned for the maximum element.</li>
        <li>➁ Another list (count list) is created of size (max element + 1) with all 0s.</li>
        <li>➂ The list is traversed and the count list is updated accordingly with an appropriate count.</li>
        <li>➃ Based on counts, the list is sorted.</li>
      </ul>
    </div>
    <div class="section">
      <h2>Radix Sort</h2>
      <ul>
        <li>➀ Find the max value in the list. Find out how many digits it has.</li>
        <li>➁ Starting from units, then to tens and hundreds, etc., arrange the elements based on sorted numbers in that digit place.</li>
      </ul>
    </div>
    <div class="section">
      <h2>Bucket Sort</h2>
      <ul>
        <li>➀ First a bucket list is created. Each bucket in the list can contain elements of a certain range.</li>
        <li>➁ Elements are scattered in buckets.</li>
        <li>➂ Each bucket is sorted (other sorting technique).</li>
        <li>➃ Elements from all buckets are gathered.</li>
      </ul>
    </div>
    <div class="section">
      <h2>Heap Sort</h2>
      <ul>
        <li>➀ Elements are kept in heap either in Min-Heap or Max-Heap.</li>
        <li>➁ The root is swapped with the rightmost child node and, then removed from the heap.</li>
        <li>➂ Then the heap is heapified and this process continues till the heap is empty.</li>
      </ul>
    </div>
    <div class="section">
      <h2>Shell Sort</h2>
      <ul>
        <li>➀ It uses insertion sort mechanism. But instead of scanning elements one-by-one, it uses a sequence.</li>
        <li>Example of a sequence: N/2, N/4, N/8 where N is size of the list.</li>
        <li>➁ So after each iteration, elements at particular intervals (based on sequence) are sorted.</li>
      </ul>
    </div>
    <div class="section">
      <h2>Time Complexity</h2>
      <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse; width: 95%; text-align: center;">
  <thead>
    <tr>
      <th>Algorithm</th>
      <th>Best case</th>
      <th>Average case</th>
      <th>Worst case</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Bubble Sort</td>
      <td>O(n)</td>
      <td>O(n²)</td>
      <td>O(n²)</td>
    </tr>
    <tr>
      <td>Selection Sort</td>
      <td>O(n²)</td>
      <td>O(n²)</td>
      <td>O(n²)</td>
    </tr>
    <tr>
      <td>Insertion Sort</td>
      <td>O(n)</td>
      <td>O(n²)</td>
      <td>O(n²)</td>
    </tr>
    <tr>
      <td>Merge Sort</td>
      <td>O(n*logn)</td>
      <td>O(n*logn)</td>
      <td>O(n*logn)</td>
    </tr>
    <tr>
      <td>Quick Sort</td>
      <td>O(n*logn)</td>
      <td>O(n*logn)</td>
      <td>O(n²)</td>
    </tr>
    <tr>
      <td>Counting Sort</td>
      <td>O(n+k)</td>
      <td>O(n+k)</td>
      <td>O(n+k)</td>
    </tr>
    <tr>
      <td>Radix Sort</td>
      <td>O(n+k)</td>
      <td>O(n+k)</td>
      <td>O(n+k)</td>
    </tr>
    <tr>
      <td>Bucket Sort</td>
      <td>O(n+k)</td>
      <td>O(n)</td>
      <td>O(n²)</td>
    </tr>
    <tr>
      <td>Heap Sort</td>
      <td>O(n*logn)</td>
      <td>O(n*logn)</td>
      <td>O(n*logn)</td>
    </tr>
    <tr>
      <td>Shell Sort</td>
      <td>O(n*logn)</td>
      <td>O(n*logn)</td>
      <td>O(n²)</td>
    </tr>
  </tbody>
</table>

    </div>
    <div class="section">
      <h2>Space Complexity</h2>
      <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse; width: 95%; text-align: center;">
  <thead>
    <tr>
      <th>Algoritma</th>
      <th>Uzay Karmaşıklığı</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>➀ Bubble Sort</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>➁ Selection Sort</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>➂ Insertion Sort</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>➃ Merge Sort</td>
      <td>O(n)</td>
    </tr>
    <tr>
      <td>➄ Quick Sort</td>
      <td>O(logn)</td>
    </tr>
    <tr>
      <td>➅ Counting Sort</td>
      <td>O(max)</td>
    </tr>
    <tr>
      <td>➆ Radix Sort</td>
      <td>O(max)</td>
    </tr>
    <tr>
      <td>➇ Bucket Sort</td>
      <td>O(n+k)</td>
    </tr>
    <tr>
      <td>➈ Heap Sort</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>➉ Shell Sort</td>
      <td>O(1)</td>
    </tr>
  </tbody>
</table>


    </div>

  </div>

  <div id="turkishContent" class="content">
    <h1>Sıralama Algoritmaları</h1>

    <div class="section">
      <h2>Bubble Sort</h2>
      <ul>
        <li>➀ İki ardışık eleman karşılaştırılır. İlk eleman ikinci elemandan büyükse yer değiştirilir.</li>
        <li>➁ Her yinelemenin sonunda, listedeki en büyük eleman listenin en sağına gider.</li>
        <li>➂ Bir sonraki yineleme, listedeki son elemanı (örneğin, en büyük elemanı) hariç tutar.</li>
      </ul>
    </div>
    <div class="section">
      <h2>Insertion Sort</h2>
      <ul>
        <li>➀ Listedeki bir eleman seçilir ve ters sırayla kendisinden önceki tüm elemanlarla karşılaştırılır.</li>
        <li>➁ Eğer eleman karşılaştırılan elemandan küçükse, karşılaştırılan eleman sağa kaydırılır. Aksi takdirde eleman, karşılaştırılan elemanın yanına yerleştirilir.</li>
      </ul>
    </div>
        <div class="section">
      <h2>Selection Sort</h2>
      <ul>
        <li>➀ Liste, en küçük elemanı bulmak için taranır.</li>
        <li>➁ Her iterasyonun sonunda, bulunan en küçük eleman listenin ilk elemanıyla yer değiştirilir.</li>
        <li>➂ Bir sonraki iterasyon, listedeki ilk elemanı (yani en küçük elemanı) hariç tutar.</li>
      </ul>
    </div>
    <div class="section">
      <h2>Merge Sort</h2>
      <ul>
        <li>➀ Liste, iki eşit parçaya bölünür. Her bir parça, aynı fonksiyonu çağırarak bir özyinelemeye (recursion) girer.</li>
        <li>➁ Özyineleme sonunda iki sıralı alt listeye sahip olması beklenir.</li>
        <li>➂ İki sıralı alt liste birleştirilerek tam sıralı bir liste oluşturulur.</li>
      </ul>
    </div>
    <div class="section">
      <h2>Quick Sort</h2>
      <ul>
        <li>➀ Bir pivot eleman seçilir ve listedeki uygun bir pozisyonda olup olmadığı kontrol edilir. Küçük elemanlar pivotun soluna, büyük elemanlar ise sağına yerleştirilir.</li>
        <li>➁ Sol ve sağ alt listeler aynı işlemi özyineleme yoluyla yapar.</li>
      </ul>
    </div>
    <div class="section">
      <h2>Counting Sort</h2>
      <ul>
        <li>➀ Liste, maksimum elemanı bulmak için taranır.</li>
        <li>➁ Boyutu (maksimum eleman + 1) olan ve tüm elemanları 0 olan bir sayma listesi oluşturulur.</li>
        <li>➂ Liste taranır ve sayma listesi uygun şekilde güncellenir.</li>
        <li>➃ Sayımlara dayanarak liste sıralanır.</li>
      </ul>
    </div>
    <div class="section">
      <h2>Radix Sort</h2>
      <ul>
        <li>➀ Listedeki maksimum değer bulunur. Kaç basamaklı olduğu tespit edilir.</li>
        <li>➁ Birler basamağından başlayarak, onlar ve yüzler basamağı gibi, elemanlar ilgili basamaklardaki sıralı sayılara göre düzenlenir.</li>
      </ul>
    </div>
    <div class="section">
      <h2>Bucket Sort</h2>
      <ul>
        <li>➀ İlk olarak bir kova listesi oluşturulur. Listedeki her kova, belirli bir aralıktaki elemanları içerebilir.</li>
        <li>➁ Elemanlar kovalar arasında dağıtılır.</li>
        <li>➂ Her kova ayrı ayrı sıralanır (başka bir sıralama tekniğiyle).</li>
        <li>➃ Tüm kovaların elemanları toplanır.</li>
      </ul>
    </div>
    <div class="section">
      <h2>Heap Sort</h2>
      <ul>
        <li>➀ Elemanlar, Min-Heap veya Max-Heap yapısında tutulur.</li>
        <li>➁ Kök eleman, en sağdaki çocuk düğümle değiştirilir ve ardından heap'ten çıkarılır.</li>
        <li>➂ Heap tekrar düzenlenir ve bu işlem heap boşalana kadar devam eder.</li>
      </ul>
    </div>
    <div class="section">
      <h2>Shell Sort</h2>
      <ul>
        <li>➀ Insertion sort sıralama mekanizmasını kullanır. Ancak elemanları tek tek taramak yerine bir dizi kullanır.</li>
        <li>Örneğin bir dizi: N/2, N/4, N/8, burada N listenin boyutudur.</li>
        <li>➁ Her iterasyondan sonra, belirli aralıklardaki (diziye göre) elemanlar sıralanır.</li>
      </ul>
    </div>
    <div class="section">
      <h2>Zaman Karmaşıklığı</h2>
	   <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse; width: 95%; text-align: center;">
  <thead>
    <tr>
      <th>Algoritma</th>
      <th>En İyi Durum</th>
      <th>Ortalama Durum</th>
      <th>En Kötü Durum</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Bubble Sort</td>
      <td>O(n)</td>
      <td>O(n²)</td>
      <td>O(n²)</td>
    </tr>
    <tr>
      <td>Selection Sort</td>
      <td>O(n²)</td>
      <td>O(n²)</td>
      <td>O(n²)</td>
    </tr>
    <tr>
      <td>Insertion Sort</td>
      <td>O(n)</td>
      <td>O(n²)</td>
      <td>O(n²)</td>
    </tr>
    <tr>
      <td>Merge Sort</td>
      <td>O(n*logn)</td>
      <td>O(n*logn)</td>
      <td>O(n*logn)</td>
    </tr>
    <tr>
      <td>Quick Sort</td>
      <td>O(n*logn)</td>
      <td>O(n*logn)</td>
      <td>O(n²)</td>
    </tr>
    <tr>
      <td>Counting Sort</td>
      <td>O(n+k)</td>
      <td>O(n+k)</td>
      <td>O(n+k)</td>
    </tr>
    <tr>
      <td>Radix Sort</td>
      <td>O(n+k)</td>
      <td>O(n+k)</td>
      <td>O(n+k)</td>
    </tr>
    <tr>
      <td>Bucket Sort</td>
      <td>O(n+k)</td>
      <td>O(n)</td>
      <td>O(n²)</td>
    </tr>
    <tr>
      <td>Heap Sort</td>
      <td>O(n*logn)</td>
      <td>O(n*logn)</td>
      <td>O(n*logn)</td>
    </tr>
    <tr>
      <td>Shell Sort</td>
      <td>O(n*logn)</td>
      <td>O(n*logn)</td>
      <td>O(n²)</td>
    </tr>
  </tbody>
</table>
    </div>
    <div class="section">
      <h2>Alan Karmaşıklığı</h2>
      
	  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse; width: 95%; text-align: center;">
  <thead>
    <tr>
      <th>Algoritma</th>
      <th>Uzay Karmaşıklığı</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>➀ Bubble Sort</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>➁ Selection Sort</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>➂ Insertion Sort</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>➃ Merge Sort</td>
      <td>O(n)</td>
    </tr>
    <tr>
      <td>➄ Quick Sort</td>
      <td>O(logn)</td>
    </tr>
    <tr>
      <td>➅ Counting Sort</td>
      <td>O(max)</td>
    </tr>
    <tr>
      <td>➆ Radix Sort</td>
      <td>O(max)</td>
    </tr>
    <tr>
      <td>➇ Bucket Sort</td>
      <td>O(n+k)</td>
    </tr>
    <tr>
      <td>➈ Heap Sort</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>➉ Shell Sort</td>
      <td>O(1)</td>
    </tr>
  </tbody>
</table>

    </div>

  </div>

  <script>
    const toggleButton = document.getElementById("toggleLang");
    const englishContent = document.getElementById("englishContent");
    const turkishContent = document.getElementById("turkishContent");

    toggleButton.addEventListener("click", () => {
      const isEnglishActive = englishContent.classList.contains("active");

      if (isEnglishActive) {
        englishContent.classList.remove("active");
        turkishContent.classList.add("active");
        toggleButton.textContent = "English";
      } else {
        turkishContent.classList.remove("active");
        englishContent.classList.add("active");
        toggleButton.textContent = "Türkçe";
      }
    });
  </script>
</body>
</html>
