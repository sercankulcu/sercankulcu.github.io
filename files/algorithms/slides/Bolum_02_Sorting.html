<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorting Algorithms</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 10px auto;
            background-color: #f4f4f9;
            max-width: 800px;
            justify-content: center;
            align-items: center;
            background-color: #f0f0f0;
        }

        .header {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1vw;
        }

        h1 {
            margin: auto;
        }

        .back-button {
            cursor: pointer;
            text-decoration: none;
        }

        .back-button:hover {
            text-decoration: underline;
        }

        .content {
            display: none;
        }

        .content.active {
            display: block;
        }

        .section {
            margin-bottom: 10px;
        }

        .section h2 {
            margin-bottom: 10px;
        }

        ul {
            margin: 0;
            padding: 0 10px;
        }

        li {
            margin-bottom: 5px;
        }

        .container {
            text-align: center;
            background-color: white;
            padding: 5px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .array-container {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            height: 300px;
            margin-bottom: 10px;
        }

        .array-bar-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0 2px;
        }

        .array-bar {
            width: min(3vw, 30px);
            background-color: #3498db;
            transition: height 0.5s ease;
        }

        .array-bar-value {
            font-size: min(2vw, 16px);
            margin-top: 3px;
        }

        .array-bar.comparing {
            background-color: #e74c3c;
        }

        .array-bar.sorted {
            background-color: #2ecc71;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        select,
        button {
            padding: 10px;
            font-size: min(3vw, 16px);
        }

        #logContainer {
            text-align: left;
            max-height: 200px;
            overflow-y: auto;
            background-color: #f8f8f8;
            padding: 10px;
            border-radius: 5px;
            font-size: min(3vw, 16px);
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 5px;
            border-radius: 3px;
        }

        .log-entry.highlight {
            background-color: #ffff99;
            font-weight: bold;
        }
    </style>
</head>

<body>
    <button id="toggleLang">Türkçe</button>

    <div id="englishContent" class="content active">
        <div class="header">
            <a href="https://sercankulcu.github.io/teaching/algorithms" class="back-button">&larr; Back</a>
            <h1>Sorting Algorithms</h1>
        </div>

        <div class="section">
            <h2>Bubble Sort</h2>
            <ul>
                <li>➀ Compare 2 consecutive elements. Swap if 1st one is larger than 2nd one.</li>
                <li>➁ At the end of each iteration, largest element in the list bubbles up to the top of the list.</li>
                <li>➂ The next iteration excludes the last element (i.e., largest element) in the list.</li>
            </ul>
        </div>
        <div class="section">
            <h2>Insertion Sort</h2>
            <ul>
                <li>➀ An element in the list is picked and compared with all other elements prior to it in reverse
                    order.</li>
                <li>➁ If the element is smaller than the compared element, later is shifted to the right. Or else the
                    element is
                    inserted next to the compared element.</li>
            </ul>
        </div>
        <div class="section">
            <h2>Selection Sort</h2>
            <ul>
                <li>➀ The list is scanned for the smallest element.</li>
                <li>➁ At the end of each iteration, this smallest element is swapped with the first element in the list.
                </li>
                <li>➂ The next iteration excludes the first element (i.e., smallest element) in the list.</li>
            </ul>
        </div>
        <div class="section">
            <h2>Merge Sort</h2>
            <ul>
                <li>➀ A list is divided into 2 equal halves. Each half goes for a recursion (calling same function).
                </li>
                <li>➁ It is expected to have 2 sorted sublists at the end of recursion.</li>
                <li>➂ Merge 2 sorted sublists to form a full sorted list.</li>
            </ul>
        </div>
        <div class="section">
            <h2>Quick Sort</h2>
            <ul>
                <li>➀ A pivot element is chosen and checked for an appropriate position in the list such that smaller
                    elements
                    are left to it and larger elements are right to it.</li>
                <li>➁ The left and right sublists do the same through recursion.</li>
            </ul>
        </div>
        <div class="section">
            <h2>Counting Sort</h2>
            <ul>
                <li>➀ The list is scanned for the maximum element.</li>
                <li>➁ Another list (count list) is created of size (max element + 1) with all 0s.</li>
                <li>➂ The list is traversed and the count list is updated accordingly with an appropriate count.</li>
                <li>➃ Based on counts, the list is sorted.</li>
            </ul>
        </div>
        <div class="section">
            <h2>Radix Sort</h2>
            <ul>
                <li>➀ Find the max value in the list. Find out how many digits it has.</li>
                <li>➁ Starting from units, then to tens and hundreds, etc., arrange the elements based on sorted numbers
                    in that
                    digit place.</li>
            </ul>
        </div>
        <div class="section">
            <h2>Bucket Sort</h2>
            <ul>
                <li>➀ First a bucket list is created. Each bucket in the list can contain elements of a certain range.
                </li>
                <li>➁ Elements are scattered in buckets.</li>
                <li>➂ Each bucket is sorted (other sorting technique).</li>
                <li>➃ Elements from all buckets are gathered.</li>
            </ul>
        </div>
        <div class="section">
            <h2>Heap Sort</h2>
            <ul>
                <li>➀ Elements are kept in heap either in Min-Heap or Max-Heap.</li>
                <li>➁ The root is swapped with the rightmost child node and, then removed from the heap.</li>
                <li>➂ Then the heap is heapified and this process continues till the heap is empty.</li>
            </ul>
        </div>
        <div class="section">
            <h2>Shell Sort</h2>
            <ul>
                <li>➀ It uses insertion sort mechanism. But instead of scanning elements one-by-one, it uses a sequence.
                </li>
                <li>Example of a sequence: N/2, N/4, N/8 where N is size of the list.</li>
                <li>➁ So after each iteration, elements at particular intervals (based on sequence) are sorted.</li>
            </ul>
        </div>

        <div class="section">
            <h2>Time Complexity</h2>
            <table border="1" cellpadding="5" cellspacing="0"
                style="border-collapse: collapse; width: 95%; text-align: center; margin: auto;">
                <thead>
                    <tr>
                        <th>Algorithm</th>
                        <th>Best case</th>
                        <th>Average case</th>
                        <th>Worst case</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Bubble Sort</td>
                        <td>O(n)</td>
                        <td>O(n²)</td>
                        <td>O(n²)</td>
                    </tr>
                    <tr>
                        <td>Selection Sort</td>
                        <td>O(n²)</td>
                        <td>O(n²)</td>
                        <td>O(n²)</td>
                    </tr>
                    <tr>
                        <td>Insertion Sort</td>
                        <td>O(n)</td>
                        <td>O(n²)</td>
                        <td>O(n²)</td>
                    </tr>
                    <tr>
                        <td>Merge Sort</td>
                        <td>O(n*logn)</td>
                        <td>O(n*logn)</td>
                        <td>O(n*logn)</td>
                    </tr>
                    <tr>
                        <td>Quick Sort</td>
                        <td>O(n*logn)</td>
                        <td>O(n*logn)</td>
                        <td>O(n²)</td>
                    </tr>
                    <tr>
                        <td>Counting Sort</td>
                        <td>O(n+k)</td>
                        <td>O(n+k)</td>
                        <td>O(n+k)</td>
                    </tr>
                    <tr>
                        <td>Radix Sort</td>
                        <td>O(n+k)</td>
                        <td>O(n+k)</td>
                        <td>O(n+k)</td>
                    </tr>
                    <tr>
                        <td>Bucket Sort</td>
                        <td>O(n+k)</td>
                        <td>O(n)</td>
                        <td>O(n²)</td>
                    </tr>
                    <tr>
                        <td>Heap Sort</td>
                        <td>O(n*logn)</td>
                        <td>O(n*logn)</td>
                        <td>O(n*logn)</td>
                    </tr>
                    <tr>
                        <td>Shell Sort</td>
                        <td>O(n*logn)</td>
                        <td>O(n*logn)</td>
                        <td>O(n²)</td>
                    </tr>
                </tbody>
            </table>

        </div>
        <div class="section">
            <h2>Space Complexity</h2>
            <table border="1" cellpadding="5" cellspacing="0"
                style="border-collapse: collapse; width: 95%; text-align: center; margin: auto;">
                <thead>
                    <tr>
                        <th>Algoritma</th>
                        <th>Uzay Karmaşıklığı</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>➀ Bubble Sort</td>
                        <td>O(1)</td>
                    </tr>
                    <tr>
                        <td>➁ Selection Sort</td>
                        <td>O(1)</td>
                    </tr>
                    <tr>
                        <td>➂ Insertion Sort</td>
                        <td>O(1)</td>
                    </tr>
                    <tr>
                        <td>➃ Merge Sort</td>
                        <td>O(n)</td>
                    </tr>
                    <tr>
                        <td>➄ Quick Sort</td>
                        <td>O(logn)</td>
                    </tr>
                    <tr>
                        <td>➅ Counting Sort</td>
                        <td>O(max)</td>
                    </tr>
                    <tr>
                        <td>➆ Radix Sort</td>
                        <td>O(max)</td>
                    </tr>
                    <tr>
                        <td>➇ Bucket Sort</td>
                        <td>O(n+k)</td>
                    </tr>
                    <tr>
                        <td>➈ Heap Sort</td>
                        <td>O(1)</td>
                    </tr>
                    <tr>
                        <td>➉ Shell Sort</td>
                        <td>O(1)</td>
                    </tr>
                </tbody>
            </table>


        </div>

    </div>

    <div id="turkishContent" class="content">
        <h1>Sıralama Algoritmaları</h1>

        <div class="section">
            <h2>Bubble Sort</h2>
            <ul>
                <li>➀ İki ardışık eleman karşılaştırılır. İlk eleman ikinci elemandan büyükse yer değiştirilir.</li>
                <li>➁ Her yinelemenin sonunda, listedeki en büyük eleman listenin en sağına gider.</li>
                <li>➂ Bir sonraki yineleme, listedeki son elemanı (örneğin, en büyük elemanı) hariç tutar.</li>
            </ul>
        </div>
        <div class="section">
            <h2>Insertion Sort</h2>
            <ul>
                <li>➀ Listedeki bir eleman seçilir ve ters sırayla kendisinden önceki tüm elemanlarla karşılaştırılır.
                </li>
                <li>➁ Eğer eleman karşılaştırılan elemandan küçükse, karşılaştırılan eleman sağa kaydırılır. Aksi
                    takdirde
                    eleman, karşılaştırılan elemanın yanına yerleştirilir.</li>
            </ul>
        </div>
        <div class="section">
            <h2>Selection Sort</h2>
            <ul>
                <li>➀ Liste, en küçük elemanı bulmak için taranır.</li>
                <li>➁ Her iterasyonun sonunda, bulunan en küçük eleman listenin ilk elemanıyla yer değiştirilir.</li>
                <li>➂ Bir sonraki iterasyon, listedeki ilk elemanı (yani en küçük elemanı) hariç tutar.</li>
            </ul>
        </div>
        <div class="section">
            <h2>Merge Sort</h2>
            <ul>
                <li>➀ Liste, iki eşit parçaya bölünür. Her bir parça, aynı fonksiyonu çağırarak bir özyinelemeye
                    (recursion)
                    girer.</li>
                <li>➁ Özyineleme sonunda iki sıralı alt listeye sahip olması beklenir.</li>
                <li>➂ İki sıralı alt liste birleştirilerek tam sıralı bir liste oluşturulur.</li>
            </ul>
        </div>
        <div class="section">
            <h2>Quick Sort</h2>
            <ul>
                <li>➀ Bir pivot eleman seçilir ve listedeki uygun bir pozisyonda olup olmadığı kontrol edilir. Küçük
                    elemanlar
                    pivotun soluna, büyük elemanlar ise sağına yerleştirilir.</li>
                <li>➁ Sol ve sağ alt listeler aynı işlemi özyineleme yoluyla yapar.</li>
            </ul>
        </div>
        <div class="section">
            <h2>Counting Sort</h2>
            <ul>
                <li>➀ Liste, maksimum elemanı bulmak için taranır.</li>
                <li>➁ Boyutu (maksimum eleman + 1) olan ve tüm elemanları 0 olan bir sayma listesi oluşturulur.</li>
                <li>➂ Liste taranır ve sayma listesi uygun şekilde güncellenir.</li>
                <li>➃ Sayımlara dayanarak liste sıralanır.</li>
            </ul>
        </div>
        <div class="section">
            <h2>Radix Sort</h2>
            <ul>
                <li>➀ Listedeki maksimum değer bulunur. Kaç basamaklı olduğu tespit edilir.</li>
                <li>➁ Birler basamağından başlayarak, onlar ve yüzler basamağı gibi, elemanlar ilgili basamaklardaki
                    sıralı
                    sayılara göre düzenlenir.</li>
            </ul>
        </div>
        <div class="section">
            <h2>Bucket Sort</h2>
            <ul>
                <li>➀ İlk olarak bir kova listesi oluşturulur. Listedeki her kova, belirli bir aralıktaki elemanları
                    içerebilir.
                </li>
                <li>➁ Elemanlar kovalar arasında dağıtılır.</li>
                <li>➂ Her kova ayrı ayrı sıralanır (başka bir sıralama tekniğiyle).</li>
                <li>➃ Tüm kovaların elemanları toplanır.</li>
            </ul>
        </div>
        <div class="section">
            <h2>Heap Sort</h2>
            <ul>
                <li>➀ Elemanlar, Min-Heap veya Max-Heap yapısında tutulur.</li>
                <li>➁ Kök eleman, en sağdaki çocuk düğümle değiştirilir ve ardından heap'ten çıkarılır.</li>
                <li>➂ Heap tekrar düzenlenir ve bu işlem heap boşalana kadar devam eder.</li>
            </ul>
        </div>
        <div class="section">
            <h2>Shell Sort</h2>
            <ul>
                <li>➀ Insertion sort sıralama mekanizmasını kullanır. Ancak elemanları tek tek taramak yerine bir dizi
                    kullanır.
                </li>
                <li>Örneğin bir dizi: N/2, N/4, N/8, burada N listenin boyutudur.</li>
                <li>➁ Her iterasyondan sonra, belirli aralıklardaki (diziye göre) elemanlar sıralanır.</li>
            </ul>
        </div>

        <div class="section">
            <h2>Zaman Karmaşıklığı</h2>
            <table border="1" cellpadding="5" cellspacing="0"
                style="border-collapse: collapse; width: 95%; text-align: center; margin: auto;">
                <thead>
                    <tr>
                        <th>Algoritma</th>
                        <th>En İyi Durum</th>
                        <th>Ortalama Durum</th>
                        <th>En Kötü Durum</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Bubble Sort</td>
                        <td>O(n)</td>
                        <td>O(n²)</td>
                        <td>O(n²)</td>
                    </tr>
                    <tr>
                        <td>Selection Sort</td>
                        <td>O(n²)</td>
                        <td>O(n²)</td>
                        <td>O(n²)</td>
                    </tr>
                    <tr>
                        <td>Insertion Sort</td>
                        <td>O(n)</td>
                        <td>O(n²)</td>
                        <td>O(n²)</td>
                    </tr>
                    <tr>
                        <td>Merge Sort</td>
                        <td>O(n*logn)</td>
                        <td>O(n*logn)</td>
                        <td>O(n*logn)</td>
                    </tr>
                    <tr>
                        <td>Quick Sort</td>
                        <td>O(n*logn)</td>
                        <td>O(n*logn)</td>
                        <td>O(n²)</td>
                    </tr>
                    <tr>
                        <td>Counting Sort</td>
                        <td>O(n+k)</td>
                        <td>O(n+k)</td>
                        <td>O(n+k)</td>
                    </tr>
                    <tr>
                        <td>Radix Sort</td>
                        <td>O(n+k)</td>
                        <td>O(n+k)</td>
                        <td>O(n+k)</td>
                    </tr>
                    <tr>
                        <td>Bucket Sort</td>
                        <td>O(n+k)</td>
                        <td>O(n)</td>
                        <td>O(n²)</td>
                    </tr>
                    <tr>
                        <td>Heap Sort</td>
                        <td>O(n*logn)</td>
                        <td>O(n*logn)</td>
                        <td>O(n*logn)</td>
                    </tr>
                    <tr>
                        <td>Shell Sort</td>
                        <td>O(n*logn)</td>
                        <td>O(n*logn)</td>
                        <td>O(n²)</td>
                    </tr>
                </tbody>
            </table>
        </div>
        <div class="section">
            <h2>Alan Karmaşıklığı</h2>

            <table border="1" cellpadding="5" cellspacing="0"
                style="border-collapse: collapse; width: 95%; text-align: center; margin: auto;">
                <thead>
                    <tr>
                        <th>Algoritma</th>
                        <th>Uzay Karmaşıklığı</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>➀ Bubble Sort</td>
                        <td>O(1)</td>
                    </tr>
                    <tr>
                        <td>➁ Selection Sort</td>
                        <td>O(1)</td>
                    </tr>
                    <tr>
                        <td>➂ Insertion Sort</td>
                        <td>O(1)</td>
                    </tr>
                    <tr>
                        <td>➃ Merge Sort</td>
                        <td>O(n)</td>
                    </tr>
                    <tr>
                        <td>➄ Quick Sort</td>
                        <td>O(logn)</td>
                    </tr>
                    <tr>
                        <td>➅ Counting Sort</td>
                        <td>O(max)</td>
                    </tr>
                    <tr>
                        <td>➆ Radix Sort</td>
                        <td>O(max)</td>
                    </tr>
                    <tr>
                        <td>➇ Bucket Sort</td>
                        <td>O(n+k)</td>
                    </tr>
                    <tr>
                        <td>➈ Heap Sort</td>
                        <td>O(1)</td>
                    </tr>
                    <tr>
                        <td>➉ Shell Sort</td>
                        <td>O(1)</td>
                    </tr>
                </tbody>
            </table>

        </div>

    </div>

    <div class="container">
        <div class="array-container" id="arrayContainer"></div>
        <div class="controls">
            <select id="algorithmSelect">
                <option value="bubble">Bubble Sort</option>
                <option value="insertion">Insertion Sort</option>
                <option value="selection">Selection Sort</option>
                <option value="merge">Merge Sort</option>
                <option value="quick">Quick Sort</option>
                <option value="counting">Counting Sort</option>
                <option value="radix">Radix Sort</option>
                <option value="bucket">Bucket Sort</option>
                <option value="heap">Heap Sort</option>
                <option value="shell">Shell Sort</option>
            </select>
            <button id="generateArrayBtn">New Array</button>
            <button id="sortBtn">Sort</button>
        </div>
        <div id="logContainer"></div>
    </div>

    <script>
        const toggleButton = document.getElementById("toggleLang");
        const englishContent = document.getElementById("englishContent");
        const turkishContent = document.getElementById("turkishContent");

        toggleButton.addEventListener("click", () => {
            const isEnglishActive = englishContent.classList.contains("active");

            if (isEnglishActive) {
                englishContent.classList.remove("active");
                turkishContent.classList.add("active");
                toggleButton.textContent = "English";
            } else {
                turkishContent.classList.remove("active");
                englishContent.classList.add("active");
                toggleButton.textContent = "Türkçe";
            }
        });

        let simulationArraySize = 16;
        let timeoutDuration = 500;
        // Sorting Algorithms
        async function bubbleSort(array, updateVisualization) {
            const n = array.length;
            for (let i = 0; i < n - 1; i++) {
                for (let j = 0; j < n - i - 1; j++) {
                    updateVisualization(array, [j, j + 1]);
                    await new Promise(resolve => setTimeout(resolve, timeoutDuration));

                    if (array[j] > array[j + 1]) {
                        [array[j], array[j + 1]] = [array[j + 1], array[j]];
                    }
                }
                updateVisualization(array, [], Array.from({ length: i + 1 }, (_, k) => n - k - 1));
            }
            updateVisualization(array, [], Array.from({ length: n }, (_, k) => k));
            return array;
        }

        async function insertionSort(array, updateVisualization) {
            const n = array.length;
            for (let i = 1; i < n; i++) {
                let key = array[i];
                let j = i - 1;

                while (j >= 0 && array[j] > key) {
                    updateVisualization(array, [j, j + 1]);
                    await new Promise(resolve => setTimeout(resolve, timeoutDuration));

                    array[j + 1] = array[j];
                    j--;
                }
                array[j + 1] = key;
                updateVisualization(array, [], Array.from({ length: i + 1 }, (_, k) => k));
            }
            updateVisualization(array, [], Array.from({ length: n }, (_, k) => k));
            return array;
        }

        async function selectionSort(array, updateVisualization) {
            const n = array.length;
            for (let i = 0; i < n - 1; i++) {
                let minIdx = i;
                for (let j = i + 1; j < n; j++) {
                    updateVisualization(array, [minIdx, j]);
                    await new Promise(resolve => setTimeout(resolve, timeoutDuration));

                    if (array[j] < array[minIdx]) {
                        minIdx = j;
                    }
                }
                if (minIdx !== i) {
                    [array[i], array[minIdx]] = [array[minIdx], array[i]];
                }
                updateVisualization(array, [], Array.from({ length: i + 1 }, (_, k) => k));
            }
            updateVisualization(array, [], Array.from({ length: n }, (_, k) => k));
            return array;
        }

        async function mergeSort(array, updateVisualization) {
            const merge = async (arr, l, m, r) => {
                const n1 = m - l + 1;
                const n2 = r - m;
                const left = new Array(n1);
                const right = new Array(n2);

                for (let i = 0; i < n1; i++) left[i] = arr[l + i];
                for (let j = 0; j < n2; j++) right[j] = arr[m + 1 + j];

                let i = 0, j = 0, k = l;
                while (i < n1 && j < n2) {
                    updateVisualization(arr, [l + i, m + 1 + j]);
                    await new Promise(resolve => setTimeout(resolve, timeoutDuration));

                    if (left[i] <= right[j]) {
                        arr[k] = left[i];
                        i++;
                    } else {
                        arr[k] = right[j];
                        j++;
                    }
                    k++;
                }

                while (i < n1) {
                    arr[k] = left[i];
                    i++;
                    k++;
                }

                while (j < n2) {
                    arr[k] = right[j];
                    j++;
                    k++;
                }
            };

            const mergeSortRecursive = async (arr, l, r) => {
                if (l < r) {
                    const m = Math.floor(l + (r - l) / 2);
                    await mergeSortRecursive(arr, l, m);
                    await mergeSortRecursive(arr, m + 1, r);
                    await merge(arr, l, m, r);
                    updateVisualization(arr, [], Array.from({ length: r + 1 - l }, (_, k) => l + k));
                }
            };

            await mergeSortRecursive(array, 0, array.length - 1);
            updateVisualization(array, [], Array.from({ length: array.length }, (_, k) => k));
            return array;
        }

        async function quickSort(array, updateVisualization) {
            const partition = async (arr, low, high) => {
                const pivot = arr[high];
                let i = low - 1;

                for (let j = low; j < high; j++) {
                    updateVisualization(arr, [j, high]);
                    await new Promise(resolve => setTimeout(resolve, timeoutDuration));

                    if (arr[j] < pivot) {
                        i++;
                        [arr[i], arr[j]] = [arr[j], arr[i]];
                    }
                }
                [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
                return i + 1;
            };

            const quickSortRecursive = async (arr, low, high) => {
                if (low < high) {
                    const pi = await partition(arr, low, high);
                    updateVisualization(arr, [], [pi]);
                    await quickSortRecursive(arr, low, pi - 1);
                    await quickSortRecursive(arr, pi + 1, high);
                }
            };

            await quickSortRecursive(array, 0, array.length - 1);
            updateVisualization(array, [], Array.from({ length: array.length }, (_, k) => k));
            return array;
        }

        async function countingSort(array, updateVisualization) {
            const max = Math.max(...array);
            const min = Math.min(...array);
            const range = max - min + 1;
            const count = new Array(range).fill(0);
            const output = new Array(array.length);

            for (let i = 0; i < array.length; i++) {
                count[array[i] - min]++;
            }

            for (let i = 1; i < count.length; i++) {
                count[i] += count[i - 1];
            }

            for (let i = array.length - 1; i >= 0; i--) {
                updateVisualization(array, [i]);
                await new Promise(resolve => setTimeout(resolve, timeoutDuration));

                output[count[array[i] - min] - 1] = array[i];
                count[array[i] - min]--;
            }

            for (let i = 0; i < array.length; i++) {
                array[i] = output[i];
            }

            updateVisualization(array, [], Array.from({ length: array.length }, (_, k) => k));
            return array;
        }

        async function radixSort(array, updateVisualization) {
            const getMax = (arr) => Math.max(...arr);
            const countingSort = async (arr, exp) => {
                const n = arr.length;
                const output = new Array(n);
                const count = new Array(10).fill(0);

                for (let i = 0; i < n; i++) {
                    const index = Math.floor(arr[i] / exp) % 10;
                    count[index]++;
                }

                for (let i = 1; i < 10; i++) {
                    count[i] += count[i - 1];
                }

                for (let i = n - 1; i >= 0; i--) {
                    updateVisualization(arr, [i]);
                    await new Promise(resolve => setTimeout(resolve, timeoutDuration));

                    const index = Math.floor(arr[i] / exp) % 10;
                    output[count[index] - 1] = arr[i];
                    count[index]--;
                }

                for (let i = 0; i < n; i++) {
                    arr[i] = output[i];
                }
            };

            const max = getMax(array);
            for (let exp = 1; Math.floor(max / exp) > 0; exp *= 10) {
                await countingSort(array, exp);
                updateVisualization(array, [], Array.from({ length: array.length }, (_, k) => k));
            }

            return array;
        }

        async function bucketSort(array, updateVisualization) {
            const n = array.length;
            const buckets = Array.from({ length: 10 }, () => []);
            const min = Math.min(...array);
            const max = Math.max(...array);

            for (let i = 0; i < n; i++) {
                updateVisualization(array, [i]);
                await new Promise(resolve => setTimeout(resolve, timeoutDuration));

                const bucketIndex = Math.floor(((array[i] - min) / (max - min)) * (buckets.length - 1));
                buckets[bucketIndex].push(array[i]);
            }

            for (let i = 0; i < buckets.length; i++) {
                buckets[i].sort((a, b) => a - b);
            }

            let index = 0;
            for (let i = 0; i < buckets.length; i++) {
                for (let j = 0; j < buckets[i].length; j++) {
                    array[index] = buckets[i][j];
                    index++;
                }
            }

            updateVisualization(array, [], Array.from({ length: array.length }, (_, k) => k));
            return array;
        }

        async function heapSort(array, updateVisualization) {
            const heapify = async (arr, n, i) => {
                let largest = i;
                const left = 2 * i + 1;
                const right = 2 * i + 2;

                if (left < n && arr[left] > arr[largest]) {
                    largest = left;
                }

                if (right < n && arr[right] > arr[largest]) {
                    largest = right;
                }

                if (largest !== i) {
                    updateVisualization(arr, [i, largest]);
                    await new Promise(resolve => setTimeout(resolve, timeoutDuration));

                    [arr[i], arr[largest]] = [arr[largest], arr[i]];
                    await heapify(arr, n, largest);
                }
            };

            const n = array.length;
            for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
                await heapify(array, n, i);
            }

            for (let i = n - 1; i > 0; i--) {
                [array[0], array[i]] = [array[i], array[0]];
                await heapify(array, i, 0);
                updateVisualization(array, [], [i]);
            }

            updateVisualization(array, [], Array.from({ length: array.length }, (_, k) => k));
            return array;
        }

        async function shellSort(array, updateVisualization) {
            const n = array.length;
            for (let gap = Math.floor(n / 2); gap > 0; gap = Math.floor(gap / 2)) {
                for (let i = gap; i < n; i++) {
                    const temp = array[i];
                    let j;

                    for (j = i; j >= gap && array[j - gap] > temp; j -= gap) {
                        updateVisualization(array, [j, j - gap]);
                        await new Promise(resolve => setTimeout(resolve, timeoutDuration));

                        array[j] = array[j - gap];
                    }
                    array[j] = temp;
                }
                updateVisualization(array, [], Array.from({ length: n }, (_, k) => k));
            }
            return array;
        }

        // Sorting Visualizer Class
        class SortingVisualizer {
            constructor() {
                this.arrayContainer = document.getElementById('arrayContainer');
                this.algorithmSelect = document.getElementById('algorithmSelect');
                this.generateArrayBtn = document.getElementById('generateArrayBtn');
                this.sortBtn = document.getElementById('sortBtn');
                this.logContainer = document.getElementById('logContainer');

                this.array = [];
                this.algorithms = {
                    bubble: bubbleSort,
                    insertion: insertionSort,
                    selection: selectionSort,
                    merge: mergeSort,
                    quick: quickSort,
                    counting: countingSort,
                    radix: radixSort,
                    bucket: bucketSort,
                    heap: heapSort,
                    shell: shellSort
                };

                this.setupEventListeners();
                this.generateArray(simulationArraySize);
            }

            setupEventListeners() {
                this.generateArrayBtn.addEventListener('click', () => this.generateArray(simulationArraySize));
                this.sortBtn.addEventListener('click', () => this.startSorting());
            }

            generateArray(length = simulationArraySize) {
                this.clearLogs();
                this.array = Array.from({ length }, () => Math.floor(Math.random() * 250) + 10);
                this.renderArray();
                this.log(`Generated new array with ${length} elements`, true);
            }

            renderArray() {
                this.arrayContainer.innerHTML = '';
                const maxValue = Math.max(...this.array);

                this.array.forEach(value => {
                    const wrapper = document.createElement('div');
                    wrapper.classList.add('array-bar-wrapper');

                    const bar = document.createElement('div');
                    bar.classList.add('array-bar');
                    bar.style.height = `${(value / maxValue) * 250}px`;

                    const valueLabel = document.createElement('div');
                    valueLabel.classList.add('array-bar-value');
                    valueLabel.textContent = value;

                    wrapper.appendChild(bar);
                    wrapper.appendChild(valueLabel);
                    this.arrayContainer.appendChild(wrapper);
                });
            }

            async startSorting() {
                const selectedAlgorithm = this.algorithmSelect.value;
                const sortAlgorithm = this.algorithms[selectedAlgorithm];

                if (sortAlgorithm) {
                    this.clearLogs();
                    this.log(`Starting ${selectedAlgorithm} sort`, true);
                    const startTime = performance.now();
                    await sortAlgorithm(this.array, this.updateVisualization.bind(this));
                    const endTime = performance.now();
                    this.log(`${selectedAlgorithm} sort completed in ${(endTime - startTime).toFixed(2)} ms`, true);
                }
            }

            updateVisualization(array, comparing = [], sorted = []) {
                const bars = this.arrayContainer.querySelectorAll('.array-bar');
                const valueLabels = this.arrayContainer.querySelectorAll('.array-bar-value');
                const maxValue = Math.max(...array);

                array.forEach((value, index) => {
                    bars[index].style.height = `${(value / maxValue) * 250}px`;
                    valueLabels[index].textContent = value;
                    bars[index].classList.remove('comparing', 'sorted');
                });

                comparing.forEach(index => {
                    bars[index].classList.add('comparing');
                    this.log(`Comparing elements at indices ${comparing.join(', ')}`, false);
                });

                sorted.forEach(index => {
                    bars[index].classList.add('sorted');
                });
            }

            clearLogs() {
                this.logContainer.innerHTML = '';
            }

            log(message, highlight = false) {
                const existingHighlightedLogs = this.logContainer.querySelectorAll('.log-entry.highlight');
                existingHighlightedLogs.forEach(log => log.remove());

                const logEntry = document.createElement('div');
                logEntry.classList.add('log-entry');
                logEntry.classList.add('highlight');
                logEntry.textContent = `${message}`;

                this.logContainer.appendChild(logEntry);
                this.logContainer.scrollTop = this.logContainer.scrollHeight;
            }
        }

        new SortingVisualizer();
    </script>
</body>

</html>