<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java'da Yaygın 30 Anti-Pattern</title>
    <!-- Prism.js CSS for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            margin: 0;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }

        h1 {
            text-align: center;
            color: #333;
            font-size: 28px;
            margin-bottom: 20px;
        }

        p {
            color: #555;
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .anti-pattern {
            border: 1px solid #ddd;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 5px;
        }

        .anti-pattern h2 {
            color: #2c3e50;
            font-size: 20px;
            margin-bottom: 10px;
        }

        .anti-pattern strong {
            color: #333;
        }

        pre {
            background-color: #f8f8f8;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 14px;
        }

        code {
            font-family: 'Courier New', Courier, monospace;
        }

        .tips {
            margin-top: 30px;
            padding: 15px;
            background-color: #e8f4f8;
            border-radius: 5px;
        }

        .tips h2 {
            color: #2c3e50;
            font-size: 20px;
            margin-bottom: 10px;
        }

        .tips ul {
            list-style-type: disc;
            padding-left: 20px;
            color: #555;
        }

        .tips li {
            margin-bottom: 10px;
        }

        /* Ensure Prism.js styles don't conflict with existing styles */
        pre[class*="language-"] {
            margin: 0;
            padding: 10px;
            border-radius: 5px;
        }

        code[class*="language-"] {
            font-size: 14px;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Java'da Yaygın 30 Anti-Pattern</h1>
        <p>Anti-pattern'ler, yazılım geliştirmede sıkça kullanılan ancak sorunlara yol açan kötü uygulamalardır.
            Aşağıda, Java'da karşılaşılan popüler anti-pattern'ler, açıklamaları, neden sorunlu oldukları, nasıl
            önlenebilecekleri ve kod örnekleri ile verilmiştir.</p>

        <div class="anti-pattern">
            <h2>1. Singleton Kötüye Kullanımı</h2>
            <p>
                Singleton pattern, bir sınıfın yalnızca tek bir örneğinin oluşturulmasını ve bu örneğe global erişim
                sağlanmasını garanti eden bir tasarım desenidir. Ancak, Singleton’ın aşırı veya yanlış kullanımı,
                yazılım tasarımında ciddi sorunlara yol açabilir. Örneğin, bir veritabanı bağlantı yöneticisi, günlük
                (logging) sistemi veya yapılandırma yöneticisi gibi sınıfların Singleton olarak tasarlanması yaygındır,
                ancak bu sınıfların global bir durumda tutulması, uygulamanın farklı bölümleri arasında beklenmedik
                bağımlılıklar yaratır. Singleton, genellikle global değişkenlerin modern bir alternatifi olarak görülse
                de, bu yaklaşım kodun modülerliğini ve test edilebilirliğini tehlikeye atar. Örneğin, bir Singleton
                veritabanı bağlantı sınıfı, uygulamanın test ortamında farklı bir veritabanına bağlanmasını
                zorlaştırabilir, çünkü Singleton örneği sabittir ve değiştirilmesi güçtür. Ayrıca, Singleton’lar,
                özellikle çok iş parçacıklı (multithreaded) ortamlarda, eşzamanlılık sorunlarına yol açabilir; örneğin,
                bir Singleton’ın örneğinin aynı anda birden fazla iş parçığı tarafından başlatılması, yarış koşullarına
                (race conditions) neden olabilir. Singleton kötüye kullanımı, genellikle tasarım sürecinde
                alternatiflerin yeterince değerlendirilmediği veya hızlı bir çözüm arayışında olunduğu durumlarda ortaya
                çıkar. Bu anti-pattern, kodun esnekliğini azaltır ve uzun vadeli bakım süreçlerini karmaşıklaştırır.
            </p>
            <p><strong>Neden Sorunlu?</strong> Singleton’lar, global durum yaratarak Tek Sorumluluk İlkesini (Single
                Responsibility Principle) ihlal eder ve gizli bağımlılıklar oluşturur. Bu, kodun test edilmesini
                zorlaştırır; çünkü testler sırasında Singleton örneğini kontrol etmek veya sahte (mock) bir nesneyle
                değiştirmek karmaşıktır. Ayrıca, Singleton’lar eşzamanlılık (multithreading) ortamlarında güvenli
                olmayan erişimlere yol açabilir, örneğin aynı örneğin farklı kopyalar arasında durum tutarsızlığı
                yaşanabilir. Örnek olarak, bir Singleton veritabanı bağlantısı, birden fazla iş parçacığının aynı
                bağlantıyı paylaşmasıyla çökmelere veya veri bozulmasına sebep olabilir. Ayrıca, Singleton’lar kodun
                yeniden kullanılabilirliğini azaltır ve bakım maliyetlerini artırır, çünkü bağımlılıklar açıkça
                tanımlanmaz.</p>
            <p><strong>Nasıl Önlenir?</strong> Singleton kullanımından mümkün olduğunca kaçınılmalı ve bağımlılık
                enjeksiyonu (Dependency Injection) gibi modern tasarım yaklaşımları tercih edilmelidir. Bağımlılık
                enjeksiyonu, sınıfların ihtiyaç duyduğu nesnelerin dışarıdan sağlanmasını sağlar, böylece test
                edilebilirlik ve esneklik artar. Örneğin, bir veritabanı bağlantısı için Singleton yerine, bağlantı
                nesnesini bir veri kaynağı (DataSource) üzerinden oluşturup enjekte edebilirsiniz. Ayrıca, durum (state)
                yönetimini dikkatle kontrol etmek için fabrika (Factory) veya havuz (Pool) pattern’leri kullanılabilir.
                Eğer Singleton kullanımı zorunluysa, eşzamanlılık sorunlarını önlemek için `volatile` anahtar kelimesi
                veya çift kilitli başlatma (Double-Checked Locking) gibi teknikler uygulanabilir. Kod incelemelerinde
                Singleton’ların gerekliliği sorgulanmalı ve alternatif çözümler değerlendirilmelidir.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
import java.sql.Connection;

public class DatabaseConnection {
    private static DatabaseConnection instance = new DatabaseConnection();
    private Connection conn;

    private DatabaseConnection() {
        // Bağlantı başlatma
        try {
            this.conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/mydb");
        } catch (SQLException e) {
            System.err.println("Bağlantı hatası: " + e.getMessage());
        }
    }

    public static DatabaseConnection getInstance() {
        return instance;
    }

    public Connection getConnection() {
        return conn;
    }
}
// Global durum nedeniyle test edilmesi zor
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
import java.sql.Connection;

public class DatabaseConnection {
    private Connection conn;

    public DatabaseConnection(Connection conn) {
        this.conn = conn;
    }

    public Connection getConnection() {
        return conn;
    }
}

// Bağımlılık enjeksiyonu ile kullanım
Connection conn = dataSource.getConnection(); // DataSource dışardan sağlanır
DatabaseConnection db = new DatabaseConnection(conn);
// Test için sahte bir Connection nesnesi kullanılabilir
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>2. Tanrı Nesnesi (God Object)</h2>
            <p>
                Tanrı nesnesi, bir sınıfın sistemin birden fazla sorumluluğunu üstlenerek çok sayıda farklı işlevi
                yerine getirmesi durumudur. Bu anti-pattern, genellikle bir sınıfın hem iş mantığını, hem veri
                erişimini, hem kullanıcı arayüzü işlemlerini hem de diğer ilgisiz görevleri (örneğin, e-posta gönderimi
                veya günlük kaydı) barındırmasıyla ortaya çıkar. Örneğin, bir `UserManager` sınıfının kullanıcı kimlik
                doğrulama, veritabanı işlemleri, dosya yönetimi ve bildirim gönderimi gibi çeşitli görevleri yapması, bu
                sınıfı bir Tanrı nesnesi haline getirir. Tanrı nesneleri, genellikle projelerin erken aşamalarında,
                tasarımın yeterince modüler planlanmadığı veya aceleyle geliştirme yapıldığı durumlarda oluşur. Ayrıca,
                deneyimsiz geliştiriciler veya mevcut kodu genişletmek yerine yeni işlevleri aynı sınıfa ekleme eğilimi,
                bu anti-pattern’in yaygınlaşmasına katkıda bulunur. Tanrı nesneleri, kod tabanını şişirir, sınıfların
                boyutunu artırır ve modülerlikten uzak bir yapı oluşturur. Bu durum, kodun anlaşılmasını zorlaştırır,
                yeni özelliklerin eklenmesini karmaşık hale getirir ve sistemin genel esnekliğini azaltır. Tanrı
                nesneleri, özellikle büyük ölçekli projelerde, bakım süreçlerini bir kâbusa çevirebilir ve teknik borcun
                hızla birikmesine neden olabilir.
            </p>
            <p><strong>Neden Sorunlu?</strong> Tanrı nesnesi, Tek Sorumluluk İlkesini ihlal eder ve kodun bakımını
                zorlaştırır. Büyük ve karmaşık bir sınıf, yeni geliştiricilerin anlamasını ve hata ayıklamasını
                güçleştirir. Ayrıca, bu sınıflar genellikle birçok bağımlılığa sahiptir, bu da test edilebilirliği
                azaltır ve kodun yeniden kullanılabilirliğini sınırlar. Örneğin, bir Tanrı nesnesi’nin değiştirilmesi,
                sistemin beklenmedik yerlerinde yan etkilere yol açabilir, bu da hata riskini artırır. Performans
                açısından, gereksiz yere büyük sınıflar bellek ve işlemci kaynaklarını verimsiz kullanabilir. Ayrıca, bu
                tür sınıfların genişletilmesi veya değiştirilmesi, kodun esnekliğini kısıtlar ve yeni özellikler
                eklemeyi zorlaştırır.</p>
            <p><strong>Nasıl Önlenir?</strong> Sorumlulukları ayırarak sınıfları küçük, odaklanmış ve tek bir amaca
                hizmet eder hale getirin. Örneğin, kimlik doğrulama için `AuthService`, veritabanı işlemleri için
                `DatabaseService` ve e-posta gönderimi için `EmailService` gibi ayrı sınıflar oluşturun. SOLID
                ilkelerine bağlı kalarak, özellikle Tek Sorumluluk İlkesini uygulayın. Bağımlılık enjeksiyonu kullanarak
                sınıflar arasındaki bağları gevşetin ve modüler bir tasarım benimseyin. Kod inceleme süreçlerinde, bir
                sınıfın çok fazla sorumluluk üstlenip üstlenmediği kontrol edilmelidir. Ayrıca, yeniden düzenleme
                (refactoring) teknikleriyle büyük sınıflar parçalara ayrılabilir. Örneğin, bir sınıfın farklı işlevleri
                ayrı modüllere taşınarak kodun okunabilirliği ve bakımı kolaylaştırılır.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
import java.sql.Connection;

public class UserManager {
    public void authenticateUser(String username, String password) {
        // Kullanıcı doğrulama mantığı
        System.out.println("Kullanıcı doğrulanıyor: " + username);
    }

    public void saveToDatabase(Connection conn, String data) {
        // Veritabanına kaydetme mantığı
        System.out.println("Veri kaydediliyor: " + data);
    }

    public void sendEmail(String recipient, String message) {
        // E-posta gönderme mantığı
        System.out.println("E-posta gönderiliyor: " + recipient);
    }
}
// Çok fazla sorumluluk tek sınıfta
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
import java.sql.Connection;

public class AuthService {
    public void authenticateUser(String username, String password) {
        // Kullanıcı doğrulama mantığı
        System.out.println("Kullanıcı doğrulanıyor: " + username);
    }
}

public class DatabaseService {
    public void saveToDatabase(Connection conn, String data) {
        // Veritabanına kaydetme mantığı
        System.out.println("Veri kaydediliyor: " + data);
    }
}

public class EmailService {
    public void sendEmail(String recipient, String message) {
        // E-posta gönderme mantığı
        System.out.println("E-posta gönderiliyor: " + recipient);
    }
}
// Sorumluluklar ayrıştırılmış
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>3. Spagetti Kod</h2>
            <p>
                Spagetti kod, karmaşık kontrol akışları, iç içe geçmiş döngüler, koşullu ifadeler ve modüler olmayan
                yapıların bir araya gelmesiyle oluşan, okunması ve anlaşılması zor bir kod yapısıdır. Adını, bir tabak
                spagettinin karışık ve düzensiz görünümünden alan bu anti-pattern, genellikle aceleyle yazılmış, kötü
                planlanmış veya yeniden düzenlenmemiş kodlarda ortaya çıkar. Örneğin, bir yöntemin içinde veri
                doğrulama, dosya okuma, iş mantığı işleme ve kullanıcı arayüzü güncelleme gibi birden fazla işlevin bir
                arada bulunması, spagetti kodun tipik bir örneğidir. Spagetti kod, genellikle deneyimsiz
                geliştiricilerin, karmaşık bir sorunu çözmek için yapılandırılmamış bir yaklaşım benimsemesiyle oluşur.
                Ayrıca, proje son teslim tarihlerine yetişme baskısı veya mevcut kodu düzeltmek yerine üzerine ekleme
                yapma alışkanlığı, spagetti kodun yaygınlaşmasına neden olur. Bu tür kodlar, mantıksal akışı takip
                etmeyi zorlaştırır, hata ayıklamayı (debugging) bir kâbus haline getirir ve yeni özelliklerin
                eklenmesini riskli bir sürece dönüştürür. Spagetti kod, özellikle büyük ölçekli veya uzun süreli
                projelerde, teknik borcun hızla birikmesine ve kod tabanının sürdürülemez hale gelmesine yol açar.
            </p>
            <p><strong>Neden Sorunlu?</strong> Spagetti kod, okunabilirliği ve bakımı ciddi şekilde zorlaştırır, çünkü
                kodun akışını takip etmek ve mantığını anlamak güçtür. Bu, hata ayıklamayı (debugging) karmaşık hale
                getirir ve yeni özellikler eklerken hata riskini artırır. Ayrıca, spagetti kod genellikle Tek Sorumluluk
                İlkesini ihlal eder, çünkü birden fazla işlevi tek bir yerde toplar. Bu tür kodlar, test yazımını da
                zorlaştırır, çünkü modüler olmayan yapılar birim testlerini karmaşık hale getirir. Performans açısından,
                gereksiz yere karmaşık kontrol akışları CPU ve bellek kullanımını artırabilir. Uzun vadede, spagetti kod
                içeren projeler teknik borç biriktirir ve geliştirme süreçlerini yavaşlatır.</p>
            <p><strong>Nasıl Önlenir?</strong> Kodu modülerleştirerek ve yöntemleri küçük, tek bir amaca hizmet eden
                parçalara ayırarak spagetti kodun önüne geçilebilir. Her yöntemin yalnızca bir işlevi yerine getirmesi
                sağlanmalıdır (örneğin, veri işleme veya doğrulama). Kodun okunabilirliğini artırmak için anlamlı
                isimlendirmeler kullanılmalı ve iç içe geçmiş yapılar sadeleştirilmelidir. Yeniden düzenleme teknikleri,
                örneğin uzun yöntemleri küçük yardımcı yöntemlere bölmek, spagetti kodu temizlemek için etkilidir.
                Ayrıca, tasarım desenleri (örneğin, Strateji veya Komut pattern’leri) kullanarak karmaşık mantığı
                yapılandırabilirsiniz. Kod incelemelerinde, karmaşık kontrol akışları tespit edilmeli ve
                sadeleştirilmelidir. Test yazımı, kodun modülerliğini zorlayarak spagetti kod oluşumunu engelleyebilir.
            </p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
public class DataProcessor {
    public void process() {
        boolean condition = true;
        if (condition) {
            for (int i = 0; i < 10; i++) {
                System.out.println("İşleniyor: " + i);
                if (i % 2 == 0) {
                    // Karmaşık mantık
                    System.out.println("Çift sayı: " + i);
                } else {
                    // Daha fazla karmaşık mantık
                    System.out.println("Tek sayı: " + i);
                }
            }
        }
    }
}
// Kodun yapısı karmaşık ve okunması zor
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
public class DataProcessor {
    public void process() {
        if (isConditionMet()) {
            processItems();
        }
    }

    private boolean isConditionMet() {
        return true;
    }

    private void processItems() {
        for (int i = 0; i < 10; i++) {
            System.out.println("İşleniyor: " + i);
            processItem(i);
        }
    }

    private void processItem(int i) {
        if (i % 2 == 0) {
            System.out.println("Çift sayı: " + i);
        } else {
            System.out.println("Tek sayı: " + i);
        }
    }
}
// Kod modüler ve okunabilir
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>4. Sihirli Sayılar/Dizeler</h2>
            <p>
                Sihirli sayılar veya dizeler, kod içinde anlamı açıkça belirtilmeden sabit kodlanmış (hard-coded)
                değerlerdir. Bu değerler, kodun bağlamında neyi temsil ettikleri anlaşılmadan kullanılır ve genellikle
                belgelenmez. Örneğin, bir koşullu ifadede `if (status == 42)` gibi bir kullanım, 42’nin ne anlama
                geldiğini belirsiz bırakır; bu değer, bir durum kodu, bir sınır değeri veya başka bir şey olabilir.
                Benzer şekilde, `String role = "admin";` gibi sabit kodlanmış bir dize, "admin" kelimesinin neyi temsil
                ettiğini açıklamaz. Sihirli sayılar ve dizeler, genellikle hızlı geliştirme süreçlerinde veya kodun
                belgelenmesine yeterince önem verilmediğinde ortaya çıkar. Bu anti-pattern, özellikle büyük kod
                tabanlarında veya birden fazla geliştiricinin çalıştığı projelerde sorun yaratır, çünkü değerlerin
                anlamını anlamak için kodun bağlamını derinlemesine incelemek gerekir. Ayrıca, sihirli değerler birden
                fazla yerde kullanıldığında, bir değişikliğin tüm bu yerlerde tutarlı bir şekilde yapılması gerekir, bu
                da bakım süreçlerini karmaşıklaştırır. Sihirli sayılar ve dizeler, kodun okunabilirliğini azaltır, hata
                riskini artırır ve uzun vadede teknik borcun birikmesine neden olur.
            </p>
            <p><strong>Neden Sorunlu?</strong> Sihirli sayılar ve dizeler, kodun anlaşılmasını zorlaştırır, çünkü
                değerlerin neyi temsil ettiği açık değildir. Bu, yeni geliştiricilerin kodu anlamasını ve bakımını
                güçleştirir. Ayrıca, bir sihirli değerin birden fazla yerde kullanılması durumunda, değeri değiştirmek
                için tüm kod taranmalı ve her kullanım güncellenmelidir, bu da hata riskini artırır. Örneğin, `42` aktif
                durumu temsil ediyorsa ve bu değer değişirse, tüm ilgili yerlerde manuel güncelleme gerekir. Performans
                açısından bir etkisi olmasa da, sihirli değerler kodun esnekliğini azaltır ve teknik borcu artırır.
                Ayrıca, bu tür kodlar genellikle kötü belgelenir, bu da uzun vadeli bakım maliyetlerini yükseltir.</p>
            <p><strong>Nasıl Önlenir?</strong> Sihirli sayılar ve dizeler yerine anlamlı isimlere sahip `static final`
                sabitler kullanılmalıdır. Örneğin, `public static final int ACTIVE_STATUS = 42;` gibi bir sabit, kodun
                anlaşılmasını kolaylaştırır ve merkezi bir yerde değiştirilebilir. Sabitler, kodun farklı bölümlerinde
                yeniden kullanılabilir ve bakım sürecini sadeleştirir. Ayrıca, sabitlerin anlamını açıklayan yorumlar
                veya belgeler eklenmelidir. Kod incelemelerinde, sabit kodlanmış değerler tespit edilmeli ve sabitlere
                dönüştürülmelidir. Eğer birden fazla sabit birbiriyle ilişkiliyse, bir `enum` yapısı kullanılarak daha
                yapılandırılmış bir yaklaşım benimsenebilir. Örneğin, durum kodları için `enum Status { ACTIVE, INACTIVE
                }` kullanılabilir.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
public class StatusChecker {
    public boolean isActive(int status) {
        if (status == 42) {
            return true;
        }
        return false;
    }
}
// 42'nin ne anlama geldiği belirsiz
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
public class StatusChecker {
    public static final int ACTIVE_STATUS = 42;

    public boolean isActive(int status) {
        if (status == ACTIVE_STATUS) {
            return true;
        }
        return false;
    }
}
// Sabit anlamlı ve yeniden kullanılabilir
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>5. Erken Optimizasyon</h2>
            <p>
                Erken optimizasyon, bir yazılımın performans sorunları analiz edilmeden veya doğrulanmadan, geliştirme
                sürecinin erken aşamalarında optimize edilmeye çalışılmasıdır. Bu anti-pattern, genellikle
                geliştiricilerin performans kaygısıyla, henüz ihtiyaç duyulmayan veya gerçek bir sorun teşkil etmeyen
                alanlarda karmaşık algoritmalar, özel veri yapıları veya düşük seviyeli optimizasyonlar kullanmasıyla
                ortaya çıkar. Örneğin, bir veri sıralama işlemi için standart `Collections.sort()` yöntemi yerine, henüz
                performans sorunu doğrulanmadan özel bir sıralama algoritması (örneğin, özelleştirilmiş bir QuickSort)
                yazılması erken optimizasyona örnektir. Bu yaklaşım, genellikle “ileride ihtiyaç olabilir” düşüncesiyle
                veya performansın her zaman kritik olduğu varsayımıyla benimsenir. Ancak, erken optimizasyon, kodun
                gereksiz yere karmaşıklaşmasına, geliştirme süresinin uzamasına ve bakım maliyetlerinin artmasına neden
                olur. Ayrıca, optimize edilen alanın gerçek bir performans darboğazı olmayabileceği durumlarda, bu çaba
                tamamen boşa gidebilir. Donald Knuth’un ünlü sözü, “Erken optimizasyon tüm kötülüklerin köküdür,” bu
                anti-pattern’in potansiyel zararlarını vurgular. Erken optimizasyon, özellikle çevik geliştirme
                süreçlerinde, YAGNI (You Aren’t Gonna Need It) ilkesine aykırıdır ve kaynak israfına yol açar.
            </p>
            <p><strong>Neden Sorunlu?</strong> Erken optimizasyon, kodun karmaşıklığını artırır ve bakım maliyetlerini
                yükseltir, çünkü gereksiz yere karmaşık algoritmalar veya yapılar kullanılır. Bu, kodun okunabilirliğini
                azaltır ve hata ayıklamayı zorlaştırır. Ayrıca, erken optimize edilmiş kod genellikle test edilmesi daha
                zordur, çünkü özel çözümler standart kütüphane çözümlerine kıyasla daha az belgelenmiştir. Performans
                açısından, erken optimizasyon genellikle beklenen faydayı sağlamaz, çünkü gerçek performans darboğazları
                farklı yerlerde olabilir. Donald Knuth’un ünlü sözü, “Erken optimizasyon tüm kötülüklerin köküdür,” bu
                anti-pattern’in zararlarını özetler. Ayrıca, erken optimizasyon geliştirme süresini uzatır ve kaynak
                israfına yol açar.</p>
            <p><strong>Nasıl Önlenir?</strong> Performans sorunlarını optimize etmeden önce, VisualVM, JMH veya diğer
                profil oluşturma araçlarıyla gerçek darboğazlar belirlenmelidir. Standart kütüphane çözümleri (örneğin,
                `Collections.sort()`) genellikle optimize edilmiş ve test edilmiştir, bu nedenle öncelikle bu çözümler
                tercih edilmelidir. YAGNI (You Aren’t Gonna Need It) ilkesine bağlı kalarak, yalnızca gerekli özellikler
                geliştirilmelidir. Kod incelemelerinde, gereksiz yere karmaşık algoritmalar veya yapılar sorgulanmalı ve
                sadeleştirilmelidir. Performans optimizasyonu, yalnızca ölçülebilir bir sorun tespit edildiğinde ve bu
                sorunun etkisi doğrulandığında yapılmalıdır. Ayrıca, birim testleri ve performans testleri yazarak
                optimizasyonların etkisi doğrulanabilir.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
import java.util.List;

public class Sorter {
    public void complexSort(List<String> list) {
        // Gereksiz yere karmaşık bir sıralama algoritması
        for (int i = 0; i < list.size(); i++) {
            for (int j = i + 1; j < list.size(); j++) {
                if (list.get(i).compareTo(list.get(j)) > 0) {
                    String temp = list.get(i);
                    list.set(i, list.get(j));
                    list.set(j, temp);
                }
            }
        }
    }
}
// Performans sorunu doğrulanmadan karmaşık kod
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
import java.util.Collections;
import java.util.List;

public class Sorter {
    public void sort(List<String> list) {
        Collections.sort(list);
        // Standart kütüphane kullanımı, optimize ve test edilmiş
    }
}
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>6. İstisna Yutma</h2>
            <p>
                İstisna yutma, bir istisnanın `try-catch` bloğunda yakalanıp hiçbir işlem yapılmadan, loglanmadan veya
                yeniden fırlatılmadan boş bırakılması durumudur. Bu anti-pattern, genellikle geliştiricilerin hataları
                hızlıca "çözmek" istemesi, hata yönetimini ihmal etmesi veya istisnaların önemini küçümsemesi nedeniyle
                ortaya çıkar. Örneğin, bir dosya okuma işlemi sırasında `IOException` yakalanıp boş bir `catch` bloğu
                bırakılırsa, dosyanın neden okunamadığına dair hiçbir bilgi kaydedilmez ve hata gizlenir. İstisna yutma,
                özellikle kritik sistemlerde ciddi sorunlara yol açabilir; örneğin, bir veritabanı işlemi başarısız
                olduğunda hata yutulursa, veri tutarsızlıkları fark edilmeden devam edebilir. Bu anti-pattern,
                genellikle aceleyle yazılmış kodlarda veya hata yönetimi için bir strateji belirlenmemiş projelerde
                görülür. Ayrıca, istisna yutma, hata ayıklamayı (debugging) zorlaştırır, çünkü hatanın kaynağına dair
                hiçbir iz bırakılmaz. Kullanıcı açısından, uygulama beklenmedik şekilde davranabilir veya yanlış
                sonuçlar üretebilir, bu da güvenilirliği ve kullanıcı deneyimini olumsuz etkiler. İstisna yutma, uzun
                vadede teknik borcu artırır ve sistemin sürdürülebilirliğini tehdit eder, çünkü gizlenen hatalar daha
                büyük sorunlara dönüşebilir.
            </p>
            <p><strong>Neden Sorunlu?</strong> İstisna yutma, hataların gizlenmesine neden olur, bu da hata ayıklamayı
                ve sorunların kaynağını bulmayı zorlaştırır. Örneğin, bir dosya okuma işlemi başarısız olduğunda hata
                yutulursa, uygulamanın neden düzgün çalışmadığı anlaşılmaz ve kullanıcıya yanıltıcı sonuçlar dönebilir.
                Bu, sistemin güvenilirliğini azaltır ve kullanıcı deneyimini olumsuz etkiler. Ayrıca, yutulan
                istisnalar, daha ciddi sorunların (örneğin, veri kaybı veya sistem çökmesi) fark edilmeden devam
                etmesine yol açabilir. Performans açısından, istisna yutma doğrudan bir sorun yaratmasa da, hataların
                gizlenmesi uzun vadede teknik borcu artırır ve bakım maliyetlerini yükseltir.</p>
            <p><strong>Nasıl Önlenir?</strong> Yakalanan istisnalar mutlaka loglanmalı veya uygun bir şekilde
                işlenmelidir. Örneğin, SLF4J veya Log4j gibi loglama kütüphaneleri kullanılarak hata detayları
                kaydedilebilir. Eğer istisna uygulamanın akışını kesmemeliyse, loglandıktan sonra uygun bir hata mesajı
                kullanıcıya iletilmelidir. Alternatif olarak, istisna yeniden fırlatılabilir (re-throw) veya özel bir
                istisna türüne dönüştürülebilir. Kod incelemelerinde, boş `catch` blokları tespit edilmeli ve
                düzeltilmelidir. Ayrıca, istisna yönetimi için bir strateji belirlenmeli; örneğin, merkezi bir hata
                işleme mekanizması (exception handler) kullanılabilir. Try-with-resources gibi modern Java özellikleri,
                kaynak yönetimiyle ilgili istisnaların düzgün işlenmesini kolaylaştırır.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
import java.io.IOException;

public class FileReader {
    public void readFile(String path) {
        try {
            // Dosya okuma işlemleri
            Files.readAllBytes(Paths.get(path));
        } catch (IOException e) {
            // İstisna yutuluyor, hata gizleniyor
        }
    }
}
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class FileReader {
    private static final Logger log = LoggerFactory.getLogger(FileReader.class);

    public void readFile(String path) {
        try {
            // Dosya okuma işlemleri
            Files.readAllBytes(Paths.get(path));
        } catch (IOException e) {
            log.error("Dosya okuma hatası: {}", path, e);
            throw new RuntimeException("Dosya okunamadı", e);
        }
    }
}
// Hata loglanıyor ve yeniden fırlatılıyor
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>7. Aşırı Miras Kullanımı</h2>
            <p>
                Aşırı miras kullanımı, nesne yönelimli programlamada kompozisyon yerine mirasın (inheritance) gereksiz
                veya yanlış bir şekilde tercih edilmesi durumudur. Miras, sınıflar arasında "is-a" (bir türdür) ilişkisi
                kurmak için kullanılır; ancak, bu mekanizmanın aşırı kullanımı, sınıflar arasında sıkı bağımlılıklar
                (tight coupling) oluşturur ve kodun esnekliğini azaltır. Örneğin, bir `Dog` sınıfının tüm davranışlarını
                `Mammal` sınıfından miras alması, `Mammal` sınıfındaki değişikliklerin `Dog` sınıfını doğrudan
                etkilemesine neden olur. Bu anti-pattern, genellikle mirasın nesne yönelimli tasarımın temel taşı olduğu
                yanılgısından veya kompozisyonun avantajlarının bilinmemesinden kaynaklanır. Aşırı miras, özellikle
                derin hiyerarşiler oluşturulduğunda (örneğin, bir sınıfın birden fazla üst sınıftan miras alması), kodun
                anlaşılmasını ve bakımını zorlaştırır. Ayrıca, mirasın yanlış kullanımı, Liskov İkame İlkesini (Liskov
                Substitution Principle) ihlal edebilir; örneğin, bir alt sınıf, üst sınıfın beklenen davranışlarını
                değiştirdiğinde, sistemin öngörülemez hale gelmesine yol açabilir. Aşırı miras kullanımı, genellikle
                büyük ölçekli projelerde, sınıfların yeniden düzenlenmesi gerektiğinde veya yeni gereksinimlere uyum
                sağlanması gerektiğinde sorun yaratır. Bu anti-pattern, kodun modülerliğini bozar, test edilebilirliği
                azaltır ve uzun vadede teknik borcu artırır.
            </p>
            <p><strong>Neden Sorunlu?</strong> Aşırı miras, sınıflar arasında sıkı bağımlılıklar (tight coupling)
                oluşturur, bu da kodun esnekliğini ve yeniden kullanılabilirliğini azaltır. Örneğin, bir üst sınıfın
                değişmesi, tüm alt sınıfları etkileyebilir, bu da bakım maliyetlerini artırır. Ayrıca, miras
                hiyerarşileri karmaşıklaştıkça, kodun anlaşılması ve hata ayıklaması zorlaşır. Bu anti-pattern,
                Açık-Kapalı İlkesini (Open-Closed Principle) ihlal edebilir, çünkü mevcut sınıflar yeni gereksinimlere
                uyarlanmak için sık sık değiştirilir. Performans açısından, derin miras hiyerarşileri metod çağrılarının
                çözümünü yavaşlatabilir. Ayrıca, mirasın aşırı kullanımı, test edilebilirliği azaltır, çünkü alt
                sınıflar üst sınıflara sıkı sıkıya bağlıdır.</p>
            <p><strong>Nasıl Önlenir?</strong> Miras yerine kompozisyonu tercih edin; yani, bir sınıfın davranışlarını
                başka bir sınıftan miras almak yerine, bu davranışları ayrı nesneler olarak enjekte edin. Örneğin, `Dog`
                sınıfı `Mammal`’dan miras almak yerine, bir `Behavior` nesnesi kompozisyon yoluyla kullanılabilir.
                Arayüzler (interface) kullanarak davranışları tanımlamak, esnek ve gevşek bağlı tasarımlar oluşturur.
                Liskov İkame İlkesine (Liskov Substitution Principle) uyarak, mirasın yalnızca uygun olduğu durumlarda
                kullanıldığından emin olun. Kod incelemelerinde, derin miras hiyerarşileri sorgulanmalı ve kompozisyonla
                değiştirilmelidir. Ayrıca, tasarım desenleri (örneğin, Strateji veya Dekoratör) kullanılarak mirasa olan
                ihtiyaç azaltılabilir.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
public class Mammal {
    public void move() { System.out.println("Hareket ediyor"); }
}

public class Dog extends Mammal {
    public void bark() { System.out.println("Havlıyor"); }
}
// Miras sıkı bağımlılık yaratıyor
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
public interface Behavior {
    void move();
}

public class MammalBehavior implements Behavior {
    public void move() { System.out.println("Hareket ediyor"); }
}

public class Dog {
    private Behavior behavior;

    public Dog(Behavior behavior) {
        this.behavior = behavior;
    }

    public void move() { behavior.move(); }
    public void bark() { System.out.println("Havlıyor"); }
}
// Kompozisyon esneklik sağlar
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>8. Kopyala-Yapıştır Programlama</h2>
            <p>
                Kopyala-yapıştır programlama, aynı veya benzer kod parçalarının yeniden kullanılabilir bir şekilde
                düzenlenmek yerine, birden fazla yerde kopyalanarak kullanılmasıdır. Bu anti-pattern, genellikle
                geliştiricilerin zaman baskısı altında hızlı bir çözüm üretmeye çalışması, mevcut kodu yeniden
                düzenlemek için yeterli vakit ayırmaması veya modüler tasarım prensiplerine yeterince hakim olmaması
                nedeniyle ortaya çıkar. Örneğin, bir doğrulama mantığının (örneğin, bir giriş dizesinin null olup
                olmadığını ve uzunluğunu kontrol eden bir kod) farklı yöntemlerde veya sınıflarda tekrar tekrar
                kopyalanması, kopyala-yapıştır programlamaya örnektir. Bu yaklaşım, kısa vadede geliştirme süresini
                kısaltıyor gibi görünse de, uzun vadede kod tabanında ciddi sorunlara yol açar. Kopyalanmış kod
                parçaları, birbirinden bağımsız olarak değiştirildiğinde tutarsızlıklar oluşabilir; örneğin, bir hata
                düzeltmesi yalnızca bir kopyada yapılırsa, diğer kopyalar hatalı kalmaya devam eder. Ayrıca,
                kopyala-yapıştır programlama, kod tabanının şişmesine neden olur, çünkü aynı mantık birden fazla yerde
                tekrarlanır. Bu anti-pattern, özellikle büyük projelerde, bakım süreçlerini karmaşıklaştırır, hata
                riskini artırır ve teknik borcun birikmesine yol açar.
            </p>
            <p><strong>Neden Sorunlu?</strong> Kopyala-yapıştır programlama, kod tekrarına (code duplication) neden
                olur, bu da bakım maliyetlerini artırır. Bir hata düzeltilmesi veya mantık değiştirilmesi gerektiğinde,
                tüm kopyalanmış kod parçalarının ayrı ayrı güncellenmesi gerekir, bu da hata riskini artırır. Örneğin,
                bir doğrulama mantığında hata bulunursa, bu mantığın kopyalandığı her yerde düzeltme yapılmalıdır.
                Ayrıca, kod tekrarı, kod tabanının büyümesine ve okunabilirliğin azalmasına yol açar. Performans
                açısından, tekrar eden kod gereksiz yere bellek ve işlemci kaynaklarını tüketebilir. Uzun vadede, bu
                anti-pattern teknik borcu artırır ve projenin sürdürülebilirliğini zorlaştırır.</p>
            <p><strong>Nasıl Önlenir?</strong> Ortak mantığı yeniden kullanılabilir yöntemlere, sınıflara veya modüllere
                ayırın. Örneğin, aynı doğrulama mantığı bir `validate` metodunda toplanabilir ve farklı yerlerde
                çağrılabilir. DRY (Don’t Repeat Yourself) ilkesine bağlı kalarak, kod tekrarından kaçının. Yeniden
                düzenleme teknikleriyle, kopyalanmış kodlar tespit edilip birleştirilmelidir. Ayrıca, yardımcı sınıflar
                (utility classes) veya tasarım desenleri (örneğin, Template Method) kullanılarak ortak mantıklar
                yapılandırılabilir. Kod incelemelerinde, kopyalanmış kod parçaları belirlenmeli ve yeniden
                kullanılabilir hale getirilmelidir. Birim testleri yazmak, kod tekrarını azaltmaya zorlar, çünkü testler
                için de benzer tekrarlar gerekir.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
public class Validator {
    public boolean validateA(String input) {
        if (input != null && input.length() > 5) {
            return true;
        }
        return false;
    }

    public boolean validateB(String input) {
        if (input != null && input.length() > 5) {
            return true;
        }
        return false;
    }
}
// Aynı mantık tekrar ediyor
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
public class Validator {
    private boolean validate(String input) {
        if (input != null && input.length() > 5) {
            return true;
        }
        return false;
    }

    public boolean validateA(String input) {
        return validate(input);
    }

    public boolean validateB(String input) {
        return validate(input);
    }
}
// Ortak mantık yeniden kullanılabilir
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>9. Sabit Kodlanmış Yapılandırma</h2>
            <p>
                Sabit kodlanmış yapılandırma, veritabanı bağlantı bilgileri, dosya yolları, API anahtarları veya diğer
                yapılandırma parametrelerinin kod içinde sabit olarak yazılmasıdır. Örneğin, bir veritabanı bağlantı
                URL’sinin `String dbUrl = "jdbc:mysql://localhost:3306/mydb";` şeklinde kodlanması, bu anti-pattern’e
                örnektir. Bu yaklaşım, genellikle geliştirme sürecinin erken aşamalarında, yapılandırmaların geçici
                olarak sabit kodlanmasıyla başlar ve daha sonra bu geçici çözüm kalıcı hale gelir. Sabit kodlanmış
                yapılandırmalar, uygulamanın farklı ortamlara (örneğin, geliştirme, test, üretim) uyarlanmasını
                zorlaştırır, çünkü her ortam için kodun manuel olarak değiştirilmesi gerekir. Ayrıca, bu anti-pattern
                güvenlik riskleri yaratır; örneğin, bir API anahtarı veya veritabanı şifresi kod içinde açıkça
                yazılırsa, bu bilgiler yanlışlıkla bir sürüm kontrol sistemine (örneğin, Git) yüklendiğinde açığa
                çıkabilir. Sabit kodlanmış yapılandırmalar, özellikle bulut tabanlı veya dağıtık sistemlerde,
                uygulamanın ölçeklenebilirliğini ve taşınabilirliğini ciddi şekilde sınırlar. Bu anti-pattern, bakım
                süreçlerini karmaşıklaştırır, çünkü yapılandırma değişiklikleri için kodun yeniden derlenmesi ve
                dağıtılması gerekir, bu da hata riskini artırır ve geliştirme sürecini yavaşlatır.
            </p>
            <p><strong>Neden Sorunlu?</strong> Sabit kodlanmış yapılandırmalar, kodu esnek olmayan ve güvensiz hale
                getirir. Farklı ortamlar (örneğin, geliştirme, test, üretim) için yapılandırmaları değiştirmek, kodda
                manuel değişiklikler gerektirir, bu da hata riskini artırır. Güvenlik açısından, hassas bilgiler
                (örneğin, API anahtarları, veritabanı şifreleri) kod içinde açıkça yer aldığında, bu bilgiler kolayca
                açığa çıkabilir. Ayrıca, sabit kodlanmış yapılandırmalar, uygulamanın yeniden derlenmesini
                gerektirebilir, bu da dağıtım süreçlerini yavaşlatır. Uzun vadede, bu anti-pattern teknik borcu artırır
                ve sistemin bakımını zorlaştırır.</p>
            <p><strong>Nasıl Önlenir?</strong> Yapılandırmaları kodun dışına taşıyarak, özellik dosyaları (örneğin,
                `application.properties` veya `application.yml`), ortam değişkenleri veya yapılandırma sunucuları
                (örneğin, Spring Cloud Config) kullanılmalıdır. Örneğin, veritabanı bağlantı bilgileri ortam
                değişkenlerinden alınabilir: `System.getenv("DB_URL")`. Bu, farklı ortamlar için yapılandırmaların
                kolayca değiştirilmesini sağlar. Ayrıca, hassas bilgiler için şifreleme veya güvenli depolama
                mekanizmaları (örneğin, HashiCorp Vault) kullanılmalıdır. Kod incelemelerinde, sabit kodlanmış
                yapılandırmalar tespit edilip kaldırılmalıdır. Test ortamlarında, yapılandırmaların dış kaynaklardan
                alındığından emin olunmalıdır. Ayrıca, yapılandırma yönetimi için kütüphaneler (örneğin, Apache Commons
                Configuration) kullanarak süreci otomatikleştirebilirsiniz.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
import java.sql.Connection;
import java.sql.DriverManager;

public class DatabaseConfig {
    public Connection getConnection() {
        String dbUrl = "jdbc:mysql://localhost:3306/mydb";
        String user = "admin";
        String password = "secret";
        try {
            return DriverManager.getConnection(dbUrl, user, password);
        } catch (SQLException e) {
            throw new RuntimeException("Bağlantı hatası", e);
        }
    }
}
// Yapılandırma sabit kodlanmış, değiştirilmesi zor
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
import java.sql.Connection;
import java.sql.DriverManager;

public class DatabaseConfig {
    public Connection getConnection() {
        String dbUrl = System.getenv("DB_URL");
        String user = System.getenv("DB_USER");
        String password = System.getenv("DB_PASSWORD");
        try {
            return DriverManager.getConnection(dbUrl, user, password);
        } catch (SQLException e) {
            throw new RuntimeException("Bağlantı hatası", e);
        }
    }
}
// Yapılandırma ortam değişkenlerinden alınıyor
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>10. Aşırı Senkronizasyon</h2>
            <p>
                Aşırı senkronizasyon, çok iş parçacıklı (multithreaded) uygulamalarda, eşzamanlılık sorunlarını önlemek
                için `synchronized` anahtar kelimesinin gereğinden fazla veya gereksiz yere kullanılmasıdır. Örneğin,
                bir sınıfın tüm yöntemlerinin `synchronized` olarak işaretlenmesi, yalnızca küçük bir kritik bölümün
                (örneğin, bir paylaşılan değişkenin güncellenmesi) korunması gerektiği durumlarda bu anti-pattern’e yol
                açar. Aşırı senkronizasyon, genellikle eşzamanlılık konusunda aşırı temkinli davranan geliştiricilerin
                veya eşzamanlılık gereksinimlerinin yeterince analiz edilmediği durumlarda ortaya çıkar. Bu yaklaşım,
                uygulamanın performansını ciddi şekilde etkileyebilir, çünkü gereksiz kilitler, iş parçacıklarının
                birbirlerini beklemesine ve sistemin tepki süresinin artmasına neden olur. Örneğin, bir sayaç sınıfında,
                yalnızca `count` değişkeninin artırıldığı kısmın senkronize edilmesi gerekirken, tüm yöntemin
                kilitlenmesi, diğer iş parçacıklarının gereksiz yere beklemesine yol açar. Aşırı senkronizasyon,
                özellikle yüksek trafikli sistemlerde veya gerçek zamanlı uygulamalarda ölçeklenebilirlik sorunlarına
                neden olabilir. Ayrıca, bu anti-pattern, kilitlenme (deadlock) veya yarış durumu (race condition) gibi
                eşzamanlılık sorunlarını tamamen ortadan kaldırmaz ve kodun karmaşıklığını artırarak hata ayıklamayı
                zorlaştırabilir.
            </p>
            <p><strong>Neden Sorunlu?</strong> Aşırı senkronizasyon, uygulamanın performansını ciddi şekilde
                düşürebilir, çünkü gereksiz yere çok fazla iş parçacığı (thread) kilitlenir ve bekletilir. Bu, özellikle
                yüksek trafikli sistemlerde ölçeklenebilirlik sorunlarına yol açar. Örneğin, bir yöntemin tamamı
                `synchronized` ise kilit yalnızca diğer iş parçacıklarını yavaşlatmaz, aynı zamanda sistemin genel tepki
                süresini artırır. Ayrıca, aşırı senkronize kod, hata ayıklamayı zorlaştırır, çünkü kilitlenme (deadlock)
                veya yarış durumu (race condition) gibi sorunlar ortaya çıkabilir. Aşırı senkronizasyon, kodun
                karmaşıklığını artırır ve gereksiz yere bakım maliyetlerini yükseltir. Bu anti-pattern, genellikle
                eşzamanlılık ihtiyaçlarının yanlış analiz edilmesiyle sonuçlanır.</p>
            <p><strong>Nasıl Önlenir?</strong> Senkronizasyon yalnızca gerçekten kritik olan bölümlerle sınırlı
                tutulmalıdır. Örneğin, yalnızca bir değişkeni değiştiren kısmı `synchronized` bloğu ile korunabilir.
                `synchronized` yöntemler yerine, daha ince taneli kilitler (fine-grained locking) veya
                `java.util.concurrent` paketindeki `Lock` sınıfları kullanılabilir. Örneğin, `ReentrantLock` daha esnek
                bir kilit mekanizması sunar. Ayrıca, eşzamanlı veri yapıları (örneğin, `ConcurrentHashMap`) kullanarak
                kilit ihtiyacını azaltabilirsiniz. Kod incelemelerinde, gereksiz `synchronized` kullanımları analiz
                edilmeli ve optimize edilmelidir. Performans testleri, senkronizasyonun performans etkisini ölçmek için
                kullanılabilir. Eşzamanlılık sorunlarını çözmek için, immutable (değiştirilemez) nesneler veya aktör
                modeli gibi alternatif yaklaşımlar da değerlendirilmelidir.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
public class Counter {
    private int count = 0;

    public synchronized void increment() {
        // Gereksiz yere tüm yöntem senkronize
        count++;
        System.out.println("Sayaç: " + count);
    }
}
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
public class Counter {
    private int count = 0;
    private final Object lock = new Object();

    public void increment() {
        synchronized (lock) {
            // Yalnızca kritik bölüm senkronize
            count++;
        }
        System.out.println("Sayaç: " + count);
    }
}
// Performans iyileştirildi
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>11. Null Pointer Sıkıntısı</h2>
            <p>
                Null Pointer Sıkıntısı, Java'da `null` değerlerin kötü yönetimi nedeniyle ortaya çıkan sorunları ifade
                eder. `NullPointerException` (NPE), bir nesnenin null olduğu durumda o nesneye erişmeye çalışıldığında
                meydana gelir ve Java'daki en yaygın hatalardan biridir. Bu anti-pattern, genellikle nesnelerin null
                olabileceği durumların yeterince kontrol edilmemesi veya aşırı null kontrolleriyle kodun karmaşık hale
                getirilmesiyle oluşur. Örneğin, bir kullanıcı nesnesinden isim bilgisi alınırken
                `user.getProfile().getName()` gibi zincirleme çağrılar, herhangi bir noktada null değerle karşılaşılırsa
                NPE fırlatır. Bu sorun, özellikle büyük ve karmaşık veri yapılarında veya harici API'lerden gelen
                verilerle çalışırken sıkça görülür. Null Pointer Sıkıntısı, genellikle aceleyle yazılmış kodlarda, null
                güvenliği için bir strateji belirlenmediğinde veya geliştiricilerin null değerlerin olası etkilerini göz
                ardı ettiğinde ortaya çıkar. Aşırı null kontrolleri (`if (obj != null)` gibi), kodu okunmaz ve bakımını
                zor hale getirir, bu da teknik borcu artırır. Ayrıca, null değerlerin yanlış yönetimi, uygulamanın
                beklenmedik şekilde çökmesine veya yanlış sonuçlar üretmesine neden olabilir, bu da kullanıcı deneyimini
                olumsuz etkiler. Modern Java uygulamalarında, bu anti-pattern, null güvenliği sağlayan araçlar (örneğin,
                `Optional`) kullanılmadığında daha belirgin hale gelir.
            </p>
            <p><strong>Neden Sorunlu?</strong> Aşırı null kontrolleri kodu karışık ve okunması zor hale getirir, bu da
                bakım maliyetlerini artırır. Null değerlerin kötü yönetimi, `NullPointerException` hatalarına yol açarak
                uygulamanın çökmesine neden olabilir. Bu, özellikle üretim ortamlarında ciddi sorunlara yol açar ve
                kullanıcı güvenini zedeler. Ayrıca, null kontrollerinin eksikliği veya fazlalığı, kodun tutarlılığını
                bozar ve hata ayıklamayı zorlaştırır. Performans açısından, çok sayıda null kontrolü gereksiz işlem yükü
                oluşturabilir. Uzun vadede, bu anti-pattern teknik borcu artırır ve kod tabanının sürdürülebilirliğini
                zorlaştırır.</p>
            <p><strong>Nasıl Önlenir?</strong> Java 8 ile tanıtılan `Optional` sınıfı kullanılarak null güvenliği
                sağlanabilir. `Optional`, bir değerin mevcut olup olmadığını kontrol etmek için zarif bir yol sunar ve
                zincirleme işlemleri kolaylaştırır. Örneğin,
                `Optional.ofNullable(user).map(User::getProfile).map(Profile::getName)` gibi bir yapı, null
                kontrollerini sadeleştirir. Ayrıca, null değer döndürmekten kaçınmak için varsayılan değerler veya null
                nesne pattern’i (Null Object Pattern) kullanılabilir. Kod incelemelerinde, null kontrollerinin
                tutarlılığı ve gerekliliği kontrol edilmelidir. API tasarımı yapılırken, null döndürmek yerine boş
                koleksiyonlar (`Collections.emptyList()`) veya varsayılan nesneler tercih edilmelidir. Ayrıca, statik
                analiz araçları (örneğin, FindBugs veya SonarQube) potansiyel NPE risklerini tespit etmek için
                kullanılabilir.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
public class UserService {
    public String getUserName(User user) {
        if (user != null && user.getProfile() != null && user.getProfile().getName() != null) {
            return user.getProfile().getName();
        }
        return "Bilinmeyen";
    }
}
// Çok fazla null kontrolü
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
import java.util.Optional;

public class UserService {
    public String getUserName(User user) {
        return Optional.ofNullable(user)
                .map(User::getProfile)
                .map(Profile::getName)
                .orElse("Bilinmeyen");
    }
}
// Optional ile temiz ve güvenli kod
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>12. Katman Sızıntısı</h2>
            <p>
                Katman Sızıntısı, bir yazılım mimarisinde bir katmanın (örneğin, veri erişim katmanı) detaylarının başka
                bir katmana (örneğin, iş mantığı veya sunum katmanı) sızması durumudur. Bu anti-pattern, genellikle
                katmanlar arasında net bir ayrım yapılmadığında veya kapsülleme (encapsulation) prensiplerine
                uyulmadığında ortaya çıkar. Örneğin, bir veri erişim katmanının `ResultSet` gibi düşük seviyeli bir
                veritabanı nesnesini doğrudan iş mantığı katmanına döndürmesi, katman sızıntısına örnektir. Bu durumda,
                iş mantığı katmanı, veritabanı detaylarına (örneğin, SQL sorguları veya bağlantı yönetimi) bağımlı hale
                gelir, bu da kodun modülerliğini ve yeniden kullanılabilirliğini azaltır. Katman sızıntısı, genellikle
                aceleyle geliştirme yapılan projelerde veya mimari tasarımın yeterince planlanmadığı durumlarda görülür.
                Ayrıca, mevcut kodu genişletirken, katman sınırlarını koruma disiplini ihmal edildiğinde bu sorun
                yaygınlaşır. Katman sızıntısı, sistemin bakımını zorlaştırır, çünkü bir katmandaki değişiklikler diğer
                katmanları beklenmedik şekilde etkileyebilir. Örneğin, veritabanı yapısı değiştiğinde, yalnızca veri
                erişim katmanının değil, iş mantığı katmanının da güncellenmesi gerekebilir. Bu anti-pattern, özellikle
                büyük ölçekli veya uzun süreli projelerde, teknik borcun hızla birikmesine ve sistemin esnekliğinin
                azalmasına yol açar.
            </p>
            <p><strong>Neden Sorunlu?</strong> Katman sızıntısı, kapsüllemeyi bozar ve katmanlar arasında sıkı
                bağımlılıklar (tight coupling) oluşturur. Bu, bir katmandaki değişikliklerin diğer katmanları
                etkilemesine neden olur, bakım maliyetlerini artırır ve sistemin esnekliğini azaltır. Örneğin,
                veritabanı teknolojisi değiştiğinde, yalnızca veri erişim katmanı değil, iş mantığı katmanı da yeniden
                yazılmak zorunda kalabilir. Ayrıca, katman sızıntısı, test edilebilirliği zorlaştırır, çünkü katmanlar
                birbirine sıkı sıkıya bağlıdır ve sahte nesneler (mock objects) oluşturmak karmaşıktır. Performans
                açısından, düşük seviyeli detayların üst katmanlara sızması, gereksiz işlem yükü oluşturabilir. Uzun
                vadede, bu anti-pattern teknik borcu artırır ve sistemin sürdürülebilirliğini tehdit eder.</p>
            <p><strong>Nasıl Önlenir?</strong> Katmanlar arasında veri modelleri (DTO - Data Transfer Objects) veya alan
                modelleri (domain models) kullanılarak net bir ayrım sağlanmalıdır. Örneğin, veri erişim katmanı,
                `ResultSet` yerine bir `UserModel` listesi döndürmelidir. Katmanlar arasındaki iletişim, arayüzler
                (interface) veya soyutlamalar aracılığıyla yapılmalıdır. Mimari desenler, örneğin Repository veya
                Service Layer, katman ayrımını güçlendirebilir. Kod incelemelerinde, bir katmanın diğer katmanların
                detaylarına bağımlı olup olmadığı kontrol edilmelidir. Ayrıca, bağımlılık enjeksiyonu (Dependency
                Injection) kullanarak katmanlar arasındaki bağlar gevşetilebilir. Test yazımı, katmanların
                bağımsızlığını zorlayarak sızıntıyı önlemeye yardımcı olur.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
import java.sql.ResultSet;

public class DataAccess {
    public ResultSet getData() {
        // SQL sorgusu çalıştır
        return connection.createStatement().executeQuery("SELECT * FROM users");
    }
}
// Veritabanı detayları üst katmana sızıyor
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
import java.util.List;

public class DataAccess {
    public List<UserModel> getData() {
        // SQL sorgusu çalıştır ve modeli dönüştür
        ResultSet rs = connection.createStatement().executeQuery("SELECT * FROM users");
        List<UserModel> users = new ArrayList<>();
        while (rs.next()) {
            users.add(new UserModel(rs.getString("name")));
        }
        return users;
    }
}
// Katmanlar ayrıştırılmış, model kullanılıyor
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>13. Meşgul Bekleme</h2>
            <p>
                Meşgul Bekleme (Busy Waiting), bir iş parçacığının (thread) bir kaynağı veya durumu kontrol etmek için
                sürekli bir döngüde çalışması ve bu süreçte CPU kaynaklarını israf etmesidir. Bu anti-pattern,
                genellikle bir işlemin tamamlanmasını beklerken, `while` döngüsü içinde bir koşulun kontrol edilmesi ve
                kısa süreli `Thread.sleep()` çağrılarıyla bekleme yapılması şeklinde görülür. Örneğin, bir dosyanın
                hazır olup olmadığını kontrol etmek için `while (!fileReady) { Thread.sleep(100); }` gibi bir kod,
                meşgul beklemeye örnektir. Meşgul bekleme, genellikle eşzamanlılık (concurrency) mekanizmalarının
                (örneğin, `wait()`/`notify()`) yeterince bilinmediği veya yanlış uygulandığı durumlarda ortaya çıkar. Bu
                yaklaşım, CPU'yu gereksiz yere meşgul eder, sistemin performansını düşürür ve özellikle yüksek yük
                altındaki sistemlerde ölçeklenebilirlik sorunlarına yol açar. Ayrıca, meşgul bekleme, enerji tüketimini
                artırır, bu da mobil veya gömülü sistemlerde ciddi bir dezavantajdır. Meşgul bekleme, genellikle
                aceleyle yazılmış kodlarda veya eşzamanlılık gereksinimlerinin iyi analiz edilmediği projelerde görülür.
                Bu anti-pattern, uygulamanın tepki süresini artırabilir, diğer iş parçacıklarının çalışmasını
                engelleyebilir ve sistem kaynaklarının verimsiz kullanılmasına neden olabilir.
            </p>
            <p><strong>Neden Sorunlu?</strong> Meşgul bekleme, CPU kaynaklarını israf eder, çünkü bir iş parçacığı
                sürekli çalışır ve gereksiz yere işlemci döngülerini tüketir. Bu, özellikle yüksek yük altındaki
                sistemlerde performans düşüşüne ve ölçeklenebilirlik sorunlarına yol açar. Ayrıca, meşgul bekleme enerji
                tüketimini artırır, bu da mobil cihazlar veya enerji verimliliği kritik olan sistemler için ciddi bir
                sorundur. Kodun okunabilirliği açısından, meşgul bekleme genellikle karmaşık ve hata yapmaya yatkın
                döngüler içerir, bu da bakım maliyetlerini artırır. Ayrıca, `Thread.sleep()` gibi mekanizmalar, bekleme
                süresini sabit bir değere bağlar, bu da sistemin dinamik ihtiyaçlarına uyum sağlamasını zorlaştırır.</p>
            <p><strong>Nasıl Önlenir?</strong> Meşgul bekleme yerine, Java'nın eşzamanlılık araçları, örneğin `wait()`
                ve `notify()` mekanizmaları kullanılmalıdır. Bu mekanizmalar, bir iş parçacığının bir koşul sağlanana
                kadar askıya alınmasını ve yalnızca gerekli olduğunda uyandırılmasını sağlar. Alternatif olarak,
                `java.util.concurrent` paketindeki `CountDownLatch`, `CyclicBarrier` veya `CompletableFuture` gibi
                yüksek seviyeli yapılar kullanılabilir. Örneğin, bir kaynağın hazır olmasını beklemek için `lock.wait()`
                kullanılabilir. Kod incelemelerinde, döngü tabanlı bekleme yapıları tespit edilip daha verimli
                alternatiflerle değiştirilmelidir. Performans testleri, meşgul beklemenin sistem üzerindeki etkisini
                ölçmek için kullanılabilir. Ayrıca, asenkron programlama modelleri (örneğin, olay tabanlı programlama)
                meşgul beklemeyi tamamen ortadan kaldırabilir.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
public class ResourceChecker {
    private boolean ready = false;

    public void waitForResource() {
        while (!ready) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        System.out.println("Kaynak hazır");
    }
}
// CPU'yu gereksiz yere tüketiyor
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
public class ResourceChecker {
    private boolean ready = false;
    private final Object lock = new Object();

    public void waitForResource() {
        synchronized (lock) {
            while (!ready) {
                try {
                    lock.wait();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        }
        System.out.println("Kaynak hazır");
    }

    public void setReady() {
        synchronized (lock) {
            ready = true;
            lock.notify();
        }
    }
}
// CPU dostu bekleme
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>14. Aşırı Mühendislik</h2>
            <p>
                Aşırı Mühendislik, bir sorunun çözümüne gereğinden fazla karmaşık veya genel bir yaklaşım
                uygulanmasıdır. Bu anti-pattern, genellikle geliştiricilerin gelecekteki olası gereksinimlere hazırlık
                yapmak istemesi, mevcut sorunu gereğinden fazla genelleştirmesi veya teknik gösteriş yapma arzusuyla
                ortaya çıkar. Örneğin, basit bir nesne oluşturma işlemi için karmaşık bir fabrika hiyerarşisi (Factory
                of Factories) tasarlanması, aşırı mühendisliğe örnektir. Aşırı mühendislik, genellikle YAGNI (You Aren’t
                Gonna Need It) ilkesine aykırıdır ve gereksiz özellikler veya esneklik ekleyerek kod tabanını şişirir.
                Bu yaklaşım, geliştirme süresini uzatır, çünkü basit bir çözüm yerine karmaşık yapılar uygulanır.
                Ayrıca, aşırı mühendislik, kodun anlaşılmasını ve bakımını zorlaştırır, çünkü gereksiz soyutlamalar ve
                hiyerarşiler yeni geliştiriciler için kafa karıştırıcı olabilir. Örneğin, yalnızca iki tür nesne
                oluşturulacaksa, bir `AbstractFactory` hiyerarşisi oluşturmak yerine basit bir `if-else` yapısı yeterli
                olabilir. Aşırı mühendislik, özellikle çevik geliştirme süreçlerinde, iteratif ve sade çözümler yerine
                büyük ön tasarımlara yönelindiğinde yaygınlaşır. Bu anti-pattern, teknik borcu artırır, çünkü
                kullanılmayan veya nadiren kullanılan özellikler kod tabanında birikir ve bakım maliyetlerini yükseltir.
            </p>
            <p><strong>Neden Sorunlu?</strong> Aşırı mühendislik, gereksiz karmaşıklık ekleyerek kodun bakım
                maliyetlerini artırır. Karmaşık yapılar, yeni geliştiricilerin kodu anlamasını ve hata ayıklamasını
                zorlaştırır. Ayrıca, kullanılmayan özellikler veya soyutlamalar, kod tabanını şişirir ve okunabilirliği
                azaltır. Performans açısından, gereksiz soyutlamalar veya hiyerarşiler işlem yükü oluşturabilir. Aşırı
                mühendislik, geliştirme süresini uzatır ve kaynak israfına yol açar, çünkü çoğu zaman bu karmaşık
                çözümler gerçek bir ihtiyaca hizmet etmez. Uzun vadede, bu anti-pattern teknik borcu artırır ve projenin
                sürdürülebilirliğini zorlaştırır.</p>
            <p><strong>Nasıl Önlenir?</strong> YAGNI (You Aren’t Gonna Need It) ilkesine bağlı kalarak, yalnızca mevcut
                gereksinimlere odaklanılmalıdır. Basit ve sade çözümler tercih edilmeli, gelecekteki olası ihtiyaçlar
                için genelleştirme yapılmamalıdır. Örneğin, bir fabrika sınıfı yerine basit bir koşullu mantık
                kullanılabilir. Kod incelemelerinde, gereksiz soyutlamalar veya karmaşık yapılar sorgulanmalı ve
                sadeleştirilmelidir. Çevik metodolojiler benimsenerek, gereksinimlerin iteratif olarak ele alınması
                sağlanabilir. Ayrıca, birim testleri yazmak, yalnızca gerekli özelliklerin geliştirilmesini zorlayarak
                aşırı mühendisliği önleyebilir. Performans ve bakım gereksinimleri, tasarım kararları alınmadan önce
                analiz edilmelidir.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
public class FactoryFactory {
    public AbstractFactory createFactory(String type) {
        // Gereksiz yere karmaşık fabrika hiyerarşisi
        if ("typeA".equals(type)) {
            return new TypeAFactory();
        } else {
            return new TypeBFactory();
        }
    }
}
// Gereksiz karmaşıklık
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
public class SimpleFactory {
    public Service createService(String type) {
        // Basit ve yeterli çözüm
        if ("typeA".equals(type)) {
            return new TypeAService();
        } else {
            return new TypeBService();
        }
    }
}
// YAGNI ilkesine uygun
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>15. Kaynak Yönetimi İhmali</h2>
            <p>
                Kaynak Yönetimi İhmali, dosya akışları, veritabanı bağlantıları, ağ soketleri veya diğer sistem
                kaynaklarının düzgün bir şekilde kapatılmaması durumudur. Bu anti-pattern, kaynakların açık kalmasına
                neden olarak kaynak sızıntılarına (resource leaks) yol açar ve sistem kaynaklarının tükenmesine sebep
                olabilir. Örneğin, bir `FileInputStream` nesnesinin `close()` metodu çağrılmadan bırakılması, dosya
                tanıtıcılarının (file descriptors) tükenmesine ve uygulamanın çökmesine neden olabilir. Benzer şekilde,
                bir veritabanı bağlantısının kapatılmaması, bağlantı havuzunun dolmasına ve yeni bağlantıların
                açılamamasına yol açar. Kaynak yönetimi ihmali, genellikle `try-catch` bloklarında kaynak kapatma
                işlemlerinin unutulması, hata durumlarında kapatma kodunun atlanması veya manuel kapatma işlemlerine
                güvenilmesiyle ortaya çıkar. Bu anti-pattern, özellikle yüksek yük altındaki sistemlerde veya uzun süre
                çalışan uygulamalarda ciddi sorunlara yol açar. Örneğin, bir web uygulamasında veritabanı
                bağlantılarının sızması, uygulamanın yavaşlamasına veya yanıt vermemesine neden olabilir. Ayrıca, kaynak
                sızıntıları, sistemin bellek tüketimini artırır ve performans düşüşüne yol açar. Kaynak yönetimi ihmali,
                genellikle aceleyle yazılmış kodlarda veya kaynak yönetimi için modern Java özelliklerinin (örneğin,
                try-with-resources) kullanılmadığı durumlarda yaygınlaşır.
            </p>
            <p><strong>Neden Sorunlu?</strong> Açık kalan kaynaklar, bellek sızıntılarına, dosya tanıtıcılarının
                tükenmesine veya veritabanı bağlantı havuzlarının dolmasına neden olabilir. Bu, uygulamanın
                performansını düşürür ve çökme riskini artırır. Örneğin, bir dosya akışının kapatılmaması, sistemin
                dosya tanıtıcı limitine ulaşmasına ve yeni dosyaların açılamamasına yol açabilir. Ayrıca, kaynak
                sızıntıları, uygulamanın ölçeklenebilirliğini sınırlar ve üretim ortamlarında ciddi arızalara neden
                olabilir. Performans açısından, açık kaynaklar gereksiz yere sistem kaynaklarını tüketir ve enerji
                verimliliğini azaltır. Uzun vadede, bu anti-pattern teknik borcu artırır ve sistemin bakımını
                zorlaştırır.</p>
            <p><strong>Nasıl Önlenir?</strong> Java'nın try-with-resources yapısı kullanılarak kaynakların otomatik
                olarak kapatılması sağlanmalıdır. Try-with-resources, `AutoCloseable` arayüzünü uygulayan nesnelerin
                (örneğin, `FileInputStream`, `Connection`) otomatik kapanmasını garanti eder. Alternatif olarak,
                `finally` bloğunda manuel kapatma işlemleri yapılabilir, ancak bu hata eğilimlidir ve try-with-resources
                tercih edilmelidir. Kod incelemelerinde, kaynak kapatma işlemlerinin doğruluğu kontrol edilmelidir.
                Ayrıca, kaynak havuzları (örneğin, veritabanı bağlantı havuzları) kullanılarak kaynak yönetimi optimize
                edilebilir. Statik analiz araçları (örneğin, SpotBugs), kaynak sızıntılarını tespit etmek için
                kullanılabilir. Test senaryolarında, kaynakların düzgün kapatıldığı doğrulanmalıdır.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
import java.io.FileInputStream;
import java.io.IOException;

public class FileProcessor {
    public void readFile(String path) {
        FileInputStream fis = null;
        try {
            fis = new FileInputStream(path);
            // Dosya okuma işlemleri
        } catch (IOException e) {
            System.err.println("Hata: " + e.getMessage());
        }
        // fis.close() çağrısı unutuldu, kaynak sızıntısına yol açar
    }
}
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
import java.io.FileInputStream;
import java.io.IOException;

public class FileProcessor {
    public void readFile(String path) {
        try (FileInputStream fis = new FileInputStream(path)) {
            // Dosya okuma işlemleri
        } catch (IOException e) {
            System.err.println("Hata: " + e.getMessage());
        }
        // try-with-resources, fis'in otomatik kapanmasını sağlar
    }
}
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>16. Kod Tekrarı</h2>
            <p>
                Kod tekrarı, aynı veya benzer kod parçalarının birden fazla yerde kopyalanarak kullanılmasıdır ve
                genellikle "Kopyala-Yapıştır Programlama" ile ilişkilidir. Bu anti-pattern, geliştiricilerin mevcut kodu
                yeniden düzenlemek yerine, aynı mantığı farklı yerlerde tekrar yazmasıyla ortaya çıkar. Örneğin, bir
                doğrulama işlemi (örneğin, bir giriş dizesinin uzunluğunu kontrol eden kod) farklı sınıflarda veya
                yöntemlerde tekrarlanıyorsa, bu kod tekrarıdır. Kod tekrarı, genellikle zaman baskısı, modüler tasarım
                prensiplerine uyulmaması veya mevcut kodun yeniden kullanılabilirliğinin göz ardı edilmesi nedeniyle
                oluşur. Bu durum, kısa vadede geliştirme süresini hızlandırıyor gibi görünse de, uzun vadede ciddi
                sorunlara yol açar. Örneğin, bir hata düzeltmesi veya mantık değişikliği gerektiğinde, tüm tekrar eden
                kod parçalarının ayrı ayrı güncellenmesi gerekir, bu da hata riskini artırır ve bakım maliyetlerini
                yükseltir. Ayrıca, kod tekrarı, kod tabanının şişmesine neden olur, bu da okunabilirliği azaltır ve yeni
                geliştiricilerin sistemi anlamasını zorlaştırır. Büyük ölçekli projelerde, kod tekrarı teknik borcun
                birikmesine ve sistemin sürdürülebilirliğinin azalmasına yol açar. Bu anti-pattern, özellikle birden
                fazla geliştiricinin çalıştığı takımlarda, tutarsızlıklara ve entegrasyon sorunlarına neden olabilir.
            </p>
            <p><strong>Neden Sorunlu?</strong> Kod tekrarı, bakım maliyetlerini artırır, çünkü bir hata düzeltmesi veya
                güncelleme gerektiğinde tüm tekrar eden kod parçaları ayrı ayrı değiştirilmelidir. Bu, hata riskini
                artırır ve tutarsızlıklara yol açabilir. Örneğin, bir doğrulama mantığında değişiklik yapıldığında,
                yalnızca bir kopyası güncellenirse, diğer kopyalar eski ve hatalı kalabilir. Ayrıca, kod tekrarı, kod
                tabanını şişirir, okunabilirliği azaltır ve bellek/işlemci kaynaklarını gereksiz yere tüketebilir. Test
                yazımı da zorlaşır, çünkü her tekrar eden kod parçası için ayrı testler yazılması gerekir. Uzun vadede,
                kod tekrarı teknik borcu artırır ve projenin sürdürülebilirliğini zorlaştırır.</p>
            <p><strong>Nasıl Önlenir?</strong> DRY (Don’t Repeat Yourself) ilkesine bağlı kalarak, ortak mantık yeniden
                kullanılabilir yöntemlere, sınıflara veya modüllere ayrılmalıdır. Örneğin, bir doğrulama mantığı tek bir
                yöntemde toplanabilir ve farklı yerlerde çağrılabilir. Yardımcı sınıflar (utility classes), tasarım
                desenleri (örneğin, Template Method) veya kütüphaneler kullanılarak kod tekrarı azaltılabilir. Yeniden
                düzenleme (refactoring) teknikleriyle, tekrar eden kodlar tespit edilip birleştirilmelidir. Kod
                incelemelerinde, kopyalanmış kod parçaları belirlenmeli ve yeniden kullanılabilir hale getirilmelidir.
                Birim testleri yazmak, kod tekrarını azaltmaya zorlar, çünkü testler için de benzer tekrarlar gerekir.
                Statik analiz araçları (örneğin, SonarQube), kod tekrarını tespit etmek için kullanılabilir.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
public class Validator {
    public boolean validateEmail(String email) {
        if (email != null && email.contains("@") && email.length() > 5) {
            return true;
        }
        return false;
    }

    public boolean validateUsername(String username) {
        if (username != null && username.contains("@") && username.length() > 5) {
            return true;
        }
        return false;
    }
}
// Aynı mantık iki yerde tekrar ediyor
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
public class Validator {
    private boolean validateInput(String input) {
        if (input != null && input.contains("@") && input.length() > 5) {
            return true;
        }
        return false;
    }

    public boolean validateEmail(String email) {
        return validateInput(email);
    }

    public boolean validateUsername(String username) {
        return validateInput(username);
    }
}
// Ortak mantık yeniden kullanılabilir
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>17. Aşırı Loglama</h2>
            <p>
                Aşırı loglama, uygulamanın her adımında veya gereksiz detaylarda log mesajları oluşturulmasıdır. Bu
                anti-pattern, genellikle geliştiricilerin hata ayıklama (debugging) için her işlemi loglama ihtiyacı
                hissetmesi, loglama seviyelerinin (örneğin, DEBUG, INFO, ERROR) yanlış kullanılması veya loglama
                stratejisinin belirlenmemesiyle ortaya çıkar. Örneğin, bir döngü içinde her iterasyonu loglamak veya her
                metod çağrısını `INFO` seviyesinde kaydetmek, aşırı loglamaya örnektir. Aşırı loglama, özellikle yüksek
                trafikli sistemlerde ciddi performans sorunlarına yol açar, çünkü log yazma işlemleri disk I/O’sunu
                artırır ve sistem kaynaklarını tüketir. Ayrıca, gereksiz loglar, log dosyalarının hızla büyümesine neden
                olur, bu da depolama sorunlarına ve log analizinin zorlaşmasına yol açar. Örneğin, bir üretim ortamında,
                kritik hataları bulmak için logları incelemek gerektiğinde, gereksiz log mesajları önemli bilgileri
                gölgede bırakabilir. Aşırı loglama, genellikle geliştirme aşamasında hata ayıklamak için eklenen geçici
                logların kaldırılmaması veya loglama kütüphanelerinin (örneğin, SLF4J, Log4j) özelliklerinin tam olarak
                kullanılmaması durumunda yaygınlaşır. Bu anti-pattern, sistemin bakımını zorlaştırır, performansını
                düşürür ve operasyonel maliyetleri artırır.
            </p>
            <p><strong>Neden Sorunlu?</strong> Aşırı loglama, performans sorunlarına yol açar, çünkü log yazma işlemleri
                disk I/O’sunu ve CPU kullanımını artırır. Büyük log dosyaları, depolama alanını tüketir ve log analizini
                zorlaştırır, bu da hata ayıklamayı yavaşlatır. Ayrıca, gereksiz loglar, kritik hata mesajlarını gölgede
                bırakarak sorunların tespitini zorlaştırır. Örneğin, bir üretim ortamında, önemli bir hata mesajı
                binlerce gereksiz log arasında kaybolabilir. Aşırı loglama, bakım maliyetlerini artırır, çünkü log
                dosyalarının yönetimi ve analizi daha karmaşık hale gelir. Ayrıca, yanlış loglama seviyeleri, logların
                faydasını azaltır ve operasyonel süreçleri aksatır.</p>
            <p><strong>Nasıl Önlenir?</strong> Loglama seviyeleri (DEBUG, INFO, WARN, ERROR) doğru şekilde
                kullanılmalıdır. Örneğin, hata ayıklama için `DEBUG`, önemli olaylar için `INFO` ve hatalar için `ERROR`
                seviyesi tercih edilmelidir. Loglama kütüphaneleri (örneğin, SLF4J, Log4j) yapılandırılmalı ve üretim
                ortamında yalnızca gerekli log seviyeleri etkinleştirilmelidir. Kod incelemelerinde, gereksiz veya aşırı
                loglama tespit edilip kaldırılmalıdır. Log mesajları anlamlı, kısa ve bağlamsal olmalıdır; örneğin, hata
                mesajları hata kodlarını ve ilgili parametreleri içermelidir. Ayrıca, log rotasyonu ve sıkıştırma gibi
                mekanizmalar kullanılarak log dosyalarının yönetimi optimize edilmelidir. Performans testleri,
                loglamanın sistem üzerindeki etkisini ölçmek için kullanılabilir.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Processor {
    private static final Logger log = LoggerFactory.getLogger(Processor.class);

    public void processList(List<String> items) {
        for (String item : items) {
            log.info("İşleniyor: {}", item); // Her iterasyon loglanıyor
            // İşleme mantığı
        }
    }
}
// Gereksiz yere fazla log
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Processor {
    private static final Logger log = LoggerFactory.getLogger(Processor.class);

    public void processList(List<String> items) {
        log.debug("Liste işleme başladı, boyut: {}", items.size());
        for (String item : items) {
            // İşleme mantığı
        }
        log.debug("Liste işleme tamamlandı");
    }
}
// Loglama sınırlı ve uygun seviyede
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>18. Yetersiz Hata Geri Bildirimi</h2>
            <p>
                Yetersiz hata geri bildirimi, bir hata oluştuğunda kullanıcıya veya geliştiriciye yeterli bilgi
                sağlanmaması durumudur. Bu anti-pattern, genellikle hata mesajlarının genel, belirsiz veya tamamen eksik
                olmasıyla ortaya çıkar. Örneğin, bir dosya yükleme işlemi başarısız olduğunda yalnızca "Hata oluştu"
                mesajı göstermek, kullanıcıya sorunun nedenini anlamada yardımcı olmaz. Benzer şekilde, bir istisnanın
                loglanmadan yutulması veya geliştiriciye hata detaylarının (örneğin, istisna türü, yığın izi)
                sağlanmaması, hata ayıklamayı zorlaştırır. Yetersiz hata geri bildirimi, genellikle hata yönetimi
                stratejisinin belirlenmediği, kullanıcı deneyiminin göz ardı edildiği veya geliştirme sürecinde hata
                senaryolarının yeterince test edilmediği durumlarda görülür. Bu anti-pattern, kullanıcıların uygulamaya
                olan güvenini azaltır, çünkü sorunların kaynağını anlamak veya çözmek mümkün olmaz. Geliştiriciler
                açısından, yetersiz geri bildirim, hata ayıklamayı zaman alıcı ve karmaşık hale getirir, bu da bakım
                maliyetlerini artırır. Örneğin, bir API istemcisine yalnızca HTTP 500 kodu döndürmek, istemcinin hatanın
                nedenini anlamasını zorlaştırır. Yetersiz hata geri bildirimi, özellikle üretim ortamlarında, sorunların
                hızlı bir şekilde çözülmesini engeller ve teknik borcu artırır.
            </p>
            <p><strong>Neden Sorunlu?</strong> Yetersiz hata geri bildirimi, kullanıcı deneyimini olumsuz etkiler, çünkü
                kullanıcılar sorunların nedenini anlayamaz ve çözüm bulmakta zorlanır. Geliştiriciler için, belirsiz
                hata mesajları hata ayıklamayı zorlaştırır ve sorunların çözüm süresini uzatır. Örneğin, bir istisnanın
                detayları loglanmazsa, hatanın kaynağına ulaşmak için ek çaba gerekir. Ayrıca, yetersiz geri bildirim,
                sistemin güvenilirliğini azaltır ve kullanıcı güvenini zedeler. Bakım açısından, bu anti-pattern teknik
                borcu artırır, çünkü hataların çözümü için daha fazla zaman ve kaynak gerekir. Üretim ortamlarında,
                yetersiz geri bildirim ciddi operasyonel sorunlara yol açabilir.</p>
            <p><strong>Nasıl Önlenir?</strong> Hata mesajları anlamlı, spesifik ve kullanıcı dostu olmalıdır. Örneğin,
                "Dosya yüklenemedi: Dosya boyutu 10MB sınırını aşıyor" gibi bir mesaj, kullanıcıya sorunun nedenini
                açıklar. Geliştiriciler için, istisnalar loglanmalı ve hata detayları (örneğin, yığın izi, hata kodu)
                kaydedilmelidir. Hata yönetimi için merkezi bir mekanizma (örneğin, global exception handler)
                kullanılabilir. API’lerde, hata yanıtları standartlaştırılmalı ve detaylı bilgiler (örneğin, hata kodu,
                mesaj) içermelidir. Kod incelemelerinde, hata mesajlarının yeterliliği kontrol edilmelidir. Ayrıca, hata
                senaryoları birim testleriyle kapsanmalı ve kullanıcıya dönen mesajlar test edilmelidir. Kullanıcı
                arayüzlerinde, hata mesajları rehber olmalı ve çözüm önerileri sunmalıdır.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
public class FileUploader {
    public void uploadFile(String path) {
        try {
            // Dosya yükleme işlemleri
        } catch (Exception e) {
            System.out.println("Hata oluştu"); // Belirsiz mesaj
        }
    }
}
// Kullanıcıya ve geliştiriciye yeterli bilgi verilmiyor
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class FileUploader {
    private static final Logger log = LoggerFactory.getLogger(FileUploader.class);

    public void uploadFile(String path) {
        try {
            // Dosya yükleme işlemleri
        } catch (IOException e) {
            log.error("Dosya yükleme hatası: {}, neden: {}", path, e.getMessage(), e);
            throw new RuntimeException("Dosya yüklenemedi: Geçersiz dosya formatı", e);
        }
    }
}
// Ayrıntılı hata mesajı ve loglama
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>19. Aşırı Genel İstisna Yakalama</h2>
            <p>
                Aşırı genel istisna yakalama, belirli istisna türleri (örneğin, `IOException`, `SQLException`) yerine,
                en üst seviye `Exception` veya `Throwable` sınıfının yakalanmasıdır. Bu anti-pattern, genellikle
                geliştiricilerin tüm olası hataları tek bir `catch` bloğunda ele almak istemesi, istisna türlerini
                analiz etmeye vakit ayırmaması veya hata yönetimini basitleştirme çabasıyla ortaya çıkar. Örneğin, bir
                dosya okuma işleminde yalnızca `IOException` beklenirken `catch (Exception e)` kullanmak, beklenmedik
                diğer istisnaları (örneğin, `NullPointerException`) da yakalar ve uygun şekilde işlenmesini engeller.
                Aşırı genel istisna yakalama, hata ayıklamayı zorlaştırır, çünkü hatanın gerçek nedeni gizlenebilir ve
                yanlış hata yönetimi uygulanabilir. Örneğin, bir veritabanı bağlantı hatası ile bir null referans hatası
                aynı şekilde ele alınırsa, sorunun kaynağına ulaşmak zorlaşır. Bu anti-pattern, özellikle kritik
                sistemlerde, hataların yanlış işlenmesi nedeniyle veri kaybına veya sistem çökmelerine yol açabilir.
                Ayrıca, genel istisna yakalama, kodun okunabilirliğini azaltır ve bakım maliyetlerini artırır, çünkü
                istisnaların nasıl işlendiği belirsizdir. Bu sorun, genellikle aceleyle yazılmış kodlarda veya hata
                yönetimi için bir strateji belirlenmediğinde yaygınlaşır.
            </p>
            <p><strong>Neden Sorunlu?</strong> Aşırı genel istisna yakalama, hatanın gerçek nedenini gizler ve hata
                ayıklamayı zorlaştırır. Örneğin, bir `NullPointerException` ile `IOException` aynı şekilde ele alınırsa,
                sorunun kaynağına ulaşmak zorlaşır. Ayrıca, genel yakalama, hataların yanlış işlenmesine yol açabilir;
                örneğin, kritik bir hata göz ardı edilebilir veya yanlış bir kurtarma stratejisi uygulanabilir. Bu,
                sistemin güvenilirliğini azaltır ve veri kaybına veya çökmelere neden olabilir. Kodun okunabilirliği ve
                bakımı da zorlaşır, çünkü istisnaların nasıl işlendiği belirsizdir. Uzun vadede, bu anti-pattern teknik
                borcu artırır ve hata yönetimini karmaşıklaştırır.</p>
            <p><strong>Nasıl Önlenir?</strong> Spesifik istisna türleri yakalanmalı ve her biri için uygun hata işleme
                mantığı uygulanmalıdır. Örneğin, `IOException` ve `SQLException` ayrı `catch` bloklarında ele
                alınmalıdır. Çoklu istisna yakalama (multi-catch) özelliği (`catch (IOException | SQLException e)`)
                kullanılarak kod sadeleştirilebilir. Kod incelemelerinde, genel `Exception` veya `Throwable`
                yakalamaları tespit edilip düzeltilmelidir. İstisna hiyerarşisi analiz edilerek yalnızca beklenen
                istisnalar yakalanmalıdır. Ayrıca, merkezi bir hata işleme mekanizması (örneğin, global exception
                handler) kullanılarak istisna yönetimi standartlaştırılabilir. Statik analiz araçları (örneğin,
                SpotBugs), genel istisna yakalamalarını tespit etmek için kullanılabilir.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
public class FileProcessor {
    public void processFile(String path) {
        try {
            // Dosya işleme
            Files.readAllBytes(Paths.get(path));
        } catch (Exception e) {
            System.out.println("Hata: " + e.getMessage()); // Genel yakalama
        }
    }
}
// Hata türü belirsiz, yanlış işleme riski
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
import java.io.IOException;

public class FileProcessor {
    public void processFile(String path) {
        try {
            // Dosya işleme
            Files.readAllBytes(Paths.get(path));
        } catch (IOException e) {
            System.out.println("Dosya okuma hatası: " + e.getMessage());
            throw new RuntimeException("Dosya işlenemedi", e);
        }
    }
}
// Spesifik istisna yakalama
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>20. Sabit Kodlanmış Zaman Dilimi</h2>
            <p>
                Sabit kodlanmış zaman dilimi, tarih ve saat işlemlerinde zaman diliminin kod içinde sabit olarak
                belirtilmesi ve farklı zaman dilimlerine uyum sağlanmamasıdır. Örneğin, `new
                SimpleDateFormat("yyyy-MM-dd").parse(date)` gibi bir kod, varsayılan sistem zaman dilimini kullanır ve
                farklı coğrafyalardaki kullanıcılar için yanlış sonuçlar üretebilir. Bu anti-pattern, genellikle
                geliştiricilerin zaman dilimi farklılıklarını göz ardı etmesi, yalnızca tek bir bölgede çalışacaklarını
                varsayması veya Java’nın zaman dilimi API’lerini (örneğin, `ZoneId`, `ZonedDateTime`) tam olarak
                kullanmaması nedeniyle ortaya çıkar. Sabit kodlanmış zaman dilimleri, özellikle uluslararası
                uygulamalarda ciddi sorunlara yol açar; örneğin, bir toplantı planlama uygulamasında, bir kullanıcı
                UTC+3 zaman dilimindeyken diğeri UTC-5’te ise, sabit kodlanmış bir zaman dilimi yanlış saatler gösterir.
                Ayrıca, yaz saati uygulamaları (DST) gibi dinamik zaman dilimi değişiklikleri dikkate alınmadığında,
                tarih ve saat hesaplamaları hatalı olabilir. Bu anti-pattern, genellikle yerel geliştirme ortamlarında
                fark edilmez, ancak üretimde farklı bölgelerdeki kullanıcılar tarafından kullanıldığında sorunlar ortaya
                çıkar. Sabit kodlanmış zaman dilimleri, kullanıcı deneyimini olumsuz etkiler, veri tutarsızlıklarına
                neden olur ve bakım maliyetlerini artırır.
            </p>
            <p><strong>Neden Sorunlu?</strong> Sabit kodlanmış zaman dilimleri, uluslararası uygulamalarda yanlış tarih
                ve saat hesaplamalarına yol açar, bu da kullanıcı deneyimini olumsuz etkiler. Örneğin, bir etkinlik
                saati farklı zaman dilimlerinde yanlış görüntülenebilir. Ayrıca, yaz saati uygulamaları (DST) gibi
                değişiklikler dikkate alınmadığında, hatalı sonuçlar üretilir. Bu, veri tutarsızlıklarına ve
                güvenilirlik sorunlarına neden olur. Bakım açısından, zaman dilimi değişiklikleri için kodun manuel
                olarak güncellenmesi gerekir, bu da hata riskini artırır. Uzun vadede, bu anti-pattern teknik borcu
                artırır ve sistemin küresel ölçekte çalışmasını zorlaştırır.</p>
            <p><strong>Nasıl Önlenir?</strong> Java’nın modern tarih ve saat API’si (`java.time` paketi, örneğin
                `ZonedDateTime`, `ZoneId`) kullanılmalıdır. Zaman dilimleri sabit kodlanmak yerine, kullanıcıdan veya
                sistem yapılandırmasından dinamik olarak alınmalıdır. Örneğin,
                `ZonedDateTime.now(ZoneId.of("Europe/Istanbul"))` gibi bir yapı kullanılabilir. Varsayılan olarak UTC
                kullanılmalı ve yerel zaman dilimlerine dönüşüm kullanıcıya bırakılmalıdır. Kod incelemelerinde, sabit
                kodlanmış zaman dilimleri tespit edilip kaldırılmalıdır. Uluslararasılaşma (i18n) kütüphaneleri
                kullanılarak zaman dilimi yönetimi standardize edilebilir. Test senaryolarında, farklı zaman dilimleri
                ve DST geçişleri test edilmelidir.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
import java.text.SimpleDateFormat;
import java.util.Date;

public class DateParser {
    public Date parseDate(String date) throws Exception {
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
        return sdf.parse(date); // Varsayılan zaman dilimi kullanılıyor
    }
}
// Zaman dilimi belirsiz
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
import java.time.LocalDate;
import java.time.ZoneId;
import java.time.ZonedDateTime;

public class DateParser {
    public ZonedDateTime parseDate(String date) {
        LocalDate localDate = LocalDate.parse(date);
        return localDate.atStartOfDay(ZoneId.of("Europe/Istanbul"));
    }
}
// Zaman dilimi açıkça belirtiliyor
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>21. Yanlış Boolean Kullanımı</h2>
            <p>
                Yanlış Boolean kullanımı, boolean değişkenlerin veya koşulların kafa karıştırıcı, belirsiz veya gereksiz
                yere karmaşık bir şekilde kullanılmasıdır. Bu anti-pattern, genellikle boolean değişkenlere anlamlı
                olmayan isimler verilmesi, çift negatif ifadeler kullanılması veya boolean mantığının gereksiz yere
                karmaşıklaştırılmasıyla ortaya çıkar. Örneğin, `boolean isNotInvalid` gibi bir değişken adı, neyi temsil
                ettiği konusunda kafa karıştırıcıdır ve okunabilirliği azaltır. Benzer şekilde, `if (!isNotActive)` gibi
                çift negatif ifadeler, kodu anlamayı zorlaştırır. Yanlış boolean kullanımı, genellikle kodun aceleyle
                yazıldığı, adlandırma kurallarına uyulmadığı veya mantıksal ifadelerin yeterince sadeleştirilmediği
                durumlarda görülür. Bu anti-pattern, özellikle büyük kod tabanlarında veya birden fazla geliştiricinin
                çalıştığı projelerde sorun yaratır, çünkü boolean mantığını anlamak için ek çaba gerekir. Ayrıca, yanlış
                boolean kullanımı, hata riskini artırır; örneğin, bir geliştirici `isNotInvalid` değişkeninin anlamını
                yanlış yorumlayarak yanlış bir koşullu mantık uygulayabilir. Bu anti-pattern, kodun okunabilirliğini ve
                bakımını zorlaştırır, teknik borcu artırır ve hata ayıklamayı karmaşık hale getirir.
            </p>
            <p><strong>Neden Sorunlu?</strong> Yanlış boolean kullanımı, kodu kafa karıştırıcı ve okunması zor hale
                getirir, bu da yeni geliştiricilerin mantığı anlamasını zorlaştırır. Çift negatif ifadeler veya belirsiz
                isimlendirmeler, hata riskini artırır, çünkü geliştiriciler koşulları yanlış yorumlayabilir. Örneğin,
                `isNotInvalid` gibi bir değişken, neyi temsil ettiği konusunda net değildir ve yanlış kullanıma yol
                açabilir. Ayrıca, karmaşık boolean ifadeleri, hata ayıklamayı zorlaştırır ve bakım maliyetlerini
                artırır. Performans açısından, gereksiz yere karmaşık ifadeler küçük bir işlem yükü oluşturabilir. Uzun
                vadede, bu anti-pattern teknik borcu artırır ve kod tabanının sürdürülebilirliğini azaltır.</p>
            <p><strong>Nasıl Önlenir?</strong> Boolean değişkenlere anlamlı ve pozitif isimler verilmelidir; örneğin,
                `isNotInvalid` yerine `isValid` kullanılmalıdır. Çift negatif ifadelerden kaçınılmalı ve mantık
                sadeleştirilmelidir. Örneğin, `if (!isNotActive)` yerine `if (isActive)` tercih edilmelidir. Kod
                incelemelerinde, boolean ifadelerin netliği ve adlandırmaların uygunluğu kontrol edilmelidir. Karmaşık
                boolean mantığı, yardımcı yöntemlere ayrılarak sadeleştirilebilir. Örneğin, `isEligible()` gibi bir
                yöntem, birden fazla boolean koşulunu kapsayabilir. Statik analiz araçları (örneğin, Checkstyle), kafa
                karıştırıcı boolean kullanımlarını tespit etmek için kullanılabilir. Ayrıca, birim testleri yazarak
                boolean mantığının doğruluğu doğrulanmalıdır.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
public class UserChecker {
    public boolean checkStatus(boolean isNotInvalid) {
        if (!isNotInvalid) {
            return false;
        }
        return true;
    }
}
// Kafa karıştırıcı isim ve çift negatif
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
public class UserChecker {
    public boolean checkStatus(boolean isValid) {
        return isValid;
    }
}
// Anlamlı isim ve sade mantık
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>22. Aşırı Uzun Yöntemler</h2>
            <p>
                Aşırı uzun yöntemler, tek bir yöntemin çok fazla sorumluluk üstlenmesi ve yüzlerce satır koda ulaşması
                durumudur. Bu anti-pattern, genellikle bir yöntemin birden fazla işlevi (örneğin, veri doğrulama, iş
                mantığı, dosya işlemleri) bir arada gerçekleştirmesiyle ortaya çıkar. Örneğin, bir kullanıcı kaydı
                işleyen bir yöntemin, giriş doğrulama, veritabanı işlemleri, e-posta bildirimi ve loglama gibi tüm
                adımları içermesi, aşırı uzun bir yönteme örnektir. Aşırı uzun yöntemler, genellikle kodun modüler bir
                şekilde tasarlanmadığı, Tek Sorumluluk İlkesine (Single Responsibility Principle) uyulmadığı veya
                yeniden düzenleme (refactoring) yapılmadığı durumlarda görülür. Bu anti-pattern, kodu anlamayı ve hata
                ayıklamayı zorlaştırır, çünkü yöntemin mantıksal akışı karmaşıktır ve birden fazla sorumluluğu
                birleştirir. Ayrıca, uzun yöntemler, test yazımını zorlaştırır, çünkü her bir işlevi ayrı ayrı test
                etmek yerine tüm yöntemi kapsayan karmaşık testler yazılması gerekir. Aşırı uzun yöntemler, genellikle
                aceleyle yazılmış kodlarda veya projenin erken aşamalarında ortaya çıkar ve zamanla teknik borç
                biriktirir. Büyük ölçekli projelerde, bu anti-pattern bakım maliyetlerini artırır, yeni özelliklerin
                eklenmesini zorlaştırır ve kod tabanının sürdürülebilirliğini azaltır.
            </p>
            <p><strong>Neden Sorunlu?</strong> Aşırı uzun yöntemler, kodu okunması ve anlaşılması zor hale getirir, bu
                da hata ayıklamayı ve bakımı zorlaştırır. Yeni geliştiriciler, uzun bir yöntemin mantığını çözmek için
                fazla zaman harcar. Ayrıca, uzun yöntemler Tek Sorumluluk İlkesini ihlal eder, çünkü birden fazla işlevi
                bir arada barındırır. Test edilebilirlik azalır, çünkü yöntemin her bir parçasını ayrı ayrı test etmek
                zordur. Performans açısından, uzun yöntemler gereksiz yere karmaşık kontrol akışları içerebilir ve işlem
                yükü oluşturabilir. Uzun vadede, bu anti-pattern teknik borcu artırır ve kod tabanının
                sürdürülebilirliğini zorlaştırır.</p>
            <p><strong>Nasıl Önlenir?</strong> Yöntemler küçük, tek bir amaca hizmet eden ve okunabilir olmalıdır. Uzun
                yöntemler, daha küçük yardımcı yöntemlere bölünerek modüler hale getirilmelidir. Örneğin, bir kullanıcı
                kaydı yöntemi, doğrulama, veritabanı işlemi ve bildirim gibi adımlara ayrılabilir. Tek Sorumluluk
                İlkesine bağlı kalarak, her yöntemin yalnızca bir işlevi yerine getirmesi sağlanmalıdır. Yeniden
                düzenleme teknikleri, örneğin Extract Method, uzun yöntemleri parçalamak için kullanılabilir. Kod
                incelemelerinde, yöntemlerin uzunluğu ve sorumlulukları kontrol edilmelidir. Anlamlı isimlendirmeler ve
                yorumlar, yöntemin amacını netleştirebilir. Birim testleri yazmak, yöntemlerin küçük ve test edilebilir
                olmasını zorlar.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
public class UserManager {
    public void processUser(String name, String email) {
        // Doğrulama
        if (name == null || email == null) {
            throw new IllegalArgumentException("Geçersiz giriş");
        }
        // Veritabanı işlemi
        Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/mydb");
        PreparedStatement stmt = conn.prepareStatement("INSERT INTO users (name, email) VALUES (?, ?)");
        stmt.setString(1, name);
        stmt.setString(2, email);
        stmt.executeUpdate();
        // Bildirim
        System.out.println("Kullanıcı kaydedildi: " + name);
        // Loglama
        System.out.println("Log: Kullanıcı eklendi");
    }
}
// Çok fazla sorumluluk, uzun ve karmaşık
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
public class UserManager {
    public void processUser(String name, String email) {
        validateInput(name, email);
        saveToDatabase(name, email);
        sendNotification(name);
        logAction(name);
    }

    private void validateInput(String name, String email) {
        if (name == null || email == null) {
            throw new IllegalArgumentException("Geçersiz giriş");
        }
    }

    private void saveToDatabase(String name, String email) {
        Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/mydb");
        PreparedStatement stmt = conn.prepareStatement("INSERT INTO users (name, email) VALUES (?, ?)");
        stmt.setString(1, name);
        stmt.setString(2, email);
        stmt.executeUpdate();
    }

    private void sendNotification(String name) {
        System.out.println("Kullanıcı kaydedildi: " + name);
    }

    private void logAction(String name) {
        System.out.println("Log: Kullanıcı eklendi");
    }
}
// Sorumluluklar ayrıştırılmış, yöntemler kısa
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>23. Değişkenlerin Yeniden Atanması</h2>
            <p>
                Değişkenlerin yeniden atanması, bir değişkenin bir yöntem veya kapsam içinde birden fazla kez farklı
                değerlerle güncellenmesi durumudur. Bu anti-pattern, genellikle değişkenlerin kapsamlarının iyi
                tanımlanmadığı, aynı değişkenin farklı amaçlarla kullanıldığı veya kodun yeterince modüler olmadığı
                durumlarda ortaya çıkar. Örneğin, bir `result` değişkeninin önce bir hesaplama sonucu, sonra bir hata
                mesajı, ardından başka bir veri türü için kullanılması, değişkenlerin yeniden atanmasına örnektir. Bu
                yaklaşım, kodu kafa karıştırıcı hale getirir, çünkü değişkenin hangi noktada hangi değeri tuttuğunu
                anlamak zorlaşır. Değişkenlerin yeniden atanması, genellikle aceleyle yazılmış kodlarda veya değişken
                kapsamlarının dikkatle planlanmadığı durumlarda görülür. Bu anti-pattern, özellikle uzun yöntemlerde
                veya karmaşık kontrol akışlarında, hata riskini artırır; örneğin, bir değişkenin yanlış bir değere
                atanması, beklenmedik sonuçlara yol açabilir. Ayrıca, bu durum, hata ayıklamayı zorlaştırır, çünkü
                değişkenin değerini izlemek için kodun tamamını incelemek gerekebilir. Büyük ölçekli projelerde,
                değişkenlerin yeniden atanması, kodun okunabilirliğini azaltır, bakım maliyetlerini artırır ve teknik
                borcu biriktirir.
            </p>
            <p><strong>Neden Sorunlu?</strong> Değişkenlerin yeniden atanması, kodu kafa karıştırıcı ve hata yapmaya
                yatkın hale getirir, çünkü bir değişkenin hangi değere sahip olduğunu takip etmek zorlaşır. Bu, hata
                ayıklamayı zorlaştırır ve yanlış değer atamaları nedeniyle hatalara yol açabilir. Ayrıca, değişkenlerin
                çok amaçlı kullanımı, Tek Sorumluluk İlkesini ihlal eder ve kodun okunabilirliğini azaltır. Performans
                açısından, gereksiz yeniden atamalar küçük bir işlem yükü oluşturabilir. Uzun vadede, bu anti-pattern
                teknik borcu artırır ve kod tabanının sürdürülebilirliğini zorlaştırır.</p>
            <p><strong>Nasıl Önlenir?</strong> Değişkenler mümkünse `final` anahtar kelimesiyle tanımlanmalı, böylece
                yeniden atanması engellenmelidir. Her değişken tek bir amaca hizmet etmeli ve anlamlı isimlerle
                tanımlanmalıdır. Kapsamlar küçültülerek, değişkenlerin yalnızca ihtiyaç duyulduğu yerde tanımlanması
                sağlanmalıdır. Uzun yöntemler küçük parçalara ayrılarak değişken kullanımı sadeleştirilmelidir. Kod
                incelemelerinde, birden fazla kez yeniden atanan değişkenler tespit edilip düzeltilmelidir. Ayrıca,
                immutable (değiştirilemez) veri yapıları kullanılarak değişkenlerin sabit tutulması teşvik edilmelidir.
                Statik analiz araçları (örneğin, Checkstyle), gereksiz yeniden atamaları tespit etmek için
                kullanılabilir.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
public class Calculator {
    public String calculate(int input) {
        String result = String.valueOf(input * 2); // İlk atama
        if (input < 0) {
            result = "Negatif sayı"; // Yeniden atama
        }
        result = "Sonuç: " + result; // Başka bir yeniden atama
        return result;
    }
}
// Değişken birden fazla amaçla kullanılıyor
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
public class Calculator {
    public String calculate(int input) {
        final String calculation = String.valueOf(input * 2);
        if (input < 0) {
            return "Negatif sayı";
        }
        return "Sonuç: " + calculation;
    }
}
// Değişken tek amaçla ve sabit kullanılıyor
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>24. Kötü İsimlendirme</h2>
            <p>
                Kötü isimlendirme, değişkenlerin, yöntemlerin, sınıfların veya diğer kod öğelerinin anlamlı, açıklayıcı
                veya tutarlı olmayan isimlerle tanımlanmasıdır. Bu anti-pattern, genellikle geliştiricilerin adlandırma
                kurallarına uymaması, kısa ama belirsiz isimler (örneğin, `x`, `temp`) kullanması veya bir öğenin
                amacını yanlış yansıtan isimler seçmesiyle ortaya çıkar. Örneğin, bir kullanıcı listesini işleyen bir
                yöntemin `doStuff()` olarak adlandırılması, yöntemin ne yaptığını açıklamaz ve kafa karışıklığına neden
                olur. Benzer şekilde, `data` gibi genel bir değişken adı, içeriğin neyi temsil ettiğini belirsiz
                bırakır. Kötü isimlendirme, genellikle aceleyle yazılmış kodlarda, adlandırma standartlarının
                belirlenmediği projelerde veya deneyimsiz geliştiricilerin çalıştığı durumlarda yaygınlaşır. Bu
                anti-pattern, kodun okunabilirliğini ciddi şekilde azaltır, yeni geliştiricilerin sistemi anlamasını
                zorlaştırır ve hata riskini artırır; örneğin, yanlış bir yöntemin çağrılması, adının belirsiz olması
                nedeniyle fark edilmeyebilir. Büyük ölçekli projelerde, kötü isimlendirme, bakım süreçlerini
                karmaşıklaştırır, kod incelemelerini yavaşlatır ve teknik borcu biriktirir. Ayrıca, kötü isimlendirme,
                kodun yeniden kullanılabilirliğini azaltır, çünkü öğelerin amacı net değildir.
            </p>
            <p><strong>Neden Sorunlu?</strong> Kötü isimlendirme, kodu anlamayı ve bakımını zorlaştırır, çünkü öğelerin
                amacı belirsizdir. Yeni geliştiriciler, kötü isimlendirilmiş bir kodu çözmek için fazla zaman harcar.
                Ayrıca, belirsiz isimler, yanlış kullanım riskini artırır; örneğin, bir yöntemin adı işlevini yanlış
                yansıtıyorsa, yanlış çağrılabilir. Kod incelemeleri, kötü isimlendirme nedeniyle daha uzun sürer ve hata
                tespitini zorlaştırır. Uzun vadede, bu anti-pattern teknik borcu artırır ve kod tabanının
                sürdürülebilirliğini azaltır. Ayrıca, kötü isimlendirme, kodun dokümantasyonunu yetersiz hale getirir,
                çünkü isimler kendi kendini açıklamaz.</p>
            <p><strong>Nasıl Önlenir?</strong> Anlamlı, açıklayıcı ve tutarlı isimler kullanılmalıdır. Örneğin, bir
                yöntem kullanıcıları işliyorsa `processUsers()` gibi bir isim tercih edilmelidir. Değişkenler, amacını
                yansıtan isimlerle tanımlanmalı; örneğin, `userList` yerine `data`. Java adlandırma kurallarına
                (örneğin, camelCase, PascalCase) uyulmalıdır. Kod incelemelerinde, isimlendirmelerin uygunluğu kontrol
                edilmelidir. Takım içinde adlandırma standartları belirlenmeli ve dökümante edilmelidir. Statik analiz
                araçları (örneğin, Checkstyle, SonarQube), kötü isimlendirmeleri tespit etmek için kullanılabilir.
                Ayrıca, yeniden düzenleme (refactoring) sırasında belirsiz isimler iyileştirilmelidir.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
public class X {
    public void doStuff(String d) {
        List<String> temp = new ArrayList<>();
        temp.add(d);
        // İşleme
    }
}
// Belirsiz isimler: X, doStuff, d, temp
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
public class UserProcessor {
    public void processUser(String userName) {
        List<String> userNames = new ArrayList<>();
        userNames.add(userName);
        // İşleme
    }
}
// Anlamlı ve açıklayıcı isimler
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>25. Gereksiz Karmaşıklık</h2>
            <p>
                Gereksiz karmaşıklık, basit bir sorunu çözmek için aşırı karmaşık algoritmalar, veri yapıları veya
                tasarım desenleri kullanılmasıdır. Bu anti-pattern, genellikle geliştiricilerin problemi gereğinden
                fazla genelleştirmesi, gelecekteki olası gereksinimlere hazırlık yapması veya teknik gösteriş yapma
                arzusuyla ortaya çıkar. Örneğin, yalnızca birkaç öğeyi sıralamak için özel bir sıralama algoritması
                yazmak yerine `Collections.sort()` kullanmak yeterlidir, ancak özel bir çözüm seçmek gereksiz
                karmaşıklığa yol açar. Benzer şekilde, basit bir veri işleme işlemi için karmaşık bir fabrika
                hiyerarşisi tasarlamak, kodu şişirir ve anlaşılmasını zorlaştırır. Gereksiz karmaşıklık, genellikle
                YAGNI (You Aren’t Gonna Need It) ilkesine aykırıdır ve çevik geliştirme süreçlerinde, sade çözümler
                yerine büyük ön tasarımlara yönelindiğinde yaygınlaşır. Bu anti-pattern, geliştirme süresini uzatır,
                çünkü basit bir çözüm yerine karmaşık yapılar uygulanır. Ayrıca, karmaşık kod, hata ayıklamayı ve bakımı
                zorlaştırır, test yazımını karmaşık hale getirir ve yeni geliştiriciler için öğrenme eğrisini artırır.
                Büyük ölçekli projelerde, gereksiz karmaşıklık teknik borcu biriktirir ve sistemin sürdürülebilirliğini
                azaltır.
            </p>
            <p><strong>Neden Sorunlu?</strong> Gereksiz karmaşıklık, kodu anlamayı ve bakımını zorlaştırır, çünkü basit
                bir sorun için karmaşık çözümler kullanılır. Bu, hata ayıklamayı ve yeni özellik eklemeyi zorlaştırır.
                Ayrıca, karmaşık yapılar, test yazımını karmaşık hale getirir ve test kapsamını artırır. Performans
                açısından, gereksiz yere karmaşık algoritmalar veya yapılar işlem yükü oluşturabilir. Geliştirme süresi
                uzar ve kaynak israfına yol açar, çünkü çoğu zaman bu karmaşık çözümler gerçek bir ihtiyaca hizmet
                etmez. Uzun vadede, bu anti-pattern teknik borcu artırır ve kod tabanının sürdürülebilirliğini
                zorlaştırır.</p>
            <p><strong>Nasıl Önlenir?</strong> YAGNI ilkesine bağlı kalarak, yalnızca mevcut gereksinimlere
                odaklanılmalıdır. Basit ve sade çözümler tercih edilmeli, gelecekteki olası ihtiyaçlar için
                genelleştirme yapılmamalıdır. Standart kütüphane çözümleri (örneğin, `Collections.sort()`) genellikle
                optimize edilmiş ve test edilmiştir, bu nedenle öncelikle bu çözümler kullanılmalıdır. Kod
                incelemelerinde, gereksiz karmaşık yapılar sorgulanmalı ve sadeleştirilmelidir. Çevik metodolojiler
                benimsenerek, gereksinimlerin iteratif olarak ele alınması sağlanabilir. Birim testleri yazmak, yalnızca
                gerekli özelliklerin geliştirilmesini zorlayarak gereksiz karmaşıklığı önleyebilir.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
public class CustomSorter {
    public void sortList(List<Integer> list) {
        // Gereksiz yere özel sıralama algoritması
        for (int i = 0; i < list.size(); i++) {
            for (int j = i + 1; j < list.size(); j++) {
                if (list.get(i) > list.get(j)) {
                    int temp = list.get(i);
                    list.set(i, list.get(j));
                    list.set(j, temp);
                }
            }
        }
    }
}
// Basit bir sıralama için karmaşık çözüm
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
import java.util.Collections;

public class Sorter {
    public void sortList(List<Integer> list) {
        Collections.sort(list); // Standart ve optimize çözüm
    }
}
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>26. Aşırı Yorum Kullanımı</h2>
            <p>
                Aşırı yorum kullanımı, kodda gereksiz, açık veya tekrarlayan yorumların yer almasıdır. Bu anti-pattern,
                genellikle geliştiricilerin kodu yeterince açıklayıcı yazmaması ve bunun yerine yorumlarla telafi etmeye
                çalışmasıyla ortaya çıkar. Örneğin, `int count = 0; // Sayaç sıfır` gibi bir yorum, kodun kendi kendini
                açıklaması gereken bir durumda gereksizdir. Benzer şekilde, kodun mantığını uzun paragraflarla
                açıklamaya çalışan yorumlar, kodun okunabilirliğini azaltabilir ve bakımını zorlaştırabilir. Aşırı yorum
                kullanımı, genellikle kodun kendi kendini açıklayıcı (self-documenting) olacak şekilde yazılmadığı
                durumlarda veya yorumların güncellenmeyi unutulmasıyla yaygınlaşır. Örneğin, kod değiştiğinde yorumlar
                güncellenmezse, yanıltıcı bilgiler içerebilir ve bu da hataşlığa yol açabilir. Ayrıca, aşırı yorumlar,
                kod tabanını şişirir ve gereksiz yere karmaşık bir görünüm oluşturur. Bu anti-pattern, özellikle büyük
                ölçekli projelerde, kod incelemelerini yavaşlatır ve yeni geliştiricilerin odaklanmasını zorlaştırır.
                Aşırı yorum kullanımı, kodun bakım maliyetlerini artırır, çünkü yorumların da kodla birlikte
                güncellenmesi gerekir. Bu anti-pattern, genellikle iyi adlandırma veya modüler tasarım gibi temel
                prensiplerin ihmal edilmesiyle ortaya çıkar.
            </p>
            <p><strong>Neden Sorunlu?</strong> Aşırı yorum kullanımı, kodu gereksiz yere karmaşık hale getirir ve
                okunabilirliği azaltır. Gereksiz veya açık yorumlar, kodun mantığını anlamayı zorlaştırabilir. Ayrıca,
                yorumların güncellenmemesi durumunda, yanıltıcı bilgiler içerebilir ve hata riskini artırabilir. Kod
                incelemeleri, aşırı yorumlar nedeniyle daha uzun sürer ve bakım maliyetleri artar. Uzun vadede, bu
                anti-pattern teknik borcu artırır, çünkü yorumların da kodla birlikte güncellenmesi gerekir. Ayrıca,
                aşırı yorumlar, kodun kendi kendini açıklama potansiyelini gölgeler ve kötü tasarım alışkanlıklarını
                teşvik eder.</p>
            <p><strong>Nasıl Önlenir?</strong> Kod, kendi kendini açıklayıcı olacak şekilde yazılmalıdır; örneğin,
                anlamlı isimlendirmeler ve modüler tasarım kullanılarak yorum ihtiyacı azaltılmalıdır. Yorumlar,
                yalnızca karmaşık mantığı açıklamak veya önemli kararları belgelemek için kullanılmalıdır. Örneğin, bir
                algoritmanın neden seçildiğini açıklayan bir yorum faydalıdır. Kod incelemelerinde, gereksiz veya açık
                yorumlar tespit edilip kaldırılmalıdır. Yorumlar kısa, net ve güncel tutulmalıdır. Statik analiz
                araçları (örneğin, SonarQube), gereksiz yorumları tespit etmek için kullanılabilir. Ayrıca, iyi
                dökümantasyon (örneğin, Javadoc) kullanılarak kodun amacı açıklanabilir ve inline yorum ihtiyacı
                azaltılabilir.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
public class Counter {
    // Sayaç değeri
    private int count = 0; // Sayaç sıfır

    // Sayacı artır
    public void increment() {
        count++; // Sayacı bir artır
        // Yeni değeri yazdır
        System.out.println(count); // Sayacı yazdır
    }
}
// Gereksiz ve açık yorumlar
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
public class Counter {
    private int count = 0;

    /** Sayacı bir artırır ve yeni değeri yazdırır. */
    public void increment() {
        count++;
        System.out.println(count);
    }
}
// Kod kendi kendini açıklıyor, yorumlar minimal
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>27. Sabit Kodlanmış Dosya Yolları</h2>
            <p>
                Sabit kodlanmış dosya yolları, dosya veya dizin yollarının kod içinde mutlak veya sabit bir şekilde
                yazılmasıdır. Örneğin, `File file = new File("C:\\data\\config.txt");` gibi bir kod, dosya yolunu sabit
                kodlar ve farklı işletim sistemlerinde veya ortamlarda çalışmayı zorlaştırır. Bu anti-pattern,
                genellikle geliştiricilerin yalnızca kendi yerel ortamlarında çalıştıklarını varsayması, dosya
                yollarının dinamik olarak belirlenmesi gerektiğini göz ardı etmesi veya yapılandırma dosyalarını
                kullanmaması nedeniyle ortaya çıkar. Sabit kodlanmış dosya yolları, uygulamanın taşınabilirliğini ciddi
                şekilde sınırlar; örneğin, Windows’ta çalışan bir kod, Linux’ta çalışmayabilir, çünkü dosya yolu ayracı
                (`\` yerine `/`) farklıdır. Ayrıca, farklı ortamlarda (örneğin, geliştirme, test, üretim) dosya
                konumları değiştiğinde, kodun manuel olarak güncellenmesi gerekir, bu da hata riskini artırır ve dağıtım
                süreçlerini karmaşıklaştırır. Güvenlik açısından, sabit kodlanmış yollar, dosya sistemine yetkisiz
                erişim riski yaratabilir, özellikle yollar hassas dizinleri işaret ediyorsa. Bu anti-pattern, genellikle
                aceleyle yazılmış kodlarda veya yapılandırma yönetimi için bir strateji belirlenmediğinde yaygınlaşır.
                Sabit kodlanmış dosya yolları, bakım maliyetlerini artırır, sistemin esnekliğini azaltır ve teknik borcu
                biriktirir.
            </p>
            <p><strong>Neden Sorunlu?</strong> Sabit kodlanmış dosya yolları, uygulamanın taşınabilirliğini ve
                esnekliğini azaltır, çünkü farklı işletim sistemleri veya ortamlar için kodun manuel olarak
                değiştirilmesi gerekir. Bu, hata riskini artırır ve dağıtım süreçlerini karmaşıklaştırır. Güvenlik
                açısından, sabit yollar yetkisiz dosya erişimine yol açabilir. Ayrıca, dosya yollarının değişmesi
                durumunda, kodun yeniden derlenmesi ve dağıtılması gerekir, bu da bakım maliyetlerini artırır. Uzun
                vadede, bu anti-pattern teknik borcu artırır ve sistemin sürdürülebilirliğini zorlaştırır.</p>
            <p><strong>Nasıl Önlenir?</strong> Dosya yolları, kod içinde sabit kodlanmak yerine, yapılandırma
                dosyalarından (örneğin, `application.properties`), ortam değişkenlerinden veya kullanıcı girişlerinden
                dinamik olarak alınmalıdır. Java’nın `java.nio.file.Paths` veya `File.separator` gibi platformdan
                bağımsız yol oluşturma araçları kullanılmalıdır. Örneğin, `Paths.get("data", "config.txt")` platformlar
                arası uyumludur. Kod incelemelerinde, sabit kodlanmış dosya yolları tespit edilip dinamik hale
                getirilmelidir. Yapılandırma yönetimi için kütüphaneler (örneğin, Apache Commons Configuration)
                kullanılabilir. Test senaryolarında, farklı işletim sistemlerinde dosya yollarının doğru çalıştığı
                doğrulanmalıdır.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
import java.io.File;

public class ConfigReader {
    public File readConfig() {
        return new File("C:\\data\\config.txt"); // Sabit kodlanmış yol
    }
}
// Platforma bağımlı ve esnek değil
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
import java.io.File;
import java.nio.file.Paths;

public class ConfigReader {
    public File readConfig() {
        String configPath = System.getenv("CONFIG_PATH");
        return Paths.get(configPath, "config.txt").toFile();
    }
}
// Dinamik ve platformdan bağımsız
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>28. Yanlış Koleksiyon Kullanımı</h2>
            <p>
                Yanlış koleksiyon kullanımı, bir veri yapısı ihtiyacına uygun olmayan bir koleksiyon türünün (örneğin,
                `List`, `Set`, `Map`) seçilmesi veya koleksiyonların yanlış yapılandırılmasıdır. Bu anti-pattern,
                genellikle geliştiricilerin Java’nın koleksiyon framework’ünü tam olarak anlamaması, performans
                etkilerini göz ardı etmesi veya varsayılan bir koleksiyon türüne (örneğin, `ArrayList`) yönelmesiyle
                ortaya çıkıyor. Örneğin, benzersiz elemanlar gerektiğinde `List` yerine `Set` kullanılması, yinelenen
                verilere yol açar. Benzer şekilde, sık sık anahtar-değer çifti aramaları yapılan bir veri yapısı için
                `List` kullanmak, performansı ciddi şekilde düşürür, çünkü `Map` daha uygun olurdu. Yanlış koleksiyon
                kullanımı, genellikle veri yapılarının erişim veya değiştirme özelliklerinin analiz edilmediği
                durumlarda ortaya çıkar. Bu anti-pattern, performans sorunlarına yol açar; örneğin, büyük bir veri
                setinde `ArrayList` üzerinde `contains()` işlemi, O(n) karmaşıklığı nedeniyle yavaş olur, oysa `HashSet`
                O(1) sağlar. Ayrıca, yanlış koleksiyonlar, kodun mantığını karmaşıklaştırır ve hata riskini artırır;
                örneğin, yinelenen veriler yanlış sonuçlara yol açabilir. Büyük ölçekli projelerde, yanlış koleksiyon
                kullanımı, sistem performansını ve bakımını olumsuz etkiler, teknik borcu artırır.
            </p>
            <p><strong>Neden Sorunlu?</strong> Yanlış koleksiyon kullanımı, performans sorunlarına yol açar, çünkü uygun
                olmayan veri yapıları daha yavaş işlemler veya daha fazla bellek tüketimi gerektirir. Örneğin, bir
                `List` üzerinde sık sık `contains()` çağrısı, `Set` yerine kullanıldığında gereksiz yere yavaş olur.
                Ayrıca, yanlış koleksiyonlar, kod mantığını karmaşıklaştırır ve hata riskini artırır; örneğin, yinelenen
                veriler yanlış sonuçlara yol açabilir. Bakım açısından, koleksiyonun yanlış seçildiği durumlarda, yeni
                gereksinimlere uyarlanmak zorlaşır. Uzun vadede, bu anti-pattern teknik borcu artırır ve sistemin
                sürdürülebilirliğini azaltır. Ayrıca, yanlış yapılandırılmış koleksiyonlar, örneğin senkronize olmayan
                bir koleksiyonun çok iş parçacıklı bir ortamda kullanılması, eşzamanlılık hatalarına yol açabilir.</p>
            <p><strong>Nasıl Önlenir?</strong> Koleksiyon seçimi, veri yapısının ihtiyaçlarına göre yapılmalıdır: `List`
                sıralı veriler için, `Set` benzersizlik için, `Map` anahtar-değer eşleşmeleri için. Performans
                gereksinimleri analiz edilmelidir; örneğin, sık arama işlemleri için `HashSet` veya `HashMap` tercih
                edilmelidir. Java’nın koleksiyon framework’ü (örneğin, `LinkedList`, `TreeSet`) iyi öğrenilmelidir.
                Eşzamanlılık gereken durumlarda, `ConcurrentHashMap` gibi uygun koleksiyonlar kullanılmalıdır. Kod
                incelemelerinde, koleksiyon seçimlerinin uygunluğu kontrol edilmelidir. Performans testleri,
                koleksiyonların veri büyüklüğüne göre etkisini ölçmelidir. Ayrıca, koleksiyonları yapılandırılırken,
                örneğin başlangıç kapasitesi veya sıralama düzeni gibi parametreler optimize edilmelidir.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
import java.util.List;

public class UserRegistry {
    public boolean hasUser(List<String> users, String username) {
        return users.contains(username); // Yavaş, O(n) karmaşıklık
    }
}
// Benzersizlik için List yerine Set kullanılmalı
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
                import java.util.Set;

                public class UserRegistry {
                    public boolean hasUser(Set<String> users) {
                        return users.contains(username); // Hızlı, O(1) karmaşıklık
                    }
                }
            // Benzersizlik için uygun koleksiyon
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>29. Aşırı Dinamik Tip Kullanımı</h2>
            <p>
                Aşırı dinamik tip kullanımı, Java’da tip güvenliğini bypass etmek için gereksiz yere `Object`, `Map`
                veya reflection gibi dinamik tip mekanizmalarının kullanılmasıdır.. Bu anti-pattern, genellikle
                geliştiricilerin esnek bir kod yazmak istemesi, tip sisteminin avantajlarını göz ardı etmesi veya
                karmaşık veri yapılarını yapılandırmak için tembel bir yaklaşım araması nedeniyle ortaya çıkıyor.
                Örneğin, bir nesnenin özelliklerini `Map<String, Object>` ile temsil etmek yerine bir sınıf tanımlamak,
                    tip güvenliğini artırır ve kodun anlaşılmasını kolaylaştırır.. Dinamik tipler, genellikle JSON veya
                    XML verileriyle çalışırken veya eski sistemlerle entegre olurken kullanılır, ancak bunların gereksiz
                    yere kullanımı, kodun okunabilirliğini azaltır ve hata riskini artırır. Aşırı dinamik tip kullanımı,
                    derleme zamanı tip denetimlerini devre dışı bırakır, bu da çalışma zamanı hatalaralarına (örneğin,
                    `ClassCastException`) yol açar.. Ayrıca, reflection gibi mekanizmalar, performans sorunları yaratır
                    ve kodun hata ayıklamasını zorlaştırır. Büyük ölçekli projelerde, aşırı dinamik tip kullanımı, kodun
                    bakımını karmaşıklaştırır, test yazımını zorlaştırır ve teknik borcu artırır. Bu anti-pattern,
                    özellikle tip güvenliğinin kritik olduğu sistemlerde ciddi sorunlara yol açabilir.</p>
            <p><strong>Neden Sorunlu?</strong> Aşırı dinamik tip kullanımı, derleme zamanı denetimlerini bypass ederek
                çalışma zamanı hatalarına yol açar, örneğin `ClassCastException` veya `NoSuchMethodException`. Bu, hata
                ayıklamayı zorlaştırır ve sistemin güvenilirliğini azaltır. Ayrıca, dinamik tipler, kodun
                okunabilirliğini ve anlaşılabilirliğini azaltır, çünkü veri türlerinin ne olduğu belirsizdir. Performans
                açısından, reflection gibi mekanizmalar yavaş çalışır ve işlem yükü oluşturur. Test yazımı, dinamik
                tipler nedeniyle karmaşıklaşır, çünkü her olası türü kapsayan testlere ihtiyaç duyulur. Uzun vadede, bu
                anti-pattern teknik borcu artırır ve kod tabanının sürdürülebilirliğini zorlaştırır.</p>
            <p><strong>Nasıl Önlenir?</strong> Java’nın statik tip sisteminden faydalanılmalı ve mümkünse sınıflar veya
                arayüzler tanımlanmalıdır. Örneğin, `Map<String, `Object>` yerine bir veri modeli (DTO) kullanılmalıdır.
                    Reflection yalnızca gerçekten gerekli olduğunda (örneğin, framework geliştirme) kullanılmalıdır.
                    JSON veya XML veriler için Jackson veya JAXB gibi kütüphaneler, tip güvenliği sağlar. Kod
                    incelemelerinde, dinamik tip kullanımları sorgulanmalı ve statik alternatiflerle değiştirilmelidir.
                    Statik analiz araçları (örneğin, SonarQube), dinamik tip kullanımını tespit etmek için
                    kullanılabilir. Ayrıca, birim testleri yazarak tip güvenliği hataları erken yakalanmalıdır.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
import java.util.Map;

public class UserProcessor {
    public void process(Map<String, Object> userData) {
        String name = (String) userData.get("name"); // Tip güvensiz
        // İşleme
    }
}
// Dinamik tip, hata eğilimli

            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
public class User {
    private String name;

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
}

public class UserProcessor {
    public void process(User user) {
        String name = user.getName(); // Tip güvenli
        // İşleme
    }
}
// Statik tip kullanımı

            </code></code>
        </pre>
        </div>

        <div class="anti-pattern">
            <h2>30. Global Durum Kötüye Kullanımı</h2>
            <p>
                Global durum kötüye kullanımı, statik değişkenler veya global nesneler aracılığıyla durumun (state)
                paylaşılması ve bu durumun kötü yönetilmesidir.. Bu anti-pattern, genellikle Singleton pattern’ın kötüye
                kullanılmasıyla veya statik alanların kontrolsüz bir şekilde paylaşılmasıyla ortaya çıkar. Örneğin, bir
                `static` veritabanı bağlantı nesnesinin tüm uygulama tarafından paylaşılması, global durum kötüye
                kullanımına örnektir. Global durum, genellikle kodun basit görünmesi için veya durum yönetiminin
                planlanmadığı durumlarda tercih edilir, ancak bu yaklaşım ciddi sorunlara yol açar. Global durum,
                sınıflar arasında gizli bağımlılıklar yaratır, bu da kodun test edilmesini ve hata ayıklamasını
                zorlaştırır. Örneğin, bir test global durumu değiştirirse, diğer testler beklenmedik şekilde başarısız
                olabilir. Ayrıca, çok iş parçacıklı (multithreaded) ortamlarda, global durum eşzamanlılık sorunlarına
                (örneğin, yarış koşulları) yol açar, çünkü birden fazla iş parçacığı aynı durumu değiştirebilir. Büyük
                ölçekli projelerde, global durum kötüye kullanımı, sistemin modülerliğini bozar, bakım maliyetlerini
                artırır ve teknik borcu biriktirir. Bu anti-pattern, özellikle ölçeklenebilir veya test edilebilir
                sistemler tasarlanırken ciddi bir engel oluşturur.
            </p>
            <p><strong>Neden Sorunlu?</strong> Global durum, gizli bağımlılıklar yaratır ve kodun modülerliğini bozar,
                bu da test edilebilirliği ve hata ayıklamayı zorlaştırır. Eşzamanlılık ortamlarında, global durum yarış
                koşulları veya durum tutarsızlıklarına yol açar, bu da sistem çökmelerine neden olabilir. Ayrıca, global
                durum, kodun yeniden kullanılabilirliğini azaltır, çünkü durum bağımlılıkları açıkça tanımlanmaz. Bakım
                açısından, global durumun değiştirilmesi, sistemin beklenmedik yerlerinde yan etkilere yol açabilir.
                Uzun vadede, bu anti-pattern teknik borcu artırır ve sistemin sürdürülebilirliğini zorlaştırır.</p>
            <p><strong>Nasıl Önlenir?</strong> Global durumdan mümkün olduğunca kaçınılmalı ve bağımlılık enjeksiyonu
                (Dependency Injection) gibi modern tasarım yaklaşımları tercih edilmelidir. Örneğin, bir veritabanı
                bağlantısı statik bir alanda tutulmak yerine, bir veri kaynağı (DataSource) üzerinden enjekte
                edilmelidir. Durum yönetimi, nesne örnekleri aracılığıyla yerel olarak yapılmalıdır. Eşzamanlılık
                sorunlarını önlemek için, immutable nesneler veya `java.util.concurrent` paketindeki eşzamanlı veri
                yapıları kullanılabilir. Kod incelemelerinde, statik alanların ve global durumun kullanımı
                sorgulanmalıdır. Birim testleri, global durum bağımlılıklarını tespit etmeye yardımcı olabilir. Ayrıca,
                tasarım desenleri (örneğin, Factory, Service Locator) kullanılarak durum yönetimi yapılandırılabilir.
            </p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
import java.sql.Connection;

public class Database {
    private static Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/mydb");

    public static Connection getConnection() {
        return conn; // Global durum
    }
}
// Eşzamanlılık ve test sorunları
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
            import java.sql.Connection;

public class Database {
    private final Connection conn;

    public Database(Connection conn) {
        this.conn = conn; // Bağımlılık enjeksiyonu
    }

    public Connection getConnection() {
        return conn;
    }
}
// Durum yerel ve test edilebilir
            </code></pre>
        </div>

        <div class="tips">
            <h2>Genel Önleme İpuçları</h2>
            <ul>
                <li><strong>SOLID İlkelerini Uygulayın:</strong> Tek sorumluluk, kompozisyon ve gevşek bağlılık gibi
                    ilkeleri benimseyin.</li>
                <li><strong>Modern Java Özelliklerini Kullanın:</strong> `Optional`, try-with-resources ve
                    `CompletableFuture` gibi araçları tercih edin.</li>
                <li><strong>Düzenli Yeniden Düzenleme:</strong> Kodu modülerleştirin, sabitler kullanın ve mantığı
                    ayırın.</li>
                <li><strong>Test Yazın:</strong> Birim testleri ile hataları erken yakalayın.</li>
                <li><strong>Performans Profil Oluşturun:</strong> VisualVM veya JMH gibi araçlarla gerçek darboğazları
                    belirleyin.</li>
            </ul>
        </div>
    </div>

    <!-- Prism.js JavaScript for syntax highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
</body>

</html>