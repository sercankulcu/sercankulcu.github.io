<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java'da Yaygın 30 Anti-Pattern</title>
    <!-- Prism.js CSS for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        h1 {
            text-align: center;
            color: #333;
            font-size: 28px;
            margin-bottom: 20px;
        }
        p {
            color: #555;
            line-height: 1.6;
            margin-bottom: 15px;
        }
        .anti-pattern {
            border: 1px solid #ddd;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 5px;
        }
        .anti-pattern h2 {
            color: #2c3e50;
            font-size: 20px;
            margin-bottom: 10px;
        }
        .anti-pattern strong {
            color: #333;
        }
        pre {
            background-color: #f8f8f8;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 14px;
        }
        code {
            font-family: 'Courier New', Courier, monospace;
        }
        .tips {
            margin-top: 30px;
            padding: 15px;
            background-color: #e8f4f8;
            border-radius: 5px;
        }
        .tips h2 {
            color: #2c3e50;
            font-size: 20px;
            margin-bottom: 10px;
        }
        .tips ul {
            list-style-type: disc;
            padding-left: 20px;
            color: #555;
        }
        .tips li {
            margin-bottom: 10px;
        }
        /* Ensure Prism.js styles don't conflict with existing styles */
        pre[class*="language-"] {
            margin: 0;
            padding: 10px;
            border-radius: 5px;
        }
        code[class*="language-"] {
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Java'da Yaygın 30 Anti-Pattern</h1>
        <p>Anti-pattern'ler, yazılım geliştirmede sıkça kullanılan ancak sorunlara yol açan kötü uygulamalardır. Aşağıda, Java'da karşılaşılan popüler anti-pattern'ler, açıklamaları, neden sorunlu oldukları, nasıl önlenebilecekleri ve kod örnekleri ile verilmiştir.</p>

        <div class="anti-pattern">
            <h2>1. Singleton Kötüye Kullanımı</h2>
            <p>Bir sınıfın yalnızca tek bir örneğinin olmasını sağlamak için Singleton pattern'inin aşırı kullanımı, global durum sorunlarına ve test zorluklarına yol açar.</p>
            <p><strong>Neden Sorunlu?</strong> Test edilmesi zor, gizli bağımlılıklar yaratır ve Tek Sorumluluk İlkesini ihlal eder.</p>
            <p><strong>Nasıl Önlenir?</strong> Singleton yerine bağımlılık enjeksiyonu kullanın veya durum yönetimini dikkatle yapın.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
import java.sql.Connection;

public class DatabaseConnection {
    private static DatabaseConnection instance = new DatabaseConnection();
    private Connection conn;

    private DatabaseConnection() {
        // Bağlantı başlatma
        try {
            this.conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/mydb");
        } catch (SQLException e) {
            System.err.println("Bağlantı hatası: " + e.getMessage());
        }
    }

    public static DatabaseConnection getInstance() {
        return instance;
    }

    public Connection getConnection() {
        return conn;
    }
}
// Global durum nedeniyle test edilmesi zor
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
import java.sql.Connection;

public class DatabaseConnection {
    private Connection conn;

    public DatabaseConnection(Connection conn) {
        this.conn = conn;
    }

    public Connection getConnection() {
        return conn;
    }
}

// Bağımlılık enjeksiyonu ile kullanım
Connection conn = dataSource.getConnection(); // DataSource dışardan sağlanır
DatabaseConnection db = new DatabaseConnection(conn);
// Test için sahte bir Connection nesnesi kullanılabilir
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>2. Tanrı Nesnesi (God Object)</h2>
            <p>Tek bir sınıfın çok fazla sorumluluk üstlenmesi, kodun şişmesine ve bakımının zorlaşmasına neden olur.</p>
            <p><strong>Neden Sorunlu?</strong> Tek Sorumluluk İlkesini ihlal eder, karmaşıklığı artırır.</p>
            <p><strong>Nasıl Önlenir?</strong> Sorumlulukları ayırarak sınıfları daha küçük ve odaklanmış hale getirin.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
import java.sql.Connection;

public class UserManager {
    public void authenticateUser(String username, String password) {
        // Kullanıcı doğrulama mantığı
        System.out.println("Kullanıcı doğrulanıyor: " + username);
    }

    public void saveToDatabase(Connection conn, String data) {
        // Veritabanına kaydetme mantığı
        System.out.println("Veri kaydediliyor: " + data);
    }

    public void sendEmail(String recipient, String message) {
        // E-posta gönderme mantığı
        System.out.println("E-posta gönderiliyor: " + recipient);
    }
}
// Çok fazla sorumluluk tek sınıfta
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
import java.sql.Connection;

public class AuthService {
    public void authenticateUser(String username, String password) {
        // Kullanıcı doğrulama mantığı
        System.out.println("Kullanıcı doğrulanıyor: " + username);
    }
}

public class DatabaseService {
    public void saveToDatabase(Connection conn, String data) {
        // Veritabanına kaydetme mantığı
        System.out.println("Veri kaydediliyor: " + data);
    }
}

public class EmailService {
    public void sendEmail(String recipient, String message) {
        // E-posta gönderme mantığı
        System.out.println("E-posta gönderiliyor: " + recipient);
    }
}
// Sorumluluklar ayrıştırılmış
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>3. Spagetti Kod</h2>
            <p>Karmakarışık kontrol akışları ve modüler olmayan kod yapısı.</p>
            <p><strong>Neden Sorunlu?</strong> Okunması, bakımı ve hata ayıklaması zor.</p>
            <p><strong>Nasıl Önlenir?</strong> Kodunuzu modülerleştirin, yöntemleri ayırın.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
public class DataProcessor {
    public void process() {
        boolean condition = true;
        if (condition) {
            for (int i = 0; i < 10; i++) {
                System.out.println("İşleniyor: " + i);
                if (i % 2 == 0) {
                    // Karmaşık mantık
                    System.out.println("Çift sayı: " + i);
                } else {
                    // Daha fazla karmaşık mantık
                    System.out.println("Tek sayı: " + i);
                }
            }
        }
    }
}
// Kodun yapısı karmaşık ve okunması zor
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
public class DataProcessor {
    public void process() {
        if (isConditionMet()) {
            processItems();
        }
    }

    private boolean isConditionMet() {
        return true;
    }

    private void processItems() {
        for (int i = 0; i < 10; i++) {
            System.out.println("İşleniyor: " + i);
            processItem(i);
        }
    }

    private void processItem(int i) {
        if (i % 2 == 0) {
            System.out.println("Çift sayı: " + i);
        } else {
            System.out.println("Tek sayı: " + i);
        }
    }
}
// Kod modüler ve okunabilir
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>4. Sihirli Sayılar/Dizeler</h2>
            <p>Sabit kodlanmış sayılar veya dizeler yerine adlandırılmış sabitler kullanmamak.</p>
            <p><strong>Neden Sorunlu?</strong> Kodu anlaşılmaz yapar, hata riskini artırır.</p>
            <p><strong>Nasıl Önlenir?</strong> Sabitler için `static final` kullanın.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
public class StatusChecker {
    public boolean isActive(int status) {
        if (status == 42) {
            return true;
        }
        return false;
    }
}
// 42'nin ne anlama geldiği belirsiz
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
public class StatusChecker {
    public static final int ACTIVE_STATUS = 42;

    public boolean isActive(int status) {
        if (status == ACTIVE_STATUS) {
            return true;
        }
        return false;
    }
}
// Sabit anlamlı ve yeniden kullanılabilir
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>5. Erken Optimizasyon</h2>
            <p>Gerçek performans sorunları belirlenmeden önce optimize etmeye çalışmak.</p>
            <p><strong>Neden Sorunlu?</strong> Gereksiz karmaşıklık ekler.</p>
            <p><strong>Nasıl Önlenir?</strong> Performans sorunlarını profil araçlarıyla belirleyin.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
import java.util.List;

public class Sorter {
    public void complexSort(List<String> list) {
        // Gereksiz yere karmaşık bir sıralama algoritması
        for (int i = 0; i < list.size(); i++) {
            for (int j = i + 1; j < list.size(); j++) {
                if (list.get(i).compareTo(list.get(j)) > 0) {
                    String temp = list.get(i);
                    list.set(i, list.get(j));
                    list.set(j, temp);
                }
            }
        }
    }
}
// Performans sorunu doğrulanmadan karmaşık kod
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
import java.util.Collections;
import java.util.List;

public class Sorter {
    public void sort(List<String> list) {
        Collections.sort(list);
        // Standart kütüphane kullanımı, optimize ve test edilmiş
    }
}
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>6. İstisna Yutma</h2>
            <p>İstisnaları yakalayıp işleme veya loglama yapmadan boş bırakma.</p>
            <p><strong>Neden Sorunlu?</strong> Hataları gizler, hata ayıklamayı zorlaştırır.</p>
            <p><strong>Nasıl Önlenir?</strong> İstisnaları loglayın veya yeniden fırlatın.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
import java.io.IOException;

public class FileReader {
    public void readFile(String path) {
        try {
            // Dosya okuma işlemleri
            Files.readAllBytes(Paths.get(path));
        } catch (IOException e) {
            // İstisna yutuluyor, hata gizleniyor
        }
    }
}
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class FileReader {
    private static final Logger log = LoggerFactory.getLogger(FileReader.class);

    public void readFile(String path) {
        try {
            // Dosya okuma işlemleri
            Files.readAllBytes(Paths.get(path));
        } catch (IOException e) {
            log.error("Dosya okuma hatası: {}", path, e);
            throw new RuntimeException("Dosya okunamadı", e);
        }
    }
}
// Hata loglanıyor ve yeniden fırlatılıyor
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>7. Aşırı Miras Kullanımı</h2>
            <p>Kompozisyon yerine mirası aşırı kullanmak.</p>
            <p><strong>Neden Sorunlu?</strong> Sıkı bağımlılıklar yaratır.</p>
            <p><strong>Nasıl Önlenir?</strong> Kompozisyonu tercih edin.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
public class Mammal {
    public void move() { System.out.println("Hareket ediyor"); }
}

public class Dog extends Mammal {
    public void bark() { System.out.println("Havlıyor"); }
}
// Miras sıkı bağımlılık yaratıyor
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
public interface Behavior {
    void move();
}

public class MammalBehavior implements Behavior {
    public void move() { System.out.println("Hareket ediyor"); }
}

public class Dog {
    private Behavior behavior;

    public Dog(Behavior behavior) {
        this.behavior = behavior;
    }

    public void move() { behavior.move(); }
    public void bark() { System.out.println("Havlıyor"); }
}
// Kompozisyon esneklik sağlar
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>8. Kopyala-Yapıştır Programlama</h2>
            <p>Kodu yeniden kullanılabilir hale getirmek yerine kopyalamak.</p>
            <p><strong>Neden Sorunlu?</strong> Bakım maliyetini artırır.</p>
            <p><strong>Nasıl Önlenir?</strong> Ortak kodu yöntemlere ayırın.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
public class Validator {
    public boolean validateA(String input) {
        if (input != null && input.length() > 5) {
            return true;
        }
        return false;
    }

    public boolean validateB(String input) {
        if (input != null && input.length() > 5) {
            return true;
        }
        return false;
    }
}
// Aynı mantık tekrar ediyor
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
public class Validator {
    private boolean validate(String input) {
        if (input != null && input.length() > 5) {
            return true;
        }
        return false;
    }

    public boolean validateA(String input) {
        return validate(input);
    }

    public boolean validateB(String input) {
        return validate(input);
    }
}
// Ortak mantık yeniden kullanılabilir
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>9. Sabit Kodlanmış Yapılandırma</h2>
            <p>Yapılandırmaları koda sabit kodlama.</p>
            <p><strong>Neden Sorunlu?</strong> Kodu esnek olmayan ve güvensiz yapar.</p>
            <p><strong>Nasıl Önlenir?</strong> Yapılandırmaları özellik dosyalarına taşıyın.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
import java.sql.Connection;
import java.sql.DriverManager;

public class DatabaseConfig {
    public Connection getConnection() {
        String dbUrl = "jdbc:mysql://localhost:3306/mydb";
        String user = "admin";
        String password = "secret";
        try {
            return DriverManager.getConnection(dbUrl, user, password);
        } catch (SQLException e) {
            throw new RuntimeException("Bağlantı hatası", e);
        }
    }
}
// Yapılandırma sabit kodlanmış, değiştirilmesi zor
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
import java.sql.Connection;
import java.sql.DriverManager;

public class DatabaseConfig {
    public Connection getConnection() {
        String dbUrl = System.getenv("DB_URL");
        String user = System.getenv("DB_USER");
        String password = System.getenv("DB_PASSWORD");
        try {
            return DriverManager.getConnection(dbUrl, user, password);
        } catch (SQLException e) {
            throw new RuntimeException("Bağlantı hatası", e);
        }
    }
}
// Yapılandırma ortam değişkenlerinden alınıyor
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>10. Aşırı Senkronizasyon</h2>
            <p>Gerekenden fazla `synchronized` kullanmak.</p>
            <p><strong>Neden Sorunlu?</strong> Performans sorunlarına yol açar.</p>
            <p><strong>Nasıl Önlenir?</strong> Yalnızca kritik bölümleri senkronize edin.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
public class Counter {
    private int count = 0;

    public synchronized void increment() {
        // Gereksiz yere tüm yöntem senkronize
        count++;
        System.out.println("Sayaç: " + count);
    }
}
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
public class Counter {
    private int count = 0;
    private final Object lock = new Object();

    public void increment() {
        synchronized (lock) {
            // Yalnızca kritik bölüm senkronize
            count++;
        }
        System.out.println("Sayaç: " + count);
    }
}
// Performans iyileştirildi
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>11. Null Pointer Sıkıntısı</h2>
            <p>Null değerlerin kötü yönetimi.</p>
            <p><strong>Neden Sorunlu?</strong> Aşırı null kontrolleri kodu karışık yapar.</p>
            <p><strong>Nasıl Önlenir?</strong> `Optional` kullanın.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
public class UserService {
    public String getUserName(User user) {
        if (user != null && user.getProfile() != null && user.getProfile().getName() != null) {
            return user.getProfile().getName();
        }
        return "Bilinmeyen";
    }
}
// Çok fazla null kontrolü
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
import java.util.Optional;

public class UserService {
    public String getUserName(User user) {
        return Optional.ofNullable(user)
                .map(User::getProfile)
                .map(Profile::getName)
                .orElse("Bilinmeyen");
    }
}
// Optional ile temiz ve güvenli kod
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>12. Katman Sızıntısı</h2>
            <p>Bir katmanın detaylarının başka bir katmana sızması.</p>
            <p><strong>Neden Sorunlu?</strong> Kapsüllemeyi bozar.</p>
            <p><strong>Nasıl Önlenir?</strong> Katmanlar arasında veri modelleri kullanın.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
import java.sql.ResultSet;

public class DataAccess {
    public ResultSet getData() {
        // SQL sorgusu çalıştır
        return connection.createStatement().executeQuery("SELECT * FROM users");
    }
}
// Veritabanı detayları üst katmana sızıyor
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
import java.util.List;

public class DataAccess {
    public List<UserModel> getData() {
        // SQL sorgusu çalıştır ve modeli dönüştür
        ResultSet rs = connection.createStatement().executeQuery("SELECT * FROM users");
        List<UserModel> users = new ArrayList<>();
        while (rs.next()) {
            users.add(new UserModel(rs.getString("name")));
        }
        return users;
    }
}
// Katmanlar ayrıştırılmış, model kullanılıyor
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>13. Meşgul Bekleme</h2>
            <p>Bir kaynağı döngüde yoklamak.</p>
            <p><strong>Neden Sorunlu?</strong> CPU kaynaklarını israf eder.</p>
            <p><strong>Nasıl Önlenir?</strong> `wait()`/`notify()` kullanın.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
public class ResourceChecker {
    private boolean ready = false;

    public void waitForResource() {
        while (!ready) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        System.out.println("Kaynak hazır");
    }
}
// CPU'yu gereksiz yere tüketiyor
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
public class ResourceChecker {
    private boolean ready = false;
    private final Object lock = new Object();

    public void waitForResource() {
        synchronized (lock) {
            while (!ready) {
                try {
                    lock.wait();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        }
        System.out.println("Kaynak hazır");
    }

    public void setReady() {
        synchronized (lock) {
            ready = true;
            lock.notify();
        }
    }
}
// CPU dostu bekleme
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>14. Aşırı Mühendislik</h2>
            <p>Gereksiz özellikler eklemek.</p>
            <p><strong>Neden Sorunlu?</strong> Bakım maliyetini artırır.</p>
            <p><strong>Nasıl Önlenir?</strong> YAGNI ilkesini takip edin.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
public class FactoryFactory {
    public AbstractFactory createFactory(String type) {
        // Gereksiz yere karmaşık fabrika hiyerarşisi
        if ("typeA".equals(type)) {
            return new TypeAFactory();
        } else {
            return new TypeBFactory();
        }
    }
}
// Gereksiz karmaşıklık
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
public class SimpleFactory {
    public Service createService(String type) {
        // Basit ve yeterli çözüm
        if ("typeA".equals(type)) {
            return new TypeAService();
        } else {
            return new TypeBService();
        }
    }
}
// YAGNI ilkesine uygun
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>15. Kaynak Yönetimi İhmali</h2>
            <p>Dosya akışları, veritabanı bağlantıları veya ağ soketleri gibi sistem kaynaklarının düzgün bir şekilde kapatılmaması, kaynak sızıntılarına yol açar. Bu anti-pattern, kaynakların açık kalmasına neden olarak uygulamanın bellek tüketimini artırır veya sistem kaynaklarının tükenmesine sebep olabilir.</p>
            <p><strong>Neden Sorunlu?</strong> Açık kalan kaynaklar, bellek sızıntılarına, dosya tanıtıcılarının tükenmesine veya veritabanı bağlantı havuzlarının dolmasına neden olabilir. Bu, uygulamanın performansını düşürür ve çökme riskini artırır.</p>
            <p><strong>Nasıl Önlenir?</strong> Java'nın try-with-resources yapısını kullanarak kaynakların otomatik olarak kapatılmasını sağlayın. Alternatif olarak, `finally` bloğunda kaynakları manuel olarak kapatabilirsiniz, ancak try-with-resources daha güvenlidir ve daha az hata eğilimlidir.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
import java.io.FileInputStream;
import java.io.IOException;

public class FileProcessor {
    public void readFile(String path) {
        FileInputStream fis = null;
        try {
            fis = new FileInputStream(path);
            // Dosya okuma işlemleri
        } catch (IOException e) {
            System.err.println("Hata: " + e.getMessage());
        }
        // fis.close() çağrısı unutuldu, kaynak sızıntısına yol açar
    }
}
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
import java.io.FileInputStream;
import java.io.IOException;

public class FileProcessor {
    public void readFile(String path) {
        try (FileInputStream fis = new FileInputStream(path)) {
            // Dosya okuma işlemleri
        } catch (IOException e) {
            System.err.println("Hata: " + e.getMessage());
        }
        // try-with-resources, fis'in otomatik kapanmasını sağlar
    }
}
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>16. Aşırı Genelleştirme</h2>
            <p>Basit bir sorunu çözmek için gereksiz yere genel bir çözüm tasarlamak.</p>
            <p><strong>Neden Sorunlu?</strong> Kod karmaşıklığını artırır ve bakımını zorlaştırır.</p>
            <p><strong>Nasıl Önlenir?</strong> Soruna özgü basit çözümler geliştirin.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
public class GenericProcessor<T extends Comparable<T>> {
    public T process(T input) {
        // Karmaşık genel mantık
        if (input != null) {
            return input;
        }
        throw new IllegalArgumentException("Girdi null olamaz");
    }
}
// Gereksiz genelleştirme
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
public class StringProcessor {
    public String process(String input) {
        // Basit ve özel mantık
        if (input != null) {
            return input.trim();
        }
        throw new IllegalArgumentException("Girdi null olamaz");
    }
}
// Soruna özel çözüm
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>17. Anemi Modeli</h2>
            <p>Nesnelerin yalnızca veri tutucusu olarak kullanılması, davranışlarının eksik olması.</p>
            <p><strong>Neden Sorunlu?</strong> Nesne yönelimli tasarım ilkelerini ihlal eder.</p>
            <p><strong>Nasıl Önlenir?</strong> Veri ve davranışı bir arada tutun.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
public class User {
    private String name;
    private String email;

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
}
// Yalnızca veri tutucu, davranış yok
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
public class User {
    private String name;
    private String email;

    public User(String name, String email) {
        this.name = name;
        this.email = email;
    }

    public String getName() { return name; }
    public String getEmail() { return email; }

    public void sendWelcomeEmail() {
        // E-posta gönderme mantığı
        System.out.println("Hoş geldiniz e-postası gönderildi: " + email);
    }
}
// Veri ve davranış bir arada
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>18. Kargo Kültü Programlama</h2>
            <p>Anlamadan kod veya pattern'leri kopyalamak, gereksiz yere uygulamak.</p>
            <p><strong>Neden Sorunlu?</strong> Gereksiz karmaşıklık ekler, hatalara yol açar.</p>
            <p><strong>Nasıl Önlenir?</strong> Kodun amacını ve bağlamını anlayın.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
public class Processor {
    public void process() {
        // Anlamadan kopyalanan karmaşık kod
        Map<String, Object> context = new ConcurrentHashMap<>();
        context.put("key", new Object());
        synchronized (context) {
            // Gereksiz senkronizasyon
            System.out.println("İşleniyor: " + context.get("key"));
        }
    }
}
// Kodun amacı belirsiz, gereksiz karmaşık
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
public class Processor {
    public void process(String data) {
        // Amaca uygun basit mantık
        System.out.println("İşleniyor: " + data);
    }
}
// Kod açık ve anlaşılır
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>19. Sert Kodlanmış Bağımlılıklar</h2>
            <p>Bağımlılıkları koda sabit kodlamak yerine enjeksiyon kullanmamak.</p>
            <p><strong>Neden Sorunlu?</strong> Test etmeyi ve değiştirmeyi zorlaştırır.</p>
            <p><strong>Nasıl Önlenir?</strong> Bağımlılık enjeksiyonu çerçeveleri kullanın.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
public class UserService {
    private Database db = new Database();

    public void saveUser(String username) {
        db.save(username);
    }
}
// Sabit bağımlılık, test etmek zor
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
public class UserService {
    private final DatabaseService dbService;

    public UserService(DatabaseService dbService) {
        this.dbService = dbService;
    }

    public void saveUser(String username) {
        dbService.save(username);
    }
}
// Bağımlılık enjeksiyonu ile test edilebilir
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>20. Büyük Ön Tasarım</h2>
            <p>Gereksinimlerin tamamını önceden tasarlamaya çalışmak.</p>
            <p><strong>Neden Sorunlu?</strong> Gereksiz zaman kaybına ve esnek olmayan tasarımlara yol açar.</p>
            <p><strong>Nasıl Önlenir?</strong> Çevik metodolojileri benimseyin.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
public class SystemDesign {
    public void initialize() {
        // Tüm sistemin detaylı tasarımı
        configureDatabase();
        configureNetwork();
        configureUI();
        // ... yüzlerce diğer yapılandırma
    }
}
// Aşırı tasarlanmış, esnek değil
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
public class ModuleService {
    public void initialize() {
        // Küçük, çevik modül tasarımı
        configureModule();
    }

    private void configureModule() {
        // Yalnızca gerekli yapılandırma
        System.out.println("Modül başlatıldı");
    }
}
// Çevik ve esnek
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>21. Döngüsel Bağımlılıklar</h2>
            <p>Sınıflar veya modüller arasında karşılıklı bağımlılıklar oluşturmak.</p>
            <p><strong>Neden Sorunlu?</strong> Kodun yeniden kullanımını ve bakımını zorlaştırır.</p>
            <p><strong>Nasıl Önlenir?</strong> Bağımlılıkları tek yönlü tutun.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
public class A {
    private B b = new B();
    public void process() { b.doSomething(); }
}

public class B {
    private A a = new A();
    public void doSomething() { a.process(); }
}
// Döngüsel bağımlılık
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
public interface Service {
    void doSomething();
}

public class A {
    private Service service;
    public A(Service svc) { this.service = svc; }
    public void process() { service.doSomething(); }
}

public class ConcreteService implements Service {
    public void doSomething() { System.out.println("Service çalışıyor"); }
}
// Bağımlılık tek yönlü
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>22. Aşırı Yansıma Kullanımı</h2>
            <p>Java'nın yansıma API'sini gereksiz yere aşırı kullanmak.</p>
            <p><strong>Neden Sorunlu?</strong> Performansı düşürür, hata ayıklamayı zorlaştırır.</p>
            <p><strong>Nasıl Önlenir?</strong> Yansıma yerine doğrudan yaklaşımlar tercih edin.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
import java.lang.reflect.Field;

public class DataUpdater {
    public void updateField(Object obj, String fieldName, String value) {
        try {
            Field field = obj.getClass().getDeclaredField(fieldName);
            field.setAccessible(true);
            field.set(obj, value);
        } catch (Exception e) {
            System.err.println("Hata: " + e.getMessage());
        }
    }
}
// Yansıma performansı düşürüyor
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
public class Data {
    private String name;

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
}

public class DataUpdater {
    public void updateField(Data data, String value) {
        data.setName(value);
    }
}
// Doğrudan erişim, hızlı ve güvenli
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>23. Kod Tekrarı</h2>
            <p>Aynı mantığı birden fazla yerde tekrar yazmak.</p>
            <p><strong>Neden Sorunlu?</strong> Bakımı zorlaştırır, hata riskini artırır.</p>
            <p><strong>Nasıl Önlenir?</strong> Ortak mantığı yöntemlere ayırın.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
public class ReportGenerator {
    public void generateUserReport() {
        // Tekrar eden mantık
        System.out.println("Rapor başlıyor");
        System.out.println("Kullanıcı verileri işleniyor");
    }

    public void generateAdminReport() {
        // Aynı mantık
        System.out.println("Rapor başlıyor");
        System.out.println("Kullanıcı verileri işleniyor");
    }
}
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
public class ReportGenerator {
    private void startReport() {
        // Ortak mantık
        System.out.println("Rapor başlıyor");
        System.out.println("Kullanıcı verileri işleniyor");
    }

    public void generateUserReport() {
        startReport();
    }

    public void generateAdminReport() {
        startReport();
    }
}
// Kod tekrarından kaçınıldı
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>24. Aşırı Genel İstisnalar</h2>
            <p>Spesifik istisnalar yerine genel `Exception` sınıfını yakalamak.</p>
            <p><strong>Neden Sorunlu?</strong> Hata türünü anlamayı zorlaştırır.</p>
            <p><strong>Nasıl Önlenir?</strong> Spesifik istisnalar yakalayın.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
import java.io.IOException;

public class DataLoader {
    public void loadData(String path) {
        try {
            Files.readString(Paths.get(path));
        } catch (Exception e) {
            System.err.println("Hata: " + e.getMessage());
        }
    }
}
// Genel istisna, hata türü belirsiz
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

public class DataLoader {
    public void loadData(String path) {
        try {
            Files.readString(Paths.get(path));
        } catch (IOException e) {
            System.err.println("Dosya okuma hatası: " + e.getMessage());
        }
    }
}
// Spesifik istisna yakalanıyor
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>25. Sabit Kodlanmış Sınır Değerleri</h2>
            <p>Döngü sınırları veya dizi boyutları gibi sabit değerleri kodda belirtmek.</p>
            <p><strong>Neden Sorunlu?</strong> Değişikliklerde hata riskini artırır.</p>
            <p><strong>Nasıl Önlenir?</strong> Dinamik hesaplamalar veya sabitler kullanın.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
public class DataSampler {
    public void sampleData(List<String> data) {
        for (int i = 0; i < 100; i++) {
            System.out.println("Veri: " + data.get(i));
        }
    }
}
// 100 sabit kodlanmış, değiştirilmesi zor
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
public class DataSampler {
    public static final int SAMPLE_SIZE = 100;

    public void sampleData(List<String> data) {
        for (int i = 0; i < SAMPLE_SIZE; i++) {
            System.out.println("Veri: " + data.get(i));
        }
    }
}
// Sabit değiştirilebilir ve anlamlı
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>26. Aşırı Loglama</h2>
            <p>Gereksiz yere fazla veya yanlış seviyede loglama yapmak.</p>
            <p><strong>Neden Sorunlu?</strong> Performansı düşürür, logları okunmaz hale getiririr.</p>
            <p><strong>Nasıl Önlenir?</strong> Log seviyelerini dikkatle seçin.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class DataProcessor {
    private static final Logger logger = LoggerFactory.getLogger(DataProcessor.class);

    public void process(String data) {
        logger.info("Data işleniyor: " + data);
        // Gereksiz yere her işlem için info logu
    }
}
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class DataProcessor {
    private static final Logger logger = LoggerFactory.getLogger(DataProcessor.class);

    public void process(String data) {
        if (logger.isDebugEnabled()) {
            logger.debug("Data işleniyor: {}", data);
        }
        // Debug düzeyinde loglama, performans dostu
    }
}
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>27. Statik Değişken Kötüye Kullanımı</h2>
            <p>Statik değişkenleri global durum yönetimi için kötüye kullanmak.</p>
            <p><strong>Neden Sorunlu?</strong> Eşzamanlılık sorunlarına yol açar.</p>
            <p><strong>Nasıl Önlenir?</strong> Statik değişkenleri yalnızca sabitler için kullanın.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
public class UserContext {
    public static String currentUser;

    public void setUser(String user) {
        currentUser = user;
    }
}
// Statik değişken, eşzamanlılık sorunlarına açık
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
public class UserSession {
    private String currentUser;

    public UserSession(String user) {
        this.currentUser = user;
    }

    public String getCurrentUser() {
        return currentUser;
    }
}
// Örnek bazlı durum yönetimi
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>28. Kod Kokusu: Uzun Yöntemler</h2>
            <p>Çok fazla iş yapan uzun yöntemler yazmak.</p>
            <p><strong>Neden Sorunlu?</strong> Okunabilirliği ve bakımı zorlaştırır.</p>
            <p><strong>Nasıl Önlenir?</strong> Yöntemleri küçük parçalara ayırın.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
public class ReportGenerator {
    public void generateReport() {
        // Uzun ve karmaşık yöntem
        System.out.println("Rapor başlatılıyor");
        List<String> data = loadData();
        for (String item : data) {
            System.out.println("Veri işleniyor: " + item);
        }
        System.out.println("Rapor tamamlandı");
    }
}
// Çok fazla sorumluluk tek yöntemde
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
public class ReportGenerator {
    public void generateReport() {
        startReport();
        processData();
        finishReport();
    }

    private void startReport() {
        System.out.println("Rapor başlatılıyor");
    }

    private void processData() {
        List<String> data = loadData();
        for (String item : data) {
            System.out.println("Veri işleniyor: " + item);
        }
    }

    private void finishReport() {
        System.out.println("Rapor tamamlandı");
    }
}
// Yöntemler ayrıştırılmış ve okunabilir
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>29. Aşırı Erişim Sağlama</h2>
            <p>Gerektiğinden fazla erişim izni vermek (ör. her şeyi `public` yapmak).</p>
            <p><strong>Neden Sorunlu?</strong> Kapsüllemeyi bozar.</p>
            <p><strong>Nasıl Önlenir?</strong> En kısıtlı erişim seviyesini kullanın.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
public class Data {
    public String value;

    public Data(String value) {
        this.value = value;
    }
}
// Değişken doğrudan erişilebilir, kapsülleme yok
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
public class Data {
    private String value;

    public Data(String value) {
        this.value = value;
    }

    public String getValue() {
        return value;
    }
}
// Kapsülleme sağlanıyor
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>30. Geçici Alan Kullanımı</h2>
            <p>Yalnızca bir yöntemde kullanılan alanları sınıf düzeyinde tanımlamak.</p>
            <p><strong>Neden Sorunlu?</strong> Bellek kullanımını artırır, sınıfı karışık hale getirir.</p>
            <p><strong>Nasıl Önlenir?</strong> Yalnızca gerekli alanları sınıf düzeyinde tanımlayın.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code class="language-java">
public class Processor {
    private int temp;

    public void process() {
        temp = 1;
        System.out.println("Geçici değer: " + temp);
    }
}
// Gereksiz sınıf alanı
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code class="language-java">
public class Processor {
    public void process() {
        int temp = 1;
        System.out.println("Geçici değer: " + temp);
    }
}
// Yalnızca yerel değişken kullanılıyor
            </code></pre>
        </div>

        <div class="tips">
            <h2>Genel Önleme İpuçları</h2>
            <ul>
                <li><strong>SOLID İlkelerini Uygulayın:</strong> Tek sorumluluk, kompozisyon ve gevşek bağlılık gibi ilkeleri benimseyin.</li>
                <li><strong>Modern Java Özelliklerini Kullanın:</strong> `Optional`, try-with-resources ve `CompletableFuture` gibi araçları tercih edin.</li>
                <li><strong>Düzenli Yeniden Düzenleme:</strong> Kodu modülerleştirin, sabitler kullanın ve mantığı ayırın.</li>
                <li><strong>Test Yazın:</strong> Birim testleri ile hataları erken yakalayın.</li>
                <li><strong>Performans Profil Oluşturun:</strong> VisualVM veya JMH gibi araçlarla gerçek darboğazları belirleyin.</li>
            </ul>
        </div>
    </div>

    <!-- Prism.js JavaScript for syntax highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
</body>
</html>