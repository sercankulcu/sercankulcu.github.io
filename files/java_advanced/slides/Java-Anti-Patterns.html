<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java'da Yaygın 30 Anti-Pattern</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        h1 {
            text-align: center;
            color: #333;
            font-size: 28px;
            margin-bottom: 20px;
        }
        p {
            color: #555;
            line-height: 1.6;
            margin-bottom: 15px;
        }
        .anti-pattern {
            border: 1px solid #ddd;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 5px;
        }
        .anti-pattern h2 {
            color: #2c3e50;
            font-size: 20px;
            margin-bottom: 10px;
        }
        .anti-pattern strong {
            color: #333;
        }
        pre {
            background-color: #f8f8f8;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 14px;
            color: #333;
        }
        code {
            font-family: 'Courier New', Courier, monospace;
        }
        .tips {
            margin-top: 30px;
            padding: 15px;
            background-color: #e8f4f8;
            border-radius: 5px;
        }
        .tips h2 {
            color: #2c3e50;
            font-size: 20px;
            margin-bottom: 10px;
        }
        .tips ul {
            list-style-type: disc;
            padding-left: 20px;
            color: #555;
        }
        .tips li {
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Java'da Yaygın 30 Anti-Pattern</h1>
        <p>Anti-pattern'ler, yazılım geliştirmede sıkça kullanılan ancak sorunlara yol açan kötü uygulamalardır. Aşağıda, Java'da karşılaşılan 30 popüler anti-pattern, açıklamaları, neden sorunlu oldukları, nasıl önlenebilecekleri ve kod örnekleri ile listelenmiştir.</p>

        <div class="anti-pattern">
            <h2>1. Singleton Kötüye Kullanımı</h2>
            <p>Bir sınıfın yalnızca tek bir örneğinin olmasını sağlamak için Singleton pattern'inin aşırı kullanımı, global durum sorunlarına ve test zorluklarına yol açar.</p>
            <p><strong>Neden Sorunlu?</strong> Test edilmesi zor, gizli bağımlılıklar yaratır ve Tek Sorumluluk İlkesini ihlal eder.</p>
            <p><strong>Nasıl Önlenir?</strong> Singleton yerine bağımlılık enjeksiyonu kullanın veya durum yönetimini dikkatle yapın.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code>
public class DatabaseConnection {
    private static DatabaseConnection instance = new DatabaseConnection();
    private DatabaseConnection() {}
    public static DatabaseConnection getInstance() { return instance; }
    // Bağlantı mantığı
}
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code>
public class DatabaseConnection {
    private Connection conn;
    public DatabaseConnection(Connection conn) { this.conn = conn; }
    // Bağlantı mantığı
}
// Bağımlılık enjeksiyonu ile kullanım
DatabaseConnection db = new DatabaseConnection(dataSource.getConnection());
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>2. Tanrı Nesnesi (God Object)</h2>
            <p>Tek bir sınıfın çok fazla sorumluluk üstlenmesi, kodun şişmesine ve bakımının zorlaşmasına neden olur.</p>
            <p><strong>Neden Sorunlu?</strong> Tek Sorumluluk İlkesini ihlal eder, karmaşıklığı artırır.</p>
            <p><strong>Nasıl Önlenir?</strong> Sorumlulukları ayırarak sınıfları daha küçük ve odaklanmış hale getirin.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code>
public class UserManager {
    public void authenticateUser() { /* ... */ }
    public void saveToDatabase() { /* ... */ }
    public void sendEmail() { /* ... */ }
}
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code>
public class AuthService { public void authenticateUser() { /* ... */ } }
public class DatabaseService { public void saveToDatabase() { /* ... */ } }
public class EmailService { public void sendEmail() { /* ... */ } }
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>3. Spagetti Kod</h2>
            <p>Karmakarışık kontrol akışları ve modüler olmayan kod yapısı.</p>
            <p><strong>Neden Sorunlu?</strong> Okunması, bakımı ve hata ayıklaması zor.</p>
            <p><strong>Nasıl Önlenir?</strong> Kodunuzu modülerleştirin, yöntemleri ayırın.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code>
public void process() {
    if (condition) {
        for (int i = 0; i < 10; i++) {
            // Karmaşık mantık
        }
    }
}
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code>
public void process() { if (condition) { processItems(); } }
private void processItems() { for (int i = 0; i < 10; i++) { /* ... */ } }
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>4. Sihirli Sayılar/Dizeler</h2>
            <p>Sabit kodlanmış sayılar veya dizeler yerine adlandırılmış sabitler kullanmamak.</p>
            <p><strong>Neden Sorunlu?</strong> Kodu anlaşılmaz yapar, hata riskini artırır.</p>
            <p><strong>Nasıl Önlenir?</strong> Sabitler için `static final` kullanın.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code>
if (status == 42) { /* ... */ }
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code>
public static final int ACTIVE_STATUS = 42;
if (status == ACTIVE_STATUS) { /* ... */ }
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>5. Erken Optimizasyon</h2>
            <p>Gerçek performans sorunları belirlenmeden önce optimize etmeye çalışmak.</p>
            <p><strong>Neden Sorunlu?</strong> Gereksiz karmaşıklık ekler.</p>
            <p><strong>Nasıl Önlenir?</strong> Performans sorunlarını profil araçlarıyla belirleyin.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code>
public void complexSort(List<String> list) { /* Karmaşık sıralama algoritması */ }
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code>
public void sort(List<String> list) { Collections.sort(list); }
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>6. İstisna Yutma</h2>
            <p>İstisnaları yakalayıp işleme veya loglama yapmadan boş bırakma.</p>
            <p><strong>Neden Sorunlu?</strong> Hataları gizler, hata ayıklamayı zorlaştırır.</p>
            <p><strong>Nasıl Önlenir?</strong> İstisnaları loglayın veya yeniden fırlatın.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code>
try { doSomething(); } catch (Exception e) {}
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code>
try { doSomething(); } catch (Exception e) { log.error("Hata oluştu", e); }
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>7. Aşırı Miras Kullanımı</h2>
            <p>Kompozisyon yerine mirası aşırı kullanmak.</p>
            <p><strong>Neden Sorunlu?</strong> Sıkı bağımlılıklar yaratır.</p>
            <p><strong>Nasıl Önlenir?</strong> Kompozisyonu tercih edin.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code>
public class Dog extends Mammal { /* ... */ }
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code>
public class Dog { private MammalBehavior behavior; /* ... */ }
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>8. Kopyala-Yapıştır Programlama</h2>
            <p>Kodu yeniden kullanılabilir hale getirmek yerine kopyalamak.</p>
            <p><strong>Neden Sorunlu?</strong> Bakım maliyetini artırır.</p>
            <p><strong>Nasıl Önlenir?</strong> Ortak kodu yöntemlere ayırın.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code>
public void validateA() { /* Aynı doğrulama mantığı */ }
public void validateB() { /* Aynı doğrulama mantığı */ }
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code>
private void validate() { /* Doğrulama mantığı */ }
public void validateA() { validate(); }
public void validateB() { validate(); }
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>9. Sabit Kodlanmış Yapılandırma</h2>
            <p>Yapılandırmaları koda sabit kodlama.</p>
            <p><strong>Neden Sorunlu?</strong> Kodu esnek olmayan ve güvensiz yapar.</p>
            <p><strong>Nasıl Önlenir?</strong> Yapılandırmaları özellik dosyalarına taşıyın.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code>
String dbUrl = "jdbc:mysql://localhost:3306/mydb";
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code>
String dbUrl = System.getenv("DB_URL");
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>10. Aşırı Senkronizasyon</h2>
            <p>Gerekenden fazla `synchronized` kullanmak.</p>
            <p><strong>Neden Sorunlu?</strong> Performans sorunlarına yol açar.</p>
            <p><strong>Nasıl Önlenir?</strong> Yalnızca kritik bölümleri senkronize edin.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code>
public synchronized void update() { /* ... */ }
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code>
public void update() { synchronized(lock) { /* Kritik bölüm */ } }
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>11. Null Pointer Sıkıntısı</h2>
            <p>Null değerlerin kötü yönetimi.</p>
            <p><strong>Neden Sorunlu?</strong> Aşırı null kontrolleri kodu karışık yapar.</p>
            <p><strong>Nasıl Önlenir?</strong> `Optional` kullanın.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code>
if (obj != null && obj.getProperty() != null) { /* ... */ }
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code>
Optional.ofNullable(obj).map(Obj::getProperty).ifPresent(p -> { /* ... */ });
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>12. Katman Sızıntısı</h2>
            <p>Bir katmanın detaylarının başka bir katmana sızması.</p>
            <p><strong>Neden Sorunlu?</strong> Kapsüllemeyi bozar.</p>
            <p><strong>Nasıl Önlenir?</strong> Katmanlar arasında veri modelleri kullanın.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code>
public ResultSet getData() { /* SQL sonucu */ }
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code>
public List<DataModel> getData() { /* Model listesi */ }
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>13. Meşgul Bekleme</h2>
            <p>Bir kaynağı döngüde yoklamak.</p>
            <p><strong>Neden Sorunlu?</strong> CPU kaynaklarını israf eder.</p>
            <p><strong>Nasıl Önlenir?</strong> `wait()`/`notify()` kullanın.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code>
while (!isReady()) { Thread.sleep(100); }
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code>
synchronized(lock) { while (!isReady()) lock.wait(); }
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>14. Aşırı Mühendislik</h2>
            <p>Gereksiz özellikler eklemek.</p>
            <p><strong>Neden Sorunlu?</strong> Bakım maliyetini artırır.</p>
            <p><strong>Nasıl Önlenir?</strong> YAGNI ilkesini takip edin.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code>
public class FactoryFactory { /* Karmaşık fabrika */ }
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code>
public class SimpleFactory { /* Basit fabrika */ }
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>15. Kaynak Yönetimi İhmali</h2>
            <p>Dosya akışları, veritabanı bağlantıları veya ağ soketleri gibi sistem kaynaklarının düzgün bir şekilde kapatılmaması, kaynak sızıntılarına yol açar. Bu anti-pattern, kaynakların açık kalmasına neden olarak uygulamanın bellek tüketimini artırır veya sistem kaynaklarının tükenmesine sebep olabilir.</p>
            <p><strong>Neden Sorunlu?</strong> Açık kalan kaynaklar, bellek sızıntılarına, dosya tanıtıcılarının tükenmesine veya veritabanı bağlantı havuzlarının dolmasına neden olabilir. Bu, uygulamanın performansını düşürür ve çökme riskini artırır.</p>
            <p><strong>Nasıl Önlenir?</strong> Java'nın try-with-resources yapısını kullanarak kaynakların otomatik olarak kapatılmasını sağlayın. Alternatif olarak, `finally` bloğunda kaynakları manuel olarak kapatabilirsiniz, ancak try-with-resources daha güvenlidir ve daha az hata eğilimlidir.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code>
import java.io.FileInputStream;
import java.io.IOException;

public class FileProcessor {
    public void readFile(String path) {
        FileInputStream fis = null;
        try {
            fis = new FileInputStream(path);
            // Dosya okuma işlemleri
        } catch (IOException e) {
            System.err.println("Hata: " + e.getMessage());
        }
        // fis.close() çağrısı unutuldu, kaynak sızıntısına yol açar
    }
}
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code>
import java.io.FileInputStream;
import java.io.IOException;

public class FileProcessor {
    public void readFile(String path) {
        try (FileInputStream fis = new FileInputStream(path)) {
            // Dosya okuma işlemleri
        } catch (IOException e) {
            System.err.println("Hata: " + e.getMessage());
        }
        // try-with-resources, fis'in otomatik kapanmasını sağlar
    }
}
            </code></pre>
        </div>
		
		
		<div class="anti-pattern">
            <h2>16. Aşırı Genelleştirme</h2>
            <p>Basit bir sorunu çözmek için gereksiz yere genel bir çözüm tasarlamak.</p>
            <p><strong>Neden Sorunlu?</strong> Kod karmaşıklığını artırır ve bakımını zorlaştırır.</p>
            <p><strong>Nasıl Önlenir?</strong> Soruna özgü basit çözümler geliştirin.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code>
public class GenericProcessor<T extends Comparable<T>> {
    public T process(T input) { /* Karmaşık genel mantık */ }
}
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code>
public class StringProcessor {
    public String process(String input) { /* Basit mantık */ }
}
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>17. Anemi Modeli</h2>
            <p>Nesnelerin yalnızca veri tutucusu olarak kullanılması, davranışlarının eksik olması.</p>
            <p><strong>Neden Sorunlu?</strong> Nesne yönelimli tasarım ilkelerini ihlal eder.</p>
            <p><strong>Nasıl Önlenir?</strong> Veri ve davranışı bir arada tutun.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code>
public class User {
    private String name;
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
}
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code>
public class User {
    private String name;
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public void sendWelcomeEmail() { /* E-posta gönderme mantığı */ }
}
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>18. Kargo Kültü Programlama</h2>
            <p>Anlamadan kod veya pattern'leri kopyalamak, gereksiz yere uygulamak.</p>
            <p><strong>Neden Sorunlu?</strong> Gereksiz karmaşıklık ekler, hatalara yol açar.</p>
            <p><strong>Nasıl Önlenir?</strong> Kodun amacını ve bağlamını anlayın.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code>
public class Processor {
    // Anlamadan kopyalanmış karmaşık kod
    public void process() { /* Gereksiz karmaşık mantık */ }
}
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code>
public class Processor {
    public void process() { /* Amaca uygun basit mantık */ }
}
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>19. Sert Kodlanmış Bağımlılıklar</h2>
            <p>Bağımlılıkları koda sabit kodlamak yerine enjeksiyon kullanmamak.</p>
            <p><strong>Neden Sorunlu?</strong> Test etmeyi ve değiştirmeyi zorlaştırır.</p>
            <p><strong>Nasıl Önlenir?</strong> Bağımlılık enjeksiyonu çerçeveleri kullanın.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code>
public class Service {
    private Database db = new Database();
}
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code>
public class Service {
    private Database db;
    public Service(Database db) { this.db = db; }
}
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>20. Büyük Ön Tasarım</h2>
            <p>Gereksinimlerin tamamını önceden tasarlamaya çalışmak.</p>
            <p><strong>Neden Sorunlu?</strong> Gereksiz zaman kaybına ve esnek olmayan tasarımlara yol açar.</p>
            <p><strong>Nasıl Önlenir?</strong> Çevik metodolojileri benimseyin.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code>
public class SystemDesign {
    // Tüm sistemi kapsayan karmaşık tasarım
}
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code>
public class Module {
    // Küçük, çevik modül tasarımı
}
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>21. Döngüsel Bağımlılıklar</h2>
            <p>Sınıflar veya modüller arasında karşılıklı bağımlılıklar oluşturmak.</p>
            <p><strong>Neden Sorunlu?</strong> Kodun yeniden kullanımını ve bakımını zorlaştırır.</p>
            <p><strong>Nasıl Önlenir?</strong> Bağımlılıkları tek yönlü tutun.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code>
public class A { B b = new B(); }
public class B { A a = new A(); }
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code>
public class A { private Service service; }
public class Service { /* Bağımsız mantık */ }
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>22. Aşırı Yansıma Kullanımı</h2>
            <p>Java'nın yansıma API'sini gereksiz yere aşırı kullanmak.</p>
            <p><strong>Neden Sorunlu?</strong> Performansı düşürür, hata ayıklamayı zorlaştırır.</p>
            <p><strong>Nasıl Önlenir?</strong> Yansıma yerine doğrudan yaklaşımlar tercih edin.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code>
Field field = clazz.getDeclaredField("name");
field.setAccessible(true);
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code>
public class Data { public String getName() { return name; } }
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>23. Kod Tekrarı</h2>
            <p>Aynı mantığı birden fazla yerde tekrar yazmak.</p>
            <p><strong>Neden Sorunlu?</strong> Bakımı zorlaştırır, hata riskini artırır.</p>
            <p><strong>Nasıl Önlenir?</strong> Ortak mantığı yöntemlere ayırın.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code>
public void method1() { /* Tekrar eden mantık */ }
public void method2() { /* Aynı mantık */ }
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code>
private void commonLogic() { /* Ortak mantık */ }
public void method1() { commonLogic(); }
public void method2() { commonLogic(); }
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>24. Aşırı Genel İstisnalar</h2>
            <p>Spesifik istisnalar yerine genel `Exception` sınıfını yakalamak.</p>
            <p><strong>Neden Sorunlu?</strong> Hata türünü anlamayı zorlaştırır.</p>
            <p><strong>Nasıl Önlenir?</strong> Spesifik istisnalar yakalayın.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code>
try { /* Kod */ } catch (Exception e) { /* İşleme */ }
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code>
try { /* Kod */ } catch (IOException e) { /* Spesifik işleme */ }
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>25. Sabit Kodlanmış Sınır Değerleri</h2>
            <p>Döngü sınırları veya dizi boyutları gibi sabit değerleri kodda belirtmek.</p>
            <p><strong>Neden Sorunlu?</strong> Değişikliklerde hata riskini artırır.</p>
            <p><strong>Nasıl Önlenir?</strong> Dinamik hesaplamalar veya sabitler kullanın.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code>
for (int i = 0; i < 100; i++) { /* ... */ }
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code>
public static final int LIMIT = 100;
for (int i = 0; i < LIMIT; i++) { /* ... */ }
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>26. Aşırı Loglama</h2>
            <p>Gereksiz yere fazla veya yanlış seviyede loglama yapmak.</p>
            <p><strong>Neden Sorunlu?</strong> Performansı düşürür, logları okunmaz hale getirir.</p>
            <p><strong>Nasıl Önlenir?</strong> Log seviyelerini dikkatle seçin.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code>
log.info("Değişken: " + var);
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code>
if (log.isDebugEnabled()) { log.debug("Değişken: {}", var); }
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>27. Statik Değişken Kötüye Kullanımı</h2>
            <p>Statik değişkenleri global durum yönetimi için kötüye kullanmak.</p>
            <p><strong>Neden Sorunlu?</strong> Eşzamanlılık sorunlarına yol açar.</p>
            <p><strong>Nasıl Önlenir?</strong> Statik değişkenleri yalnızca sabitler için kullanın.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code>
public static String currentUser;
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code>
public class Session { private String currentUser; }
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>28. Kod Kokusu: Uzun Yöntemler</h2>
            <p>Çok fazla iş yapan uzun yöntemler yazmak.</p>
            <p><strong>Neden Sorunlu?</strong> Okunabilirliği ve bakımı zorlaştırır.</p>
            <p><strong>Nasıl Önlenir?</strong> Yöntemleri küçük parçalara ayırın.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code>
public void process() { /* 100 satırlık kod */ }
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code>
public void process() { step1(); step2(); }
private void step1() { /* ... */ }
private void step2() { /* ... */ }
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>29. Aşırı Erişim Sağlama</h2>
            <p>Gerektiğinden daha fazla erişim izni vermek (ör. her şeyi `public` yapmak).</p>
            <p><strong>Neden Sorunlu?</strong> Kapsüllemeyi bozar.</p>
            <p><strong>Nasıl Önlenir?</strong> En kısıtlı erişim seviyesini kullanın.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code>
public class Data { public String value; }
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code>
public class Data {
    private String value;
    public String getValue() { return value; }
}
            </code></pre>
        </div>

        <div class="anti-pattern">
            <h2>30. Geçici Alan Kullanımı</h2>
            <p>Yalnızca bir yöntemde kullanılan alanları sınıf düzeyinde tanımlamak.</p>
            <p><strong>Neden Sorunlu?</strong> Bellek kullanımını artırır, sınıfı karışık hale getirir.</p>
            <p><strong>Nasıl Önlenir?</strong> Yalnızca gerekli alanları sınıf düzeyinde tanımlayın.</p>
            <p><strong>Kötü Örnek:</strong></p>
            <pre><code>
public class Processor {
    private int temp;
    public void process() { temp = 1; /* Kullanım */ }
}
            </code></pre>
            <p><strong>İyi Örnek:</strong></p>
            <pre><code>
public class Processor {
    public void process() { int temp = 1; /* Kullanım */ }
}
            </code></pre>
        </div>

        <div class="tips">
            <h2>Genel Önleme İpuçları</h2>
            <ul>
                <li><strong>SOLID İlkelerini Uygulayın:</strong> Tek sorumluluk, kompozisyon ve gevşek bağlılık gibi ilkeleri benimseyin.</li>
                <li><strong>Modern Java Özelliklerini Kullanın:</strong> `Optional`, try-with-resources ve `CompletableFuture` gibi araçları tercih edin.</li>
                <li><strong>Düzenli Yeniden Düzenleme:</strong> Kodu modülerleştirin, sabitler kullanın ve mantığı ayırın.</li>
                <li><strong>Test Yazın:</strong> Birim testleri ile hataları erken yakalayın.</li>
                <li><strong>Performans Profil Oluşturun:</strong> VisualVM veya JMH gibi araçlarla gerçek darboğazları belirleyin.</li>
            </ul>
        </div>
    </div>
</body>
</html>